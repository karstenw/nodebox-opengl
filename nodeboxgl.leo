<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="karstenw.20231124170756.2" a="E"><vh>nodeboxgl</vh>
<v t="karstenw.20231124170851.1" a="E"><vh>library</vh>
<v t="karstenw.20231124170956.1" a="E"><vh>@clean nodeboxgl/__init__.py</vh>
<v t="karstenw.20231124171037.1"><vh>Declarations</vh></v>
</v>
<v t="karstenw.20231124170856.1" a="E"><vh>ext</vh>
<v t="karstenw.20231124171143.1"><vh>@clean nodeboxgl/ext/setup.py</vh>
<v t="karstenw.20231124171244.1"><vh>Declarations</vh></v>
</v>
</v>
<v t="karstenw.20231124170908.1"><vh>font</vh>
<v t="karstenw.20240123172532.1"><vh>@clean nodeboxgl/font/glyph.py</vh>
<v t="karstenw.20240123172554.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172554.2"><vh>descent</vh></v>
<v t="karstenw.20240123172554.3"><vh>textpath_from_glyphs</vh></v>
</v>
</v>
<v t="karstenw.20231124170943.1" a="E"><vh>graphics</vh>
<v t="karstenw.20240123172657.1" a="E"><vh>@clean nodeboxgl/graphics/__init__.py</vh>
<v t="karstenw.20240123172922.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172922.2"><vh>size</vh></v>
<v t="karstenw.20240123172922.3"><vh>speed</vh></v>
<v t="karstenw.20240123172922.4"><vh>frame</vh></v>
<v t="karstenw.20240123172922.5"><vh>clear</vh></v>
</v>
<v t="karstenw.20240123172734.1"><vh>@clean nodeboxgl/graphics/bezier.py</vh>
<v t="karstenw.20240123172920.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172920.2"><vh>class DynamicPathElement</vh></v>
<v t="karstenw.20240126154716.1"><vh>+ BEZIERMATH +</vh>
<v t="karstenw.20240123172920.3"><vh>linepoint</vh></v>
<v t="karstenw.20240123172920.4"><vh>linelength</vh></v>
<v t="karstenw.20240123172920.5"><vh>curvepoint</vh></v>
</v>
<v t="karstenw.20240126154749.1"><vh>+ BEZIER PATH LENGTH +</vh>
<v t="karstenw.20240123172920.6"><vh>curvelength</vh></v>
<v t="karstenw.20240123172920.7"><vh>segment_lengths</vh></v>
<v t="karstenw.20240123172920.8"><vh>length</vh></v>
</v>
<v t="karstenw.20240126154832.1"><vh>+ BEZIER PATH POINT +</vh>
<v t="karstenw.20240123172920.9"><vh>_locate</vh></v>
<v t="karstenw.20240123172920.10"><vh>point</vh></v>
<v t="karstenw.20240123172920.11"><vh>points</vh></v>
</v>
<v t="karstenw.20240126154916.1"><vh>+ BEZIER PATH CONTOURS +</vh>
<v t="karstenw.20240123172920.12"><vh>contours</vh></v>
</v>
<v t="karstenw.20240126154940.1"><vh>+ BEZIER PATH FROM POINTS +</vh>
<v t="karstenw.20240123172920.13"><vh>findpath</vh></v>
</v>
<v t="karstenw.20240126155025.1"><vh>+ BEZIER PATH INSERT POINT +</vh>
<v t="karstenw.20240123172920.14"><vh>insert_point</vh></v>
</v>
<v t="karstenw.20240126155058.1"><vh>+ BEZIER ARC +</vh>
<v t="karstenw.20240123172920.15"><vh>arc</vh></v>
<v t="karstenw.20240123172920.16"><vh>arcto</vh></v>
</v>
</v>
<v t="karstenw.20240123172753.1"><vh>@clean nodeboxgl/graphics/context.py</vh>
<v t="karstenw.20240123172917.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172917.2"><vh>getscreenconf</vh></v>
<v t="karstenw.20240126155307.1" a="E"><vh>+ CACHING +</vh>
<v t="karstenw.20240123172917.3"><vh>precompile</vh></v>
<v t="karstenw.20240123172917.4"><vh>precompiled</vh></v>
</v>
<v t="karstenw.20240123172917.5"><vh>flush</vh></v>
<v t="karstenw.20240126155339.1"><vh>+ COLOR +</vh>
<v t="karstenw.20240123172917.6"><vh>class Color</vh>
<v t="karstenw.20240123172917.7"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.8"><vh>__setitem__</vh></v>
<v t="karstenw.20240123172917.9"><vh>_get_r</vh></v>
<v t="karstenw.20240123172917.10"><vh>_get_g</vh></v>
<v t="karstenw.20240123172917.11"><vh>_get_b</vh></v>
<v t="karstenw.20240123172917.12"><vh>_get_a</vh></v>
<v t="karstenw.20240123172917.13"><vh>_set_r</vh></v>
<v t="karstenw.20240123172917.14"><vh>_set_g</vh></v>
<v t="karstenw.20240123172917.15"><vh>_set_b</vh></v>
<v t="karstenw.20240123172917.16"><vh>_set_a</vh></v>
<v t="karstenw.20240123172917.17"><vh>_get_rgb</vh></v>
<v t="karstenw.20240123172917.18"><vh>_set_rgb</vh></v>
<v t="karstenw.20240123172917.19"><vh>_get_rgba</vh></v>
<v t="karstenw.20240123172917.20"><vh>_set_rgba</vh></v>
<v t="karstenw.20240123172917.21"><vh>copy</vh></v>
<v t="karstenw.20240123172917.22"><vh>_apply</vh></v>
<v t="karstenw.20240123172917.23"><vh>__repr__</vh></v>
<v t="karstenw.20240123172917.24"><vh>__eq__</vh></v>
<v t="karstenw.20240123172917.25"><vh>__ne__</vh></v>
<v t="karstenw.20240123172917.26"><vh>map</vh></v>
<v t="karstenw.20240123172917.27"><vh>blend</vh></v>
<v t="karstenw.20240123172917.28"><vh>rotate</vh></v>
</v>
<v t="karstenw.20240123172917.29"><vh>background</vh></v>
<v t="karstenw.20240123172917.30"><vh>fill</vh></v>
<v t="karstenw.20240123172917.31"><vh>stroke</vh></v>
<v t="karstenw.20240123172917.32"><vh>nofill</vh></v>
<v t="karstenw.20240123172917.33"><vh>nostroke</vh></v>
<v t="karstenw.20240123172917.34"><vh>strokewidth</vh></v>
<v t="karstenw.20240123172917.35"><vh>strokestyle</vh></v>
<v t="karstenw.20240123172917.36"><vh>glLineDash</vh></v>
<v t="karstenw.20240123172917.37"><vh>outputmode</vh></v>
</v>
<v t="karstenw.20240123172917.38"><vh>colormode</vh></v>
<v t="karstenw.20240126155445.1"><vh>+ COLOR SPACE +</vh>
<v t="karstenw.20240123172917.39"><vh>rgb_to_hsb</vh></v>
<v t="karstenw.20240123172917.40"><vh>hsb_to_rgb</vh></v>
<v t="karstenw.20240123172917.41"><vh>rgb_to_xyz</vh></v>
<v t="karstenw.20240123172917.42"><vh>xyz_to_rgb</vh></v>
<v t="karstenw.20240123172917.43"><vh>rgb_to_lab</vh></v>
<v t="karstenw.20240123172917.44"><vh>lab_to_rgb</vh></v>
<v t="karstenw.20240123172917.45"><vh>luminance</vh></v>
<v t="karstenw.20240123172917.46"><vh>darker</vh></v>
<v t="karstenw.20240123172917.47"><vh>lighter</vh></v>
</v>
<v t="karstenw.20240126155525.1"><vh>+ COLOR ROTATION +</vh>
<v t="karstenw.20240123172917.48"><vh>rotate_ryb</vh></v>
<v t="karstenw.20240123172917.49"><vh>complement</vh></v>
<v t="karstenw.20240123172917.50"><vh>analog</vh></v>
</v>
<v t="karstenw.20240126155550.1"><vh>+ COLOR MIXIN +</vh>
<v t="karstenw.20240123172917.51"><vh>color_mixin</vh></v>
</v>
<v t="karstenw.20240126155609.1"><vh>+ COLOR PLANE +</vh>
<v t="karstenw.20240123172917.52"><vh>colorplane</vh></v>
</v>
<v t="karstenw.20240126155632.1"><vh>+ TRANSFORMATIONS +</vh>
<v t="karstenw.20240123172917.53"><vh>push</vh></v>
<v t="karstenw.20240123172917.54"><vh>pop</vh></v>
<v t="karstenw.20240123172917.55"><vh>translate</vh></v>
<v t="karstenw.20240123172917.56"><vh>rotate</vh></v>
<v t="karstenw.20240123172917.57"><vh>scale</vh></v>
<v t="karstenw.20240123172917.58"><vh>reset</vh></v>
<v t="karstenw.20240123172917.59"><vh>transform</vh></v>
<v t="karstenw.20240123172917.60"><vh>skew</vh></v>
</v>
<v t="karstenw.20240126155731.1"><vh>+ DRAWING PRIMITIVES +</vh>
<v t="karstenw.20240123172917.61"><vh>line</vh></v>
<v t="karstenw.20240123172917.62"><vh>rect</vh></v>
<v t="karstenw.20240123172917.63"><vh>triangle</vh></v>
<v t="karstenw.20240123172917.64"><vh>ellipse</vh></v>
<v t="karstenw.20240123172917.65"><vh>arrow</vh></v>
<v t="karstenw.20240123172917.66"><vh>gcd</vh></v>
<v t="karstenw.20240123172917.67"><vh>fast_star</vh></v>
<v t="karstenw.20240123172917.68"><vh>star</vh></v>
</v>
<v t="karstenw.20240126155903.1" a="E"><vh>BEZIER PATH</vh>
<v t="karstenw.20240123172917.69"><vh>class PathError</vh></v>
<v t="karstenw.20240123172917.70"><vh>class NoCurrentPointForPath</vh></v>
<v t="karstenw.20240123172917.71"><vh>class NoCurrentPath</vh></v>
<v t="karstenw.20240123172917.72"><vh>class PathPoint</vh>
<v t="karstenw.20240123172917.73"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.74"><vh>_get_x</vh></v>
<v t="karstenw.20240123172917.75"><vh>_set_x</vh></v>
<v t="karstenw.20240123172917.76"><vh>_get_y</vh></v>
<v t="karstenw.20240123172917.77"><vh>_set_y</vh></v>
<v t="karstenw.20240123172917.78"><vh>copy</vh></v>
</v>
<v t="karstenw.20240123172917.79"><vh>class PathElement</vh>
<v t="karstenw.20240123172917.80"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.81"><vh>_get_dirty</vh></v>
<v t="karstenw.20240123172917.82"><vh>_set_dirty</vh></v>
<v t="karstenw.20240123172917.83"><vh>cmd</vh></v>
<v t="karstenw.20240123172917.84"><vh>_get_x</vh></v>
<v t="karstenw.20240123172917.85"><vh>_set_x</vh></v>
<v t="karstenw.20240123172917.86"><vh>_get_y</vh></v>
<v t="karstenw.20240123172917.87"><vh>_set_y</vh></v>
<v t="karstenw.20240123172917.88"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172917.89"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172917.90"><vh>_get_ctrl1</vh></v>
<v t="karstenw.20240123172917.91"><vh>_set_ctrl1</vh></v>
<v t="karstenw.20240123172917.92"><vh>_get_ctrl2</vh></v>
<v t="karstenw.20240123172917.93"><vh>_set_ctrl2</vh></v>
<v t="karstenw.20240123172917.94"><vh>__eq__</vh></v>
<v t="karstenw.20240123172917.95"><vh>__ne__</vh></v>
<v t="karstenw.20240123172917.96"><vh>__repr__</vh></v>
<v t="karstenw.20240123172917.97"><vh>copy</vh></v>
</v>
<v t="karstenw.20240123172917.98" a="E"><vh>class BezierPath</vh>
<v t="karstenw.20240123172917.99"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.100"><vh>copy</vh></v>
<v t="karstenw.20240123172917.101"><vh>append</vh></v>
<v t="karstenw.20240123172917.102"><vh>extend</vh></v>
<v t="karstenw.20240123172917.103"><vh>insert</vh></v>
<v t="karstenw.20240123172917.104"><vh>remove</vh></v>
<v t="karstenw.20240123172917.105"><vh>pop</vh></v>
<v t="karstenw.20240123172917.106"><vh>__setitem__</vh></v>
<v t="karstenw.20240123172917.107"><vh>__delitem__</vh></v>
<v t="karstenw.20240123172917.108"><vh>sort</vh></v>
<v t="karstenw.20240123172917.109"><vh>reverse</vh></v>
<v t="karstenw.20240123172917.110"><vh>index</vh></v>
<v t="karstenw.20240123172917.111"><vh>_update</vh></v>
<v t="karstenw.20240123172917.112"><vh>moveto</vh></v>
<v t="karstenw.20240123172917.113"><vh>lineto</vh></v>
<v t="karstenw.20240123172917.114"><vh>curveto</vh></v>
<v t="karstenw.20240123172917.115"><vh>arcto</vh></v>
<v t="karstenw.20240123172917.116"><vh>closepath</vh></v>
<v t="karstenw.20240123172917.117"><vh>rect</vh></v>
<v t="karstenw.20240123172917.118"><vh>ellipse</vh></v>
<v t="karstenw.20240123172917.119"><vh>arc</vh></v>
<v t="karstenw.20240123172917.120"><vh>smooth</vh></v>
<v t="karstenw.20240123172917.121"><vh>flatten</vh></v>
<v t="karstenw.20240123172917.122"><vh>draw</vh></v>
<v t="karstenw.20240123172917.123"><vh>angle</vh></v>
<v t="karstenw.20240123172917.124"><vh>point</vh></v>
<v t="karstenw.20240123172917.125"><vh>points</vh></v>
<v t="karstenw.20240123172917.126"><vh>addpoint</vh></v>
<v t="karstenw.20240123172917.127"><vh>length</vh></v>
<v t="karstenw.20240123172917.128"><vh>contours</vh></v>
<v t="karstenw.20240123172917.129"><vh>bounds</vh></v>
<v t="karstenw.20240123172917.130"><vh>contains</vh></v>
<v t="karstenw.20240123172917.131"><vh>hash</vh></v>
<v t="karstenw.20240123172917.132"><vh>__repr__</vh></v>
<v t="karstenw.20240123172917.133"><vh>__del__</vh></v>
</v>
<v t="karstenw.20240123172917.134"><vh>drawpath</vh></v>
<v t="karstenw.20240123172917.135"><vh>autoclosepath</vh></v>
<v t="karstenw.20240123172917.136"><vh>beginpath</vh></v>
<v t="karstenw.20240123172917.137"><vh>moveto</vh></v>
<v t="karstenw.20240123172917.138"><vh>lineto</vh></v>
<v t="karstenw.20240123172917.139"><vh>curveto</vh></v>
<v t="karstenw.20240123172917.140"><vh>closepath</vh></v>
<v t="karstenw.20240123172917.141"><vh>endpath</vh></v>
</v>
<v t="karstenw.20240123172917.142"><vh>findpath</vh></v>
<v t="karstenw.20240126155952.1"><vh>+ BEZIER EDITOR +</vh>
<v t="karstenw.20240123172917.143"><vh>class BezierEditor</vh>
<v t="karstenw.20240123172917.144"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.145"><vh>_nextpoint</vh></v>
<v t="karstenw.20240123172917.146"><vh>translate</vh></v>
<v t="karstenw.20240123172917.147"><vh>rotate</vh></v>
<v t="karstenw.20240123172917.148"><vh>scale</vh></v>
<v t="karstenw.20240123172917.149"><vh>smooth</vh></v>
</v>
</v>
<v t="karstenw.20240126160010.1"><vh>+ POINT ANGLES +</vh>
<v t="karstenw.20240123172917.150"><vh>directed</vh></v>
</v>
<v t="karstenw.20240126160022.1"><vh>+ CLIPPING PATH +</vh>
<v t="karstenw.20240123172917.151"><vh>class ClippingMask</vh>
<v t="karstenw.20240123172917.152"><vh>draw</vh></v>
</v>
<v t="karstenw.20240123172917.153"><vh>beginclip</vh></v>
<v t="karstenw.20240123172917.154"><vh>endclip</vh></v>
</v>
<v t="karstenw.20240126160104.1"><vh>+ SUPERSHAPE +</vh>
<v t="karstenw.20240123172917.155"><vh>supershape</vh></v>
</v>
<v t="karstenw.20240126160123.1" a="E"><vh>+ IMAGE +</vh>
<v t="karstenw.20240123172917.156"><vh>ceil2</vh></v>
<v t="karstenw.20240123172917.157"><vh>class ImageError</vh></v>
<v t="karstenw.20240123172917.158"><vh>texture</vh></v>
<v t="karstenw.20240123172917.159"><vh>cache</vh></v>
<v t="karstenw.20240123172917.160"><vh>cached</vh></v>
<v t="karstenw.20240123172917.161"><vh>_render</vh></v>
<v t="karstenw.20240123172917.162"><vh>class Quad</vh>
<v t="karstenw.20240123172917.163"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.164"><vh>copy</vh></v>
<v t="karstenw.20240123172917.165"><vh>reset</vh></v>
<v t="karstenw.20240123172917.166"><vh>__setitem__</vh></v>
<v t="karstenw.20240123172917.167"><vh>_get_dx1</vh></v>
<v t="karstenw.20240123172917.168"><vh>_get_dy1</vh></v>
<v t="karstenw.20240123172917.169"><vh>_get_dx2</vh></v>
<v t="karstenw.20240123172917.170"><vh>_get_dy2</vh></v>
<v t="karstenw.20240123172917.171"><vh>_get_dx3</vh></v>
<v t="karstenw.20240123172917.172"><vh>_get_dy3</vh></v>
<v t="karstenw.20240123172917.173"><vh>_get_dx4</vh></v>
<v t="karstenw.20240123172917.174"><vh>_get_dy4</vh></v>
<v t="karstenw.20240123172917.175"><vh>_set_dx1</vh></v>
<v t="karstenw.20240123172917.176"><vh>_set_dy1</vh></v>
<v t="karstenw.20240123172917.177"><vh>_set_dx2</vh></v>
<v t="karstenw.20240123172917.178"><vh>_set_dy2</vh></v>
<v t="karstenw.20240123172917.179"><vh>_set_dx3</vh></v>
<v t="karstenw.20240123172917.180"><vh>_set_dy3</vh></v>
<v t="karstenw.20240123172917.181"><vh>_set_dx4</vh></v>
<v t="karstenw.20240123172917.182"><vh>_set_dy4</vh></v>
</v>
<v t="karstenw.20240123172917.183"><vh>class Image</vh>
<v t="karstenw.20240123172917.184"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.185"><vh>copy</vh></v>
<v t="karstenw.20240123172917.186"><vh>id</vh></v>
<v t="karstenw.20240123172917.187"><vh>texture</vh></v>
<v t="karstenw.20240123172917.188"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172917.189"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172917.190"><vh>_get_size</vh></v>
<v t="karstenw.20240123172917.191"><vh>_set_size</vh></v>
<v t="karstenw.20240123172917.192"><vh>_get_alpha</vh></v>
<v t="karstenw.20240123172917.193"><vh>_set_alpha</vh></v>
<v t="karstenw.20240123172917.194"><vh>distort</vh></v>
<v t="karstenw.20240123172917.195"><vh>adjust</vh></v>
<v t="karstenw.20240123172917.196"><vh>draw</vh></v>
<v t="karstenw.20240123172917.197"><vh>save</vh></v>
<v t="karstenw.20240123172917.198"><vh>__repr__</vh></v>
<v t="karstenw.20240123172917.199"><vh>__del__</vh></v>
</v>
<v t="karstenw.20240123172917.200"><vh>image</vh></v>
<v t="karstenw.20240123172917.201"><vh>imagesize</vh></v>
<v t="karstenw.20240123172917.202"><vh>crop</vh></v>
</v>
<v t="karstenw.20240126160327.1" a="E"><vh>+ PIXELS +</vh>
<v t="karstenw.20240123172917.203" a="E"><vh>class Pixels</vh>
<v t="karstenw.20240123172917.204"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.205"><vh>width</vh></v>
<v t="karstenw.20240123172917.206"><vh>height</vh></v>
<v t="karstenw.20240123172917.207"><vh>size</vh></v>
<v t="karstenw.20240123172917.208"><vh>__len__</vh></v>
<v t="karstenw.20240123172917.209"><vh>__iter__</vh></v>
<v t="karstenw.20240123172917.210"><vh>__getitem__</vh></v>
<v t="karstenw.20240123172917.211"><vh>__setitem__</vh></v>
<v t="karstenw.20240123172917.212"><vh>__getslice__</vh></v>
<v t="karstenw.20240123172917.213"><vh>__setslice__</vh></v>
<v t="karstenw.20240123172917.214"><vh>map</vh></v>
<v t="karstenw.20240123172917.215"><vh>get</vh></v>
<v t="karstenw.20240123172917.216"><vh>set</vh></v>
<v t="karstenw.20240123172917.217"><vh>update</vh></v>
<v t="karstenw.20240123172917.218"><vh>texture</vh></v>
<v t="karstenw.20240123172917.219"><vh>copy</vh></v>
<v t="karstenw.20240123172917.220"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172917.221"><vh>class Animation</vh>
<v t="karstenw.20240123172917.222"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.223"><vh>copy</vh></v>
<v t="karstenw.20240123172917.224"><vh>update</vh></v>
<v t="karstenw.20240123172917.225"><vh>frames</vh></v>
<v t="karstenw.20240123172917.226"><vh>frame</vh></v>
<v t="karstenw.20240123172917.227"><vh>done</vh></v>
<v t="karstenw.20240123172917.228"><vh>draw</vh></v>
<v t="karstenw.20240123172917.229"><vh>__repr__</vh></v>
</v>
</v>
<v t="karstenw.20240126160358.1"><vh>+ OFFSCREEN RENDERING +</vh></v>
<v t="karstenw.20240126160433.1"><vh>+ FONT +</vh>
<v t="karstenw.20240123172917.230"><vh>install_font</vh></v>
<v t="karstenw.20240123172917.231"><vh>font</vh></v>
<v t="karstenw.20240123172917.232"><vh>fontname</vh></v>
<v t="karstenw.20240123172917.233"><vh>fontsize</vh></v>
<v t="karstenw.20240123172917.234"><vh>fontweight</vh></v>
<v t="karstenw.20240123172917.235"><vh>lineheight</vh></v>
<v t="karstenw.20240123172917.236"><vh>align</vh></v>
</v>
<v t="karstenw.20240126160534.1"><vh>+ FONT MIXIN +</vh>
<v t="karstenw.20240123172917.237"><vh>font_mixin</vh></v>
</v>
<v t="karstenw.20240126160602.1" a="E"><vh>+ TEXT +</vh>
<v t="karstenw.20240123172917.238"><vh>label</vh></v>
<v t="karstenw.20240123172917.239" a="E"><vh>class Text</vh>
<v t="karstenw.20240123172917.240"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.241"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172917.242"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172917.243"><vh>_get_size</vh></v>
<v t="karstenw.20240123172917.244"><vh>_set_size</vh></v>
<v t="karstenw.20240123172917.245"><vh>__getattr__</vh></v>
<v t="karstenw.20240123172917.246"><vh>__setattr__</vh></v>
<v t="karstenw.20240123172917.247"><vh>_update</vh></v>
<v t="karstenw.20240123172917.248"><vh>path</vh></v>
<v t="karstenw.20240123172917.249"><vh>metrics</vh></v>
<v t="karstenw.20240123172917.250"><vh>draw</vh></v>
<v t="karstenw.20240123172917.251"><vh>copy</vh></v>
<v t="karstenw.20240123172917.252"><vh>style</vh></v>
<v t="karstenw.20240123172917.253"><vh>__len__</vh></v>
<v t="karstenw.20240123172917.254"><vh>__del__</vh></v>
</v>
<v t="karstenw.20240123172917.255"><vh>text</vh></v>
<v t="karstenw.20240123172917.256"><vh>textwidth</vh></v>
<v t="karstenw.20240123172917.257"><vh>textheight</vh></v>
<v t="karstenw.20240123172917.258"><vh>textmetrics</vh></v>
</v>
<v t="karstenw.20240126160625.1" a="E"><vh>+ TEXTPATH +</vh>
<v t="karstenw.20240123172917.259"><vh>class GlyphPathError</vh></v>
<v t="karstenw.20240123172917.260"><vh>textpath</vh></v>
</v>
<v t="karstenw.20240126160653.1"><vh> + UTILITIES +</vh>
<v t="karstenw.20240123172917.261"><vh>_rnd_exp</vh></v>
<v t="karstenw.20240123172917.262"><vh>random</vh></v>
<v t="karstenw.20240123172917.263"><vh>grid</vh></v>
<v t="karstenw.20240123172917.264"><vh>files</vh></v>
</v>
<v t="karstenw.20240126160719.1" a="E"><vh>+ PROTOTYPE +</vh>
<v t="karstenw.20240123172917.265" a="E"><vh>class Prototype</vh>
<v t="karstenw.20240123172917.266"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.267"><vh>_deepcopy</vh></v>
<v t="karstenw.20240123172917.268"><vh>_bind</vh></v>
<v t="karstenw.20240123172917.269"><vh>set_method</vh></v>
<v t="karstenw.20240123172917.270"><vh>set_property</vh></v>
<v t="karstenw.20240123172917.271"><vh>inherit</vh></v>
</v>
<v t="karstenw.20240123172917.272"><vh>class EventHandler</vh>
<v t="karstenw.20240123172917.273"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.274"><vh>on_mouse_enter</vh></v>
<v t="karstenw.20240123172917.275"><vh>on_mouse_leave</vh></v>
<v t="karstenw.20240123172917.276"><vh>on_mouse_motion</vh></v>
<v t="karstenw.20240123172917.277"><vh>on_mouse_press</vh></v>
<v t="karstenw.20240123172917.278"><vh>on_mouse_release</vh></v>
<v t="karstenw.20240123172917.279"><vh>on_mouse_drag</vh></v>
<v t="karstenw.20240123172917.280"><vh>on_mouse_scroll</vh></v>
<v t="karstenw.20240123172917.281"><vh>on_key_press</vh></v>
<v t="karstenw.20240123172917.282"><vh>on_key_release</vh></v>
<v t="karstenw.20240123172917.283"><vh>queue_event</vh></v>
<v t="karstenw.20240123172917.284"><vh>process_events</vh></v>
</v>
</v>
<v t="karstenw.20240126160737.1"><vh>+ TRANSITION +</vh>
<v t="karstenw.20240123172917.285"><vh>class Transition</vh>
<v t="karstenw.20240123172917.286"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.287"><vh>copy</vh></v>
<v t="karstenw.20240123172917.288"><vh>get</vh></v>
<v t="karstenw.20240123172917.289"><vh>set</vh></v>
<v t="karstenw.20240123172917.290"><vh>start</vh></v>
<v t="karstenw.20240123172917.291"><vh>stop</vh></v>
<v t="karstenw.20240123172917.292"><vh>current</vh></v>
<v t="karstenw.20240123172917.293"><vh>done</vh></v>
<v t="karstenw.20240123172917.294"><vh>update</vh></v>
</v>
</v>
<v t="karstenw.20240126160803.1"><vh>+ LAYER +</vh>
<v t="karstenw.20240123172917.295"><vh>_uid</vh></v>
<v t="karstenw.20240123172917.296"><vh>class LayerRenderError</vh></v>
<v t="karstenw.20240123172917.297"><vh>class LayerClippingMask</vh>
<v t="karstenw.20240123172917.298"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.299"><vh>draw</vh></v>
</v>
<v t="karstenw.20240123172917.300"><vh>class Layer</vh>
<v t="karstenw.20240123172917.301"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.302"><vh>from_image</vh></v>
<v t="karstenw.20240123172917.303"><vh>from_function</vh></v>
<v t="karstenw.20240123172917.304"><vh>copy</vh></v>
<v t="karstenw.20240123172917.305"><vh>__getattr__</vh></v>
<v t="karstenw.20240123172917.306"><vh>_set_container</vh></v>
<v t="karstenw.20240123172917.307"><vh>_get_canvas</vh></v>
<v t="karstenw.20240123172917.308"><vh>_get_parent</vh></v>
<v t="karstenw.20240123172917.309"><vh>_set_canvas</vh></v>
<v t="karstenw.20240123172917.310"><vh>_set_parent</vh></v>
<v t="karstenw.20240123172917.311"><vh>root</vh></v>
<v t="karstenw.20240123172917.312"><vh>layers</vh></v>
<v t="karstenw.20240123172917.313"><vh>insert</vh></v>
<v t="karstenw.20240123172917.314"><vh>append</vh></v>
<v t="karstenw.20240123172917.315"><vh>extend</vh></v>
<v t="karstenw.20240123172917.316"><vh>remove</vh></v>
<v t="karstenw.20240123172917.317"><vh>pop</vh></v>
<v t="karstenw.20240123172917.318"><vh>_get_x</vh></v>
<v t="karstenw.20240123172917.319"><vh>_get_y</vh></v>
<v t="karstenw.20240123172917.320"><vh>_get_width</vh></v>
<v t="karstenw.20240123172917.321"><vh>_get_height</vh></v>
<v t="karstenw.20240123172917.322"><vh>_get_scale</vh></v>
<v t="karstenw.20240123172917.323"><vh>_get_rotation</vh></v>
<v t="karstenw.20240123172917.324"><vh>_get_opacity</vh></v>
<v t="karstenw.20240123172917.325"><vh>_set_x</vh></v>
<v t="karstenw.20240123172917.326"><vh>_set_y</vh></v>
<v t="karstenw.20240123172917.327"><vh>_set_width</vh></v>
<v t="karstenw.20240123172917.328"><vh>_set_height</vh></v>
<v t="karstenw.20240123172917.329"><vh>_set_scale</vh></v>
<v t="karstenw.20240123172917.330"><vh>_set_rotation</vh></v>
<v t="karstenw.20240123172917.331"><vh>_set_opacity</vh></v>
<v t="karstenw.20240123172917.332"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172917.333"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172917.334"><vh>_get_origin</vh></v>
<v t="karstenw.20240123172917.335"><vh>_set_origin</vh></v>
<v t="karstenw.20240123172917.336"><vh>origin</vh></v>
<v t="karstenw.20240123172917.337"><vh>_get_relative_origin</vh></v>
<v t="karstenw.20240123172917.338"><vh>_set_relative_origin</vh></v>
<v t="karstenw.20240123172917.339"><vh>_get_absolute_origin</vh></v>
<v t="karstenw.20240123172917.340"><vh>_set_absolute_origin</vh></v>
<v t="karstenw.20240123172917.341"><vh>_get_visible</vh></v>
<v t="karstenw.20240123172917.342"><vh>_set_visible</vh></v>
<v t="karstenw.20240123172917.343"><vh>translate</vh></v>
<v t="karstenw.20240123172917.344"><vh>rotate</vh></v>
<v t="karstenw.20240123172917.345"><vh>scale</vh></v>
<v t="karstenw.20240123172917.346"><vh>flip</vh></v>
<v t="karstenw.20240123172917.347"><vh>_update</vh></v>
<v t="karstenw.20240123172917.348"><vh>update</vh></v>
<v t="karstenw.20240123172917.349"><vh>done</vh></v>
<v t="karstenw.20240123172917.350"><vh>_draw</vh></v>
<v t="karstenw.20240123172917.351"><vh>draw</vh></v>
<v t="karstenw.20240123172917.352"><vh>render</vh></v>
<v t="karstenw.20240123172917.353"><vh>layer_at</vh></v>
<v t="karstenw.20240123172917.354"><vh>_transform</vh></v>
<v t="karstenw.20240123172917.355"><vh>transform</vh></v>
<v t="karstenw.20240123172917.356"><vh>_bounds</vh></v>
<v t="karstenw.20240123172917.357"><vh>bounds</vh></v>
<v t="karstenw.20240123172917.358"><vh>contains</vh></v>
<v t="karstenw.20240123172917.359"><vh>absolute_position</vh></v>
<v t="karstenw.20240123172917.360"><vh>traverse</vh></v>
<v t="karstenw.20240123172917.361"><vh>__repr__</vh></v>
<v t="karstenw.20240123172917.362"><vh>__eq__</vh></v>
<v t="karstenw.20240123172917.363"><vh>__ne__</vh></v>
</v>
</v>
<v t="karstenw.20240126160845.1"><vh>+ GROUP +</vh>
<v t="karstenw.20240123172917.364"><vh>class Group</vh>
<v t="karstenw.20240123172917.365"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.366"><vh>from_image</vh></v>
<v t="karstenw.20240123172917.367"><vh>from_function</vh></v>
<v t="karstenw.20240123172917.368"><vh>width</vh></v>
<v t="karstenw.20240123172917.369"><vh>height</vh></v>
<v t="karstenw.20240123172917.370"><vh>layer_at</vh></v>
</v>
</v>
<v t="karstenw.20240126160906.1"><vh>+ MOUSE +</vh>
<v t="karstenw.20240123172917.371"><vh>class Mouse</vh>
<v t="karstenw.20240123172917.372"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.373"><vh>vx</vh></v>
<v t="karstenw.20240123172917.374"><vh>vy</vh></v>
<v t="karstenw.20240123172917.375"><vh>relative_x</vh></v>
<v t="karstenw.20240123172917.376"><vh>relative_y</vh></v>
<v t="karstenw.20240123172917.377"><vh>_get_cursor</vh></v>
<v t="karstenw.20240123172917.378"><vh>_set_cursor</vh></v>
<v t="karstenw.20240123172917.379"><vh>_get_button</vh></v>
<v t="karstenw.20240123172917.380"><vh>_set_button</vh></v>
<v t="karstenw.20240123172917.381"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172917.382"><vh>class Keys</vh>
<v t="karstenw.20240123172917.383"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.384"><vh>append</vh></v>
<v t="karstenw.20240123172917.385"><vh>remove</vh></v>
<v t="karstenw.20240123172917.386"><vh>_decode</vh></v>
<v t="karstenw.20240123172917.387"><vh>__repr__</vh></v>
</v>
</v>
<v t="karstenw.20240126160950.1" a="E"><vh>+ CANVAS +</vh>
<v t="karstenw.20240123172917.388"><vh>_configure</vh></v>
<v t="karstenw.20240123172917.389" a="E"><vh>class Canvas</vh>
<v t="karstenw.20240123172917.390"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.391"><vh>_get_name</vh></v>
<v t="karstenw.20240123172917.392"><vh>_set_name</vh></v>
<v t="karstenw.20240123172917.393"><vh>_get_vsync</vh></v>
<v t="karstenw.20240123172917.394"><vh>_set_vsync</vh></v>
<v t="karstenw.20240123172917.395"><vh>layers</vh></v>
<v t="karstenw.20240123172917.396"><vh>insert</vh></v>
<v t="karstenw.20240123172917.397"><vh>append</vh></v>
<v t="karstenw.20240123172917.398"><vh>extend</vh></v>
<v t="karstenw.20240123172917.399"><vh>remove</vh></v>
<v t="karstenw.20240123172917.400"><vh>pop</vh></v>
<v t="karstenw.20240123172917.401"><vh>_get_x</vh></v>
<v t="karstenw.20240123172917.402"><vh>_set_x</vh></v>
<v t="karstenw.20240123172917.403"><vh>_get_y</vh></v>
<v t="karstenw.20240123172917.404"><vh>_set_y</vh></v>
<v t="karstenw.20240123172917.405"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172917.406"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172917.407"><vh>_get_width</vh></v>
<v t="karstenw.20240123172917.408"><vh>_get_height</vh></v>
<v t="karstenw.20240123172917.409"><vh>_get_size</vh></v>
<v t="karstenw.20240123172917.410"><vh>_set_width</vh></v>
<v t="karstenw.20240123172917.411"><vh>_set_height</vh></v>
<v t="karstenw.20240123172917.412"><vh>_set_size</vh></v>
<v t="karstenw.20240123172917.413"><vh>_get_fullscreen</vh></v>
<v t="karstenw.20240123172917.414"><vh>_set_fullscreen</vh></v>
<v t="karstenw.20240123172917.415"><vh>screen</vh></v>
<v t="karstenw.20240123172917.416"><vh>frame</vh></v>
<v t="karstenw.20240123172917.417"><vh>elapsed</vh></v>
<v t="karstenw.20240123172917.418"><vh>mouse</vh></v>
<v t="karstenw.20240123172917.419"><vh>keys</vh></v>
<v t="karstenw.20240123172917.420"><vh>key</vh></v>
<v t="karstenw.20240123172917.421"><vh>focus</vh></v>
<v t="karstenw.20240123172917.422"><vh>layer_at</vh></v>
<v t="karstenw.20240123172917.423"><vh>_on_mouse_enter</vh></v>
<v t="karstenw.20240123172917.424"><vh>_on_mouse_leave</vh></v>
<v t="karstenw.20240123172917.425"><vh>_on_mouse_motion</vh></v>
<v t="karstenw.20240123172917.426"><vh>_on_mouse_press</vh></v>
<v t="karstenw.20240123172917.427"><vh>_on_mouse_release</vh></v>
<v t="karstenw.20240123172917.428"><vh>_on_mouse_drag</vh></v>
<v t="karstenw.20240123172917.429"><vh>_on_mouse_scroll</vh></v>
<v t="karstenw.20240123172917.430"><vh>_on_key_press</vh></v>
<v t="karstenw.20240123172917.431"><vh>_on_key_release</vh></v>
<v t="karstenw.20240123172917.432"><vh>_on_text</vh></v>
<v t="karstenw.20240123172917.433"><vh>_on_text_motion</vh></v>
<v t="karstenw.20240123172917.434"><vh>_on_move</vh></v>
<v t="karstenw.20240123172917.435"><vh>_on_resize</vh></v>
<v t="karstenw.20240123172917.436"><vh>on_key_press</vh></v>
<v t="karstenw.20240123172917.437"><vh>on_move</vh></v>
<v t="karstenw.20240123172917.438"><vh>on_resize</vh></v>
<v t="karstenw.20240123172917.439"><vh>setup</vh></v>
<v t="karstenw.20240123172917.440"><vh>update</vh></v>
<v t="karstenw.20240123172917.441"><vh>draw</vh></v>
<v t="karstenw.20240123172917.442"><vh>draw_overlay</vh></v>
<v t="karstenw.20240123172917.443"><vh>_setup</vh></v>
<v t="karstenw.20240123172917.444"><vh>_draw</vh></v>
<v t="karstenw.20240123172917.445"><vh>_update</vh></v>
<v t="karstenw.20240123172917.446"><vh>stop</vh></v>
<v t="karstenw.20240123172917.447"><vh>clear</vh></v>
<v t="karstenw.20240123172917.448"><vh>run</vh></v>
<v t="karstenw.20240123172917.449"><vh>active</vh></v>
<v t="karstenw.20240123172917.450"><vh>_get_fps</vh></v>
<v t="karstenw.20240123172917.451"><vh>_set_fps</vh></v>
<v t="karstenw.20240123172917.452"><vh>render</vh></v>
<v t="karstenw.20240123172917.453"><vh>texture</vh></v>
<v t="karstenw.20240123172917.454"><vh>save</vh></v>
<v t="karstenw.20240123172917.455"><vh>__setattr__</vh></v>
<v t="karstenw.20240123172917.456"><vh>set_method</vh></v>
<v t="karstenw.20240123172917.457"><vh>__repr__</vh></v>
</v>
</v>
<v t="karstenw.20240126161010.1" a="E"><vh>+ PROFILER +</vh>
<v t="karstenw.20240123172917.458"><vh>profile_run</vh></v>
<v t="karstenw.20240123172917.459" a="E"><vh>class Profiler</vh>
<v t="karstenw.20240123172917.460"><vh>__init__</vh></v>
<v t="karstenw.20240123172917.461"><vh>framerate</vh></v>
<v t="karstenw.20240123172917.462"><vh>run</vh></v>
</v>
</v>
<v t="karstenw.20240126161026.1"><vh>+ LIBRARIES +</vh>
<v t="karstenw.20240123172917.463"><vh>ximport</vh></v>
</v>
<v t="karstenw.20240126161053.1"><vh>+ BEZIER IMPORT +</vh></v>
</v>
<v t="karstenw.20240123172754.1"><vh>@clean nodeboxgl/graphics/geometry.py</vh>
<v t="karstenw.20240123172914.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172914.2"><vh>angle</vh></v>
<v t="karstenw.20240123172914.3"><vh>distance</vh></v>
<v t="karstenw.20240123172914.4"><vh>coordinates</vh></v>
<v t="karstenw.20240123172914.5"><vh>rotate</vh></v>
<v t="karstenw.20240123172914.6"><vh>reflect</vh></v>
<v t="karstenw.20240123172914.7"><vh>lerp</vh></v>
<v t="karstenw.20240123172914.8"><vh>smoothstep</vh></v>
<v t="karstenw.20240123172914.9"><vh>bounce</vh></v>
<v t="karstenw.20240123172914.10"><vh>clamp</vh></v>
<v t="karstenw.20240123172914.11"><vh>line_line_intersection</vh></v>
<v t="karstenw.20240123172914.12"><vh>circle_line_intersection</vh></v>
<v t="karstenw.20240123172914.13"><vh>intersection</vh></v>
<v t="karstenw.20240123172914.14"><vh>point_in_polygon</vh></v>
<v t="karstenw.20240123172914.15"><vh>superformula</vh></v>
<v t="karstenw.20240123172914.16"><vh>class AffineTransform</vh>
<v t="karstenw.20240123172914.17"><vh>__init__</vh></v>
<v t="karstenw.20240123172914.18"><vh>copy</vh></v>
<v t="karstenw.20240123172914.19"><vh>prepend</vh></v>
<v t="karstenw.20240123172914.20"><vh>append</vh></v>
<v t="karstenw.20240123172914.21"><vh>_mmult</vh></v>
<v t="karstenw.20240123172914.22"><vh>invert</vh></v>
<v t="karstenw.20240123172914.23"><vh>inverse</vh></v>
<v t="karstenw.20240123172914.24"><vh>identity</vh></v>
<v t="karstenw.20240123172914.25"><vh>rotation</vh></v>
<v t="karstenw.20240123172914.26"><vh>scale</vh></v>
<v t="karstenw.20240123172914.27"><vh>translate</vh></v>
<v t="karstenw.20240123172914.28"><vh>rotate</vh></v>
<v t="karstenw.20240123172914.29"><vh>transform_point</vh></v>
<v t="karstenw.20240123172914.30"><vh>transform_path</vh></v>
<v t="karstenw.20240123172914.31"><vh>map</vh></v>
</v>
<v t="karstenw.20240123172914.32"><vh>class Point</vh>
<v t="karstenw.20240123172914.33"><vh>__init__</vh></v>
<v t="karstenw.20240123172914.34"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172914.35"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172914.36"><vh>__iter__</vh></v>
<v t="karstenw.20240123172914.37"><vh>__repr__</vh></v>
<v t="karstenw.20240123172914.38"><vh>__eq__</vh></v>
<v t="karstenw.20240123172914.39"><vh>__ne__</vh></v>
</v>
<v t="karstenw.20240123172914.40"><vh>class Bounds</vh>
<v t="karstenw.20240123172914.41"><vh>__init__</vh></v>
<v t="karstenw.20240123172914.42"><vh>copy</vh></v>
<v t="karstenw.20240123172914.43"><vh>__iter__</vh></v>
<v t="karstenw.20240123172914.44"><vh>intersects</vh></v>
<v t="karstenw.20240123172914.45"><vh>intersection</vh></v>
<v t="karstenw.20240123172914.46"><vh>union</vh></v>
<v t="karstenw.20240123172914.47"><vh>contains</vh></v>
<v t="karstenw.20240123172914.48"><vh>__eq__</vh></v>
<v t="karstenw.20240123172914.49"><vh>__ne__</vh></v>
<v t="karstenw.20240123172914.50"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172914.51"><vh>class TessellationError</vh></v>
<v t="karstenw.20240123172914.52"><vh>class Tessellate</vh>
<v t="karstenw.20240123172914.53"><vh>__init__</vh></v>
<v t="karstenw.20240123172914.54"><vh>clear</vh></v>
<v t="karstenw.20240123172914.55"><vh>reset</vh></v>
</v>
<v t="karstenw.20240123172914.56"><vh>_tessellate_callback</vh></v>
<v t="karstenw.20240123172914.57"><vh>_tessellate_begin</vh></v>
<v t="karstenw.20240123172914.58"><vh>_tessellate_vertex</vh></v>
<v t="karstenw.20240123172914.59"><vh>_tessellate_end</vh></v>
<v t="karstenw.20240123172914.60"><vh>_tessellate_combine</vh></v>
<v t="karstenw.20240123172914.61"><vh>_tessellate_error</vh></v>
<v t="karstenw.20240123172914.62"><vh>tessellate</vh></v>
</v>
<v t="karstenw.20240123172754.2"><vh>@clean nodeboxgl/graphics/noise.py</vh>
<v t="karstenw.20240123172911.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172911.2"><vh>class PerlinNoise</vh>
<v t="karstenw.20240123172911.3"><vh>__init__</vh></v>
<v t="karstenw.20240123172911.4"><vh>_init</vh></v>
<v t="karstenw.20240123172911.5"><vh>_fade</vh></v>
<v t="karstenw.20240123172911.6"><vh>_lerp</vh></v>
<v t="karstenw.20240123172911.7"><vh>_grad</vh></v>
<v t="karstenw.20240123172911.8"><vh>generate</vh></v>
</v>
<v t="karstenw.20240123172911.9"><vh>noise</vh></v>
</v>
<v t="karstenw.20240123172826.1" a="E"><vh>@clean nodeboxgl/graphics/physics.py</vh>
<v t="karstenw.20240123172908.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172908.2"><vh>line</vh></v>
<v t="karstenw.20240123172908.3"><vh>ellipse</vh></v>
<v t="karstenw.20240123172908.4" a="E"><vh>class Text</vh>
<v t="karstenw.20240123172908.5"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.6"><vh>copy</vh></v>
<v t="karstenw.20240123172908.7"><vh>draw</vh></v>
</v>
<v t="karstenw.20240123172908.8"><vh>class Vector</vh>
<v t="karstenw.20240123172908.9"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.10"><vh>copy</vh></v>
<v t="karstenw.20240123172908.11"><vh>__getitem__</vh></v>
<v t="karstenw.20240123172908.12"><vh>__setitem__</vh></v>
<v t="karstenw.20240123172908.13"><vh>_get_xyz</vh></v>
<v t="karstenw.20240123172908.14"><vh>_set_xyz</vh></v>
<v t="karstenw.20240123172908.15"><vh>_get_xy</vh></v>
<v t="karstenw.20240123172908.16"><vh>_set_xy</vh></v>
<v t="karstenw.20240123172908.17"><vh>_get_length</vh></v>
<v t="karstenw.20240123172908.18"><vh>_set_length</vh></v>
<v t="karstenw.20240123172908.19"><vh>distance</vh></v>
<v t="karstenw.20240123172908.20"><vh>distance2</vh></v>
<v t="karstenw.20240123172908.21"><vh>normalize</vh></v>
<v t="karstenw.20240123172908.22"><vh>_normalized</vh></v>
<v t="karstenw.20240123172908.23"><vh>reverse</vh></v>
<v t="karstenw.20240123172908.24"><vh>_reversed</vh></v>
<v t="karstenw.20240123172908.25"><vh>in2D</vh></v>
<v t="karstenw.20240123172908.26"><vh>_orthogonal</vh></v>
<v t="karstenw.20240123172908.27"><vh>_get_angle</vh></v>
<v t="karstenw.20240123172908.28"><vh>_set_angle</vh></v>
<v t="karstenw.20240123172908.29"><vh>rotate</vh></v>
<v t="karstenw.20240123172908.30"><vh>rotated</vh></v>
<v t="karstenw.20240123172908.31"><vh>angle_to</vh></v>
<v t="karstenw.20240123172908.32"><vh>__add__</vh></v>
<v t="karstenw.20240123172908.33"><vh>__sub__</vh></v>
<v t="karstenw.20240123172908.34"><vh>__mul__</vh></v>
<v t="karstenw.20240123172908.35"><vh>__div__</vh></v>
<v t="karstenw.20240123172908.36"><vh>__iadd__</vh></v>
<v t="karstenw.20240123172908.37"><vh>__isub__</vh></v>
<v t="karstenw.20240123172908.38"><vh>__imul__</vh></v>
<v t="karstenw.20240123172908.39"><vh>__idiv__</vh></v>
<v t="karstenw.20240123172908.40"><vh>dot</vh></v>
<v t="karstenw.20240123172908.41"><vh>cross</vh></v>
<v t="karstenw.20240123172908.42"><vh>__neg__</vh></v>
<v t="karstenw.20240123172908.43"><vh>__eq__</vh></v>
<v t="karstenw.20240123172908.44"><vh>__ne__</vh></v>
<v t="karstenw.20240123172908.45"><vh>__repr__</vh></v>
<v t="karstenw.20240123172908.46"><vh>draw</vh></v>
</v>
<v t="karstenw.20240123172908.47"><vh>_uid</vh></v>
<v t="karstenw.20240123172908.48"><vh>class Boid</vh>
<v t="karstenw.20240123172908.49"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.50"><vh>__eq__</vh></v>
<v t="karstenw.20240123172908.51"><vh>__ne__</vh></v>
<v t="karstenw.20240123172908.52"><vh>copy</vh></v>
<v t="karstenw.20240123172908.53"><vh>heading</vh></v>
<v t="karstenw.20240123172908.54"><vh>depth</vh></v>
<v t="karstenw.20240123172908.55"><vh>near</vh></v>
<v t="karstenw.20240123172908.56"><vh>separation</vh></v>
<v t="karstenw.20240123172908.57"><vh>alignment</vh></v>
<v t="karstenw.20240123172908.58"><vh>cohesion</vh></v>
<v t="karstenw.20240123172908.59"><vh>avoidance</vh></v>
<v t="karstenw.20240123172908.60"><vh>limit</vh></v>
<v t="karstenw.20240123172908.61"><vh>update</vh></v>
<v t="karstenw.20240123172908.62"><vh>seek</vh></v>
<v t="karstenw.20240123172908.63"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.64"><vh>class Obstacle</vh>
<v t="karstenw.20240123172908.65"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.66"><vh>copy</vh></v>
<v t="karstenw.20240123172908.67"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.68"><vh>class Flock</vh>
<v t="karstenw.20240123172908.69"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.70"><vh>boids</vh></v>
<v t="karstenw.20240123172908.71"><vh>copy</vh></v>
<v t="karstenw.20240123172908.72"><vh>seek</vh></v>
<v t="karstenw.20240123172908.73"><vh>sight</vh></v>
<v t="karstenw.20240123172908.74"><vh>space</vh></v>
<v t="karstenw.20240123172908.75"><vh>constrain</vh></v>
<v t="karstenw.20240123172908.76"><vh>scatter</vh></v>
<v t="karstenw.20240123172908.77"><vh>update</vh></v>
<v t="karstenw.20240123172908.78"><vh>by_depth</vh></v>
<v t="karstenw.20240123172908.79"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.80"><vh>class Force</vh>
<v t="karstenw.20240123172908.81"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.82"><vh>apply</vh></v>
<v t="karstenw.20240123172908.83"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.84"><vh>class Spring</vh>
<v t="karstenw.20240123172908.85"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.86"><vh>snap</vh></v>
<v t="karstenw.20240123172908.87"><vh>apply</vh></v>
<v t="karstenw.20240123172908.88"><vh>draw</vh></v>
<v t="karstenw.20240123172908.89"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.90"><vh>class Particle</vh>
<v t="karstenw.20240123172908.91"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.92"><vh>age</vh></v>
<v t="karstenw.20240123172908.93"><vh>draw</vh></v>
<v t="karstenw.20240123172908.94"><vh>__eq__</vh></v>
<v t="karstenw.20240123172908.95"><vh>__ne__</vh></v>
<v t="karstenw.20240123172908.96"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.97"><vh>class flist</vh>
<v t="karstenw.20240123172908.98"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.99"><vh>insert</vh></v>
<v t="karstenw.20240123172908.100"><vh>append</vh></v>
<v t="karstenw.20240123172908.101"><vh>extend</vh></v>
<v t="karstenw.20240123172908.102"><vh>pop</vh></v>
<v t="karstenw.20240123172908.103"><vh>remove</vh></v>
</v>
<v t="karstenw.20240123172908.104"><vh>class System</vh>
<v t="karstenw.20240123172908.105"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.106"><vh>__len__</vh></v>
<v t="karstenw.20240123172908.107"><vh>__iter__</vh></v>
<v t="karstenw.20240123172908.108"><vh>__getitem__</vh></v>
<v t="karstenw.20240123172908.109"><vh>extend</vh></v>
<v t="karstenw.20240123172908.110"><vh>append</vh></v>
<v t="karstenw.20240123172908.111"><vh>_cross</vh></v>
<v t="karstenw.20240123172908.112"><vh>force</vh></v>
<v t="karstenw.20240123172908.113"><vh>dynamics</vh></v>
<v t="karstenw.20240123172908.114"><vh>limit</vh></v>
<v t="karstenw.20240123172908.115"><vh>update</vh></v>
<v t="karstenw.20240123172908.116"><vh>dead</vh></v>
<v t="karstenw.20240123172908.117"><vh>draw</vh></v>
<v t="karstenw.20240123172908.118"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240123172908.119"><vh>class Emitter</vh>
<v t="karstenw.20240123172908.120"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.121"><vh>__len__</vh></v>
<v t="karstenw.20240123172908.122"><vh>__iter__</vh></v>
<v t="karstenw.20240123172908.123"><vh>__getitem__</vh></v>
<v t="karstenw.20240123172908.124"><vh>extend</vh></v>
<v t="karstenw.20240123172908.125"><vh>append</vh></v>
<v t="karstenw.20240123172908.126"><vh>_get_angle</vh></v>
<v t="karstenw.20240123172908.127"><vh>_set_angle</vh></v>
<v t="karstenw.20240123172908.128"><vh>_get_strength</vh></v>
<v t="karstenw.20240123172908.129"><vh>_set_strength</vh></v>
<v t="karstenw.20240123172908.130"><vh>update</vh></v>
</v>
<v t="karstenw.20240123172908.131"><vh>deepcopy</vh></v>
<v t="karstenw.20240123172908.132"><vh>class Node</vh>
<v t="karstenw.20240123172908.133"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.134"><vh>_distance</vh></v>
<v t="karstenw.20240123172908.135"><vh>_get_x</vh></v>
<v t="karstenw.20240123172908.136"><vh>_get_y</vh></v>
<v t="karstenw.20240123172908.137"><vh>_set_x</vh></v>
<v t="karstenw.20240123172908.138"><vh>_set_y</vh></v>
<v t="karstenw.20240123172908.139"><vh>edges</vh></v>
<v t="karstenw.20240123172908.140"><vh>weight</vh></v>
<v t="karstenw.20240123172908.141"><vh>centrality</vh></v>
<v t="karstenw.20240123172908.142"><vh>flatten</vh></v>
<v t="karstenw.20240123172908.143"><vh>draw</vh></v>
<v t="karstenw.20240123172908.144"><vh>contains</vh></v>
<v t="karstenw.20240123172908.145"><vh>__repr__</vh></v>
<v t="karstenw.20240123172908.146"><vh>__eq__</vh></v>
<v t="karstenw.20240123172908.147"><vh>__ne__</vh></v>
<v t="karstenw.20240317204938.1"><vh>__hash__</vh></v>
</v>
<v t="karstenw.20240123172908.148"><vh>class Links</vh>
<v t="karstenw.20240123172908.149"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.150"><vh>append</vh></v>
<v t="karstenw.20240123172908.151"><vh>remove</vh></v>
<v t="karstenw.20240123172908.152"><vh>edge</vh></v>
</v>
<v t="karstenw.20240123172908.153"><vh>class Edge</vh>
<v t="karstenw.20240123172908.154"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.155"><vh>_get_weight</vh></v>
<v t="karstenw.20240123172908.156"><vh>_set_weight</vh></v>
<v t="karstenw.20240123172908.157"><vh>draw</vh></v>
<v t="karstenw.20240123172908.158"><vh>draw_arrow</vh></v>
<v t="karstenw.20240123172908.159"><vh>__repr__</vh></v>
</v>
<v t="karstenw.20240317203023.1" a="E"><vh>++ GRAPH ++</vh>
<v t="karstenw.20240123172908.160" a="E"><vh>class nodedict</vh>
<v t="karstenw.20240123172908.161"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.162"><vh>__contains__</vh></v>
<v t="karstenw.20240123172908.163"><vh>__getitem__</vh></v>
<v t="karstenw.20240123172908.164"><vh>get</vh></v>
</v>
<v t="karstenw.20240123172908.165"><vh>unique</vh></v>
</v>
<v t="karstenw.20240123172908.166" a="E"><vh>class Graph</vh>
<v t="karstenw.20240123172908.167"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.168"><vh>__getitem__</vh></v>
<v t="karstenw.20240123172908.169"><vh>append</vh></v>
<v t="karstenw.20240123172908.170"><vh>add_node</vh></v>
<v t="karstenw.20240123172908.171"><vh>add_edge</vh></v>
<v t="karstenw.20240123172908.172"><vh>remove</vh></v>
<v t="karstenw.20240123172908.173"><vh>node</vh></v>
<v t="karstenw.20240123172908.174"><vh>edge</vh></v>
<v t="karstenw.20240123172908.175"><vh>paths</vh></v>
<v t="karstenw.20240123172908.176"><vh>shortest_path</vh></v>
<v t="karstenw.20240123172908.177"><vh>shortest_paths</vh></v>
<v t="karstenw.20240123172908.178"><vh>eigenvector_centrality</vh></v>
<v t="karstenw.20240123172908.179"><vh>betweenness_centrality</vh></v>
<v t="karstenw.20240123172908.180"><vh>sorted</vh></v>
<v t="karstenw.20240123172908.181"><vh>prune</vh></v>
<v t="karstenw.20240123172908.182"><vh>fringe</vh></v>
<v t="karstenw.20240123172908.183"><vh>density</vh></v>
<v t="karstenw.20240123172908.184"><vh>is_complete</vh></v>
<v t="karstenw.20240123172908.185"><vh>is_dense</vh></v>
<v t="karstenw.20240123172908.186"><vh>is_sparse</vh></v>
<v t="karstenw.20240123172908.187"><vh>split</vh></v>
<v t="karstenw.20240123172908.188"><vh>update</vh></v>
<v t="karstenw.20240123172908.189"><vh>draw</vh></v>
<v t="karstenw.20240123172908.190"><vh>node_at</vh></v>
<v t="karstenw.20240123172908.191"><vh>_add_node_copy</vh></v>
<v t="karstenw.20240123172908.192"><vh>_add_edge_copy</vh></v>
<v t="karstenw.20240123172908.193"><vh>copy</vh></v>
</v>
<v t="karstenw.20240123172908.194"><vh>class GraphLayout</vh>
<v t="karstenw.20240123172908.195"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.196"><vh>update</vh></v>
<v t="karstenw.20240123172908.197"><vh>reset</vh></v>
<v t="karstenw.20240123172908.198"><vh>bounds</vh></v>
<v t="karstenw.20240123172908.199"><vh>copy</vh></v>
</v>
<v t="karstenw.20240123172908.200"><vh>class GraphSpringLayout</vh>
<v t="karstenw.20240123172908.201"><vh>__init__</vh></v>
<v t="karstenw.20240123172908.202"><vh>_distance</vh></v>
<v t="karstenw.20240123172908.203"><vh>_repulse</vh></v>
<v t="karstenw.20240123172908.204"><vh>_attract</vh></v>
<v t="karstenw.20240123172908.205"><vh>update</vh></v>
<v t="karstenw.20240123172908.206"><vh>copy</vh></v>
</v>
<v t="karstenw.20240317203143.1"><vh>++ GRAPH TRAVERSAL ++</vh>
<v t="karstenw.20240123172908.207"><vh>depth_first_search</vh></v>
<v t="karstenw.20240123172908.208"><vh>breadth_first_search</vh></v>
<v t="karstenw.20240123172908.209"><vh>paths</vh></v>
<v t="karstenw.20240123172908.210"><vh>edges</vh></v>
</v>
<v t="karstenw.20240317203210.1"><vh>++ GRAPH THEORY ++</vh>
<v t="karstenw.20240123172908.211"><vh>adjacency</vh></v>
<v t="karstenw.20240123172908.212"><vh>dijkstra_shortest_path</vh></v>
<v t="karstenw.20240123172908.213"><vh>dijkstra_shortest_paths</vh></v>
<v t="karstenw.20240123172908.214"><vh>floyd_warshall_all_pairs_distance</vh></v>
<v t="karstenw.20240123172908.215"><vh>predecessor_path</vh></v>
<v t="karstenw.20240123172908.216"><vh>brandes_betweenness_centrality</vh></v>
<v t="karstenw.20240123172908.217"><vh>eigenvector_centrality</vh></v>
<v t="karstenw.20240123172908.218"><vh>union</vh></v>
<v t="karstenw.20240123172908.219"><vh>intersection</vh></v>
<v t="karstenw.20240123172908.220"><vh>difference</vh></v>
<v t="karstenw.20240123172908.221"><vh>partition</vh></v>
</v>
<v t="karstenw.20240317203259.1"><vh>++ GRAPH THEORY | CLIQUE ++</vh>
<v t="karstenw.20240123172908.222"><vh>is_clique</vh></v>
<v t="karstenw.20240123172908.223"><vh>clique</vh></v>
<v t="karstenw.20240123172908.224"><vh>cliques</vh></v>
</v>
<v t="karstenw.20240317203331.1"><vh>++ GRAPH MAINTENANCE ++</vh>
<v t="karstenw.20240123172908.225"><vh>unlink</vh></v>
<v t="karstenw.20240123172908.226"><vh>redirect</vh></v>
<v t="karstenw.20240123172908.227"><vh>cut</vh></v>
<v t="karstenw.20240123172908.228"><vh>insert</vh></v>
</v>
</v>
<v t="karstenw.20240123172755.1"><vh>@clean nodeboxgl/graphics/shader.py</vh>
<v t="karstenw.20240123172852.1"><vh>Declarations</vh></v>
<v t="karstenw.20240123172852.2"><vh>next</vh></v>
<v t="karstenw.20240123172852.3"><vh>ceil2</vh></v>
<v t="karstenw.20240123172852.4"><vh>extent2</vh></v>
<v t="karstenw.20240123172852.5"><vh>ratio2</vh></v>
<v t="karstenw.20240123172852.6"><vh>class vector</vh></v>
<v t="karstenw.20240123172852.7"><vh>vec2</vh></v>
<v t="karstenw.20240123172852.8"><vh>vec3</vh></v>
<v t="karstenw.20240123172852.9"><vh>vec4</vh></v>
<v t="karstenw.20240123172852.10"><vh>class ShaderError</vh>
<v t="karstenw.20240123172852.11"><vh>__init__</vh></v>
</v>
<v t="karstenw.20240123172852.12"><vh>class Shader</vh>
<v t="karstenw.20240123172852.13"><vh>__init__</vh></v>
<v t="karstenw.20240123172852.14"><vh>_compile</vh></v>
<v t="karstenw.20240123172852.15"><vh>_build</vh></v>
<v t="karstenw.20240123172852.16"><vh>_error</vh></v>
<v t="karstenw.20240123172852.17"><vh>get</vh></v>
<v t="karstenw.20240123172852.18"><vh>set</vh></v>
<v t="karstenw.20240123172852.19"><vh>_set</vh></v>
<v t="karstenw.20240123172853.1"><vh>push</vh></v>
<v t="karstenw.20240123172853.2"><vh>pop</vh></v>
<v t="karstenw.20240123172853.3"><vh>active</vh></v>
<v t="karstenw.20240123172853.4"><vh>source</vh></v>
<v t="karstenw.20240123172853.5"><vh>__del__</vh></v>
</v>
<v t="karstenw.20240123172853.6"><vh>class ShaderFacade</vh>
<v t="karstenw.20240123172853.7"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.8"><vh>variables</vh></v>
<v t="karstenw.20240123172853.9"><vh>active</vh></v>
<v t="karstenw.20240123172853.10"><vh>get</vh></v>
<v t="karstenw.20240123172853.11"><vh>set</vh></v>
<v t="karstenw.20240123172853.12"><vh>push</vh></v>
<v t="karstenw.20240123172853.13"><vh>pop</vh></v>
</v>
<v t="karstenw.20240123172853.14"><vh>shader</vh></v>
<v t="karstenw.20240123172853.15"><vh>class Filter</vh>
<v t="karstenw.20240123172853.16"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.17"><vh>push</vh></v>
<v t="karstenw.20240123172853.18"><vh>pop</vh></v>
</v>
<v t="karstenw.20240123172853.19"><vh>class Invert</vh>
<v t="karstenw.20240123172853.20"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.21"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.22"><vh>class LinearGradient</vh>
<v t="karstenw.20240123172853.23"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.24"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.25"><vh>class RadialGradient</vh>
<v t="karstenw.20240123172853.26"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.27"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.28"><vh>class Colorize</vh>
<v t="karstenw.20240123172853.29"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.30"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.31"><vh>class BrightnessAdjustment</vh>
<v t="karstenw.20240123172853.32"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.33"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.34"><vh>class ContrastAdjustment</vh>
<v t="karstenw.20240123172853.35"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.36"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.37"><vh>class SaturationAdjustment</vh>
<v t="karstenw.20240123172853.38"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.39"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.40"><vh>class HueAdjustment</vh>
<v t="karstenw.20240123172853.41"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.42"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.43"><vh>class BrightPass</vh>
<v t="karstenw.20240123172853.44"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.45"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.46"><vh>class HorizontalBlur</vh>
<v t="karstenw.20240123172853.47"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.48"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.49"><vh>class VerticalBlur</vh>
<v t="karstenw.20240123172853.50"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.51"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.52"><vh>class Gaussian3x3Blur</vh>
<v t="karstenw.20240123172853.53"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.54"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.55"><vh>class Compositing</vh>
<v t="karstenw.20240123172853.56"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.57"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.58"><vh>class AlphaTransparency</vh>
<v t="karstenw.20240123172853.59"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.60"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.61"><vh>class AlphaMask</vh>
<v t="karstenw.20240123172853.62"><vh>__init__</vh></v>
</v>
<v t="karstenw.20240123172853.63"><vh>class Blend</vh>
<v t="karstenw.20240123172853.64"><vh>__init__</vh></v>
</v>
<v t="karstenw.20240123172853.65"><vh>class Distortion</vh>
<v t="karstenw.20240123172853.66"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.67"><vh>_get_abs_dx</vh></v>
<v t="karstenw.20240123172853.68"><vh>_get_abs_dy</vh></v>
<v t="karstenw.20240123172853.69"><vh>_set_abs_dx</vh></v>
<v t="karstenw.20240123172853.70"><vh>_set_abs_dy</vh></v>
<v t="karstenw.20240123172853.71"><vh>push</vh></v>
</v>
<v t="karstenw.20240123172853.72"><vh>_uid</vh></v>
<v t="karstenw.20240123172853.73"><vh>_texture</vh></v>
<v t="karstenw.20240123172853.74"><vh>glCurrentViewport</vh></v>
<v t="karstenw.20240123172853.75"><vh>class OffscreenBufferError</vh></v>
<v t="karstenw.20240123172853.76"><vh>class OffscreenBuffer</vh>
<v t="karstenw.20240123172853.77"><vh>__init__</vh></v>
<v t="karstenw.20240123172853.78"><vh>_init</vh></v>
<v t="karstenw.20240123172853.79"><vh>width</vh></v>
<v t="karstenw.20240123172853.80"><vh>height</vh></v>
<v t="karstenw.20240123172853.81"><vh>active</vh></v>
<v t="karstenw.20240123172853.82"><vh>push</vh></v>
<v t="karstenw.20240123172853.83"><vh>pop</vh></v>
<v t="karstenw.20240123172853.84"><vh>render</vh></v>
<v t="karstenw.20240123172853.85"><vh>draw</vh></v>
<v t="karstenw.20240123172853.86"><vh>slice</vh></v>
<v t="karstenw.20240123172853.87"><vh>reset</vh></v>
<v t="karstenw.20240123172853.88"><vh>clear</vh></v>
<v t="karstenw.20240123172853.89"><vh>_init_depthbuffer</vh></v>
<v t="karstenw.20240123172853.90"><vh>__del__</vh></v>
</v>
<v t="karstenw.20240123172853.91"><vh>filter</vh></v>
<v t="karstenw.20240123172853.92"><vh>class RenderedImage</vh>
<v t="karstenw.20240123172853.93"><vh>draw</vh></v>
<v t="karstenw.20240123172853.94"><vh>save</vh></v>
</v>
<v t="karstenw.20240123172853.95"><vh>render</vh></v>
<v t="karstenw.20240123172853.96"><vh>invert</vh></v>
<v t="karstenw.20240123172853.97"><vh>solid</vh></v>
<v t="karstenw.20240123172853.98"><vh>gradient</vh></v>
<v t="karstenw.20240123172853.99"><vh>colorize</vh></v>
<v t="karstenw.20240123172853.100"><vh>adjust</vh></v>
<v t="karstenw.20240123172853.101"><vh>desaturate</vh></v>
<v t="karstenw.20240123172853.102"><vh>brightpass</vh></v>
<v t="karstenw.20240123172853.103"><vh>blur</vh></v>
<v t="karstenw.20240123172853.104"><vh>transparent</vh></v>
<v t="karstenw.20240123172853.105"><vh>_q</vh></v>
<v t="karstenw.20240123172853.106"><vh>mask</vh></v>
<v t="karstenw.20240123172853.107"><vh>blend</vh></v>
<v t="karstenw.20240123172853.108"><vh>add</vh></v>
<v t="karstenw.20240123172853.109"><vh>subtract</vh></v>
<v t="karstenw.20240123172853.110"><vh>lighten</vh></v>
<v t="karstenw.20240123172853.111"><vh>darken</vh></v>
<v t="karstenw.20240123172853.112"><vh>multiply</vh></v>
<v t="karstenw.20240123172853.113"><vh>screen</vh></v>
<v t="karstenw.20240123172853.114"><vh>overlay</vh></v>
<v t="karstenw.20240123172853.115"><vh>hardlight</vh></v>
<v t="karstenw.20240123172853.116"><vh>hue</vh></v>
<v t="karstenw.20240123172853.117"><vh>glow</vh></v>
<v t="karstenw.20240123172853.118"><vh>bloom</vh></v>
<v t="karstenw.20240123172853.119"><vh>distortion_mixin</vh></v>
<v t="karstenw.20240123172853.120"><vh>bump</vh></v>
<v t="karstenw.20240123172853.121"><vh>dent</vh></v>
<v t="karstenw.20240123172853.122"><vh>pinch</vh></v>
<v t="karstenw.20240123172853.123"><vh>twirl</vh></v>
<v t="karstenw.20240123172853.124"><vh>splash</vh></v>
<v t="karstenw.20240123172853.125"><vh>stretch</vh></v>
<v t="karstenw.20240123172853.126"><vh>mirror</vh></v>
<v t="karstenw.20240123172853.127"><vh>dropshadow</vh></v>
<v t="karstenw.20240123172853.128"><vh>inverted</vh></v>
<v t="karstenw.20240123172853.129"><vh>colorized</vh></v>
<v t="karstenw.20240123172853.130"><vh>adjusted</vh></v>
<v t="karstenw.20240123172853.131"><vh>desaturated</vh></v>
<v t="karstenw.20240123172853.132"><vh>blurred</vh></v>
<v t="karstenw.20240123172853.133"><vh>masked</vh></v>
<v t="karstenw.20240123172853.134"><vh>blended</vh></v>
<v t="karstenw.20240123172853.135"><vh>distorted</vh></v>
</v>
</v>
<v t="karstenw.20231124170948.1"><vh>gui</vh></v>
<v t="karstenw.20231124170950.1"><vh>sound</vh></v>
</v>
<v t="karstenw.20231124170901.1"><vh>examples</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="karstenw.20231124170756.2"></t>
<t tx="karstenw.20231124170851.1"></t>
<t tx="karstenw.20231124170856.1"></t>
<t tx="karstenw.20231124170901.1"></t>
<t tx="karstenw.20231124170908.1"></t>
<t tx="karstenw.20231124170943.1"></t>
<t tx="karstenw.20231124170948.1"></t>
<t tx="karstenw.20231124170950.1"></t>
<t tx="karstenw.20231124170956.1">#=== NODEBOX FOR OPENGL ========================================================

# NodeBox for OpenGL is a Python module for creating 2D interactive visuals
# using OpenGL. 
# 
# It is based on the command set of the classic NodeBox for Mac OS X
# (http://nodebox.net).
# 
# It has support for Bezier paths, text, image filters (blur, bloom, ...),
# offscreen rendering, animation &amp; motion tweening, and simple 2D physics.

@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20231124171037.1">__author__    = "Tom De Smedt, Frederik De Bleser"
__version__   = "1.8"
__copyright__ = "Copyright (c) 2008-2012 City In A Bottle (cityinabottle.org)"
__license__   = "BSD"

import sys

import nodeboxgl
</t>
<t tx="karstenw.20231124171143.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20231124171244.1">import os
from setuptools import setup
from setuptools import find_packages
from setuptools.extension import Extension


nglbezier   = Extension("nglbezier",   sources=["nglbezier.c"])
nglgeometry = Extension("nglgeometry", sources=["nglgeometry.c"])
nglnoise    = Extension("nglnoise",    sources=["nglnoise.c"])

setup(
         name = "Nodebox for OpenGL c-extensions",
      version = "1.0",
       author = "Tom De Smedt, Frederik De Bleser",
  description = "Fast C Bezier, geometry and noise math.",
  ext_modules = [nglbezier, nglgeometry, nglnoise]
)
</t>
<t tx="karstenw.20240123172532.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20240123172554.1">#=== CHARACTER GLYPH PATHS ===========================================================================
# NodeBox for OpenGL has no direct way of accessing glyph path information.
# This script is to be used in the classic NodeBox for Mac OS X (http://nodebox.net).
# It uses the textpath() command to convert characters to paths,
# and store the paths in a file that can be used by NodeBox for OpenGL as glyph path info.

# Defines the characters to process.
# By default, only standard ASCII characters are converted.
from itertools import chain

import io

# characters = range(32, 127)
characters = list(chain( range(32,127), range(160, 512)))

# Defines which fonts to process.
# By default, only the standard fonts in NodeBox for OpenGL
# are converted (Droid Sans, Droid Sans Mono, Droid Serif, Arial).
fonts = {
    "Droid Sans": {
         "normal" : "DroidSans", # PostScript-name.
           "bold" : "DroidSans-Bold"
    },
    "Droid Sans Mono": {
         "normal" : "DroidSansMono"
    },
    "Droid Serif": {
         "normal" : "DroidSerif",
           "bold" : "DroidSerif-Bold",
         "italic" : "DroidSerif-Italic",
    "bold italic" : "DroidSerif-BoldItalic" 
    },
    "Arial": {
         "normal" : "ArialMT",
           "bold" : "Arial-BoldMT",  
    },
    'Verdana': {'bold': 'Verdana-Bold',
             'bold italic': 'Verdana-BoldItalic',
             'italic': 'Verdana-Italic',
             'normal': 'Verdana'},
    'Monaco': {'normal': 'Monaco'},
    'Menlo': {'bold': 'Menlo-Bold',
           'bold italic': 'Menlo-BoldItalic',
           'italic': 'Menlo-Italic',
           'normal': 'Menlo-Regular'},
    'Herculanum': {'normal': 'Herculanum'},
    # 'Acme': {'normal': 'Acme-Regular'},
    'Gill Sans': {
        'bold': 'GillSans-Bold',
        'bold italic': 'GillSans-BoldItalic',
        'italic': 'GillSans-Italic',
        'light': 'GillSans-Light',
        'light italic': 'GillSans-LightItalic',
        'normal': u'GillSans'},
    'FontAwesome': {'normal': 'FontAwesome'},
    'Futura': {
        'condensed extrabold': 'Futura-CondensedExtraBold',
        'condensed medium': 'Futura-CondensedMedium',
        'medium': 'Futura-Medium',
        'medium italic': 'Futura-MediumItalic'},
    'Lato': {
        'normal': 'Lato-Regular',
        'light': 'Lato-Hairline',
        'bold': 'Lato-Bold',
        'bold italic': 'Lato-BoldItalic',
    },
}
"""
    'Eurostile': {
        'bold': 'Eurostile-Bold',
        'bold condensed': 'Eurostile-BoldCondensed',
        'bold extended': 'Eurostile-BoldExtendedTwo',
        'bold oblique': 'Eurostile-BoldOblique',
        'condensed': 'Eurostile-Condensed',
        'demi': 'Eurostile-Demi',
        'demi oblique': 'Eurostile-DemiOblique',
        'extended': 'Eurostile-ExtendedTwo',
        'normal': 'Eurostile',
        'oblique': 'Eurostile-Oblique'},
}
"""

# How point size is measured (NodeBox for OpenGL uses 96dpi).
dpi = 96

# Measure from the baseline?
baseline = True

#=====================================================================================================

glyphs = {}

commands = {
    0: "moveto", 
    1: "lineto", 
    2: "curveto", 
    3: "close"
}

from AppKit import NSFont
</t>
<t tx="karstenw.20240123172554.2">def descent(fontname, fontsize=10):
    return NSFont.fontWithName_size_(fontname, fontsize).descender()
    
for fontname in fonts:
    glyphs[fontname] = {}
    print(fontname)
    for fontweight in fonts[fontname]:
        print("   "+fontweight)
        glyphs[fontname][fontweight] = {}
        # Render the font at a large size so we can round the path points.
        # This saves disk space and decreases the loading time.
        _ctx.font(fonts[fontname][fontweight])
        _ctx.fontsize(1000.0 * dpi / 72)
        _ctx.lineheight(1.0)
        dy = baseline and descent(fontname, _ctx.fontsize()) or 0
        for i in characters:
            # ch = unichr(i)
            ch = chr(i)
            # print( i, ch )
            glyphs[fontname][fontweight][ch] = []
            for pt in _ctx.textpath(ch, 0, 0):
                if pt.cmd == 0:
                    pt = [commands[pt.cmd], int(pt.x), int(pt.y-dy)]
                elif pt.cmd == 1:
                    pt = [commands[pt.cmd], int(pt.x), int(pt.y-dy)]
                elif pt.cmd == 2:
                    pt = [commands[pt.cmd], 
                          int(pt.x), int(pt.y-dy), 
                          int(pt.ctrl1.x), int(pt.ctrl1.y-dy), 
                          int(pt.ctrl2.x), int(pt.ctrl2.y-dy)]
                elif pt.cmd == 3:
                    pt = [commands[pt.cmd]]
                glyphs[fontname][fontweight][ch].append(pt)

import pickle
f = open("glyph.p","wb")
pickle.dump(glyphs, f)
f.close()

#=====================================================================================================
# For testing purposes:

</t>
<t tx="karstenw.20240123172554.3">def textpath_from_glyphs(string, x=0, y=0, fontname="Droid Sans", fontweight="normal"):
    glyphs = pickle.load(open("glyph.p", 'rb'))
    p = _ctx.BezierPath()
    f = _ctx.fontsize() / 1000.0 * 72 / dpi
    y += textheight(" ", lineheight()) - textheight(" ", lineheight=1)
    from nodebox.graphics import MOVETO, LINETO, CURVETO, CLOSE
    for ch in string:
        glyph = glyphs[fontname][fontweight][ch]
        for pt in glyph:
            if pt[0] == "moveto":
                p.moveto(x+pt[1]*f, y+pt[2]*f)
            elif pt[0] == "lineto":
                p.lineto(x+pt[1]*f, y+pt[2]*f)
            elif pt[0] == "curveto":
                p.curveto(x+pt[3]*f, y+pt[4]*f, x+pt[5]*f, y+pt[6]*f, x+pt[1]*f, y+pt[2]*f)
            elif pt[0] == "close":
                p.closepath()
        x += _ctx.textwidth(ch)
    return p
textpath_from_glyphs("Hello World!", 100,100 )
</t>
<t tx="karstenw.20240123172657.1">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20240123172734.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20240123172753.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20240123172754.1">@language python
@tabwidth -4
@others
</t>
<t tx="karstenw.20240123172754.2">@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20240123172755.1">
# Fragment shaders, filters, Frame Buffer Object (FBO)
# Authors: Tom De Smedt, Frederik De Bleser
# License: BSD (see LICENSE.txt for details).
# Copyright (c) 2008-2012 City In A Bottle (cityinabottle.org)
# http://cityinabottle.org/nodebox

@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20240123172826.1">#=== PHYSICS =========================================================================================
# 2D physics functions.
# Authors: Tom De Smedt, Giorgio Olivero
# License: BSD (see LICENSE.txt for details).
# Copyright (c) 2008-2012 City In A Bottle (cityinabottle.org)
# http://cityinabottle.org/nodebox

# This module can benefit greatly from loading psyco.

@others
@language python
@tabwidth -4
</t>
<t tx="karstenw.20240123172852.1">from pyglet.gl    import *
from pyglet.image import Texture, SolidColorImagePattern
from .context      import Image, texture
from .geometry     import lerp, clamp
from math         import radians
from ctypes       import byref, cast, pointer, POINTER
from ctypes       import c_char, c_char_p, c_uint, c_int

</t>
<t tx="karstenw.20240123172852.10">class ShaderError(Exception):
    @others
</t>
<t tx="karstenw.20240123172852.11">def __init__(self, value, type=COMPILE):
    Exception.__init__(self, "%s error: %s" % (type, value))
    self.value = value
    self.type  = type

</t>
<t tx="karstenw.20240123172852.12">class Shader(object):
   
    @others
</t>
<t tx="karstenw.20240123172852.13">def __init__(self, vertex=DEFAULT, fragment=DEFAULT):
    """ A per-pixel shader effect (blur, fog, glow, ...) executed on the GPU.
        Shader wraps a compiled GLSL program and facilitates passing parameters to it.
        The fragment and vertex parameters contain the GLSL source code to execute.
        Raises a ShaderError if the source fails to compile.
        Once compiled, you can set uniform variables in the GLSL source with Shader.set().
    """
    if vertex == DEFAULT:
        vertex = DEFAULT_VERTEX_SHADER
    if fragment == DEFAULT:
        fragment = DEFAULT_FRAGMENT_SHADER
    self._vertex   = vertex   # GLSL source for vertex shader.
    self._fragment = fragment # GLSL source for fragment shader.
    self._compiled = []
    self._program  = None
    self._active   = False
    self.variables = {}
    self._build()

</t>
<t tx="karstenw.20240123172852.14">def _compile(self, source, type=GL_VERTEX_SHADER):
    # Compile the GLSL source code, either as GL_FRAGMENT_SHADER or GL_VERTEX_SHADER.
    # If the source fails to compile, retrieve the error message and raise ShaderError.
    # Store the compiled shader so we can delete it later on.
    shader = glCreateShader(type)
    status = c_int(-1)
    glShaderSource(shader, 1, cast(pointer(c_char_p(source)), POINTER(POINTER(c_char))), None)
    glCompileShader(shader)
    glGetShaderiv(shader, GL_COMPILE_STATUS, byref(status))
    if status.value == 0:
        raise self._error(shader, type=COMPILE)
    self._compiled.append(shader)
    return shader
    
</t>
<t tx="karstenw.20240123172852.15">def _build(self):
    # Each Shader has its own OpenGL rendering program and you need to switch between them.
    # Compile fragment and vertex shaders and build the program.
    program = glCreateProgram()
    status  = c_int(-1)
    if self._vertex:
        glAttachShader(program, self._compile(self._vertex, GL_VERTEX_SHADER))
    if self._fragment:
        glAttachShader(program, self._compile(self._fragment, GL_FRAGMENT_SHADER))
    glLinkProgram(program)
    glGetProgramiv(program, GL_LINK_STATUS, byref(status))
    if status.value == 0:
        raise self._error(program, type=BUILD)
    self._program = program

</t>
<t tx="karstenw.20240123172852.16">def _error(self, obj, type=COMPILE):
    # Get the info for the failed glCompileShader() or glLinkProgram(),
    # delete the failed shader or program,
    # return a ShaderError with the error message.
    f1 = type==COMPILE and glGetShaderiv      or glGetProgramiv
    f2 = type==COMPILE and glGetShaderInfoLog or glGetProgramInfoLog
    f3 = type==COMPILE and glDeleteShader     or glDeleteProgram
    length = c_int(); f1(obj, GL_INFO_LOG_LENGTH, byref(length))  
    msg = ""     
    if length.value &gt; 0:
        msg = create_string_buffer(length.value); f2(obj, length, byref(length), msg)
        msg = msg.value
    f3(obj)
    return ShaderError(msg, type)

</t>
<t tx="karstenw.20240123172852.17">def get(self, name):
    """ Returns the value of the variable with the given name.
    """
    return self.variables[name]

</t>
<t tx="karstenw.20240123172852.18">def set(self, name, value):
    """ Set the value of the variable with the given name in the GLSL source script.
        Supported variable types are: vec2(), vec3(), vec4(), single int/float, list of int/float.
        Variables will be initialized when Shader.push() is called (i.e. glUseProgram).
    """
    self.variables[name] = value
    if self._active:
        self._set(name, value)

</t>
<t tx="karstenw.20240123172852.19">def _set(self, name, value):
    address = glGetUniformLocation(self._program, name)
    # A vector with 2, 3 or 4 floats representing vec2, vec3 or vec4.
    if isinstance(value, vector):
        if len(value) == 2:
            glUniform2f(address, value[0], value[1])
        elif len(value) == 3:
            glUniform3f(address, value[0], value[1], value[2])
        elif len(value) == 4:
            glUniform4f(address, value[0], value[1], value[2], value[3])
    # A list representing an array of ints or floats.
    elif isinstance(value, (list, tuple)):
        if next((v for v in value if isinstance(v, float))) is not None:
            array = c_float * len(value)
            glUniform1fv(address, len(value), array(*value))
        else:
            array = c_int * len(value)
            glUniform1iv(address, len(value), array(*value))
    # Single float value.
    elif isinstance(value, float):
        glUniform1f(address, value)
    # Single int value or named texture.
    elif isinstance(value, int):
        glUniform1i(address, value)
    else:
        ShaderError, "don't know how to handle variable %s" % value.__class__

</t>
<t tx="karstenw.20240123172852.2">
#def next(generator, default=None):
#    try: 
#        return generator.next()
#    except StopIteration:
#        return default


#=====================================================================================================

pow2 = [2**n for n in range(20)] # [1, 2, 4, 8, 16, 32, 64, ...]

</t>
<t tx="karstenw.20240123172852.3">def ceil2(x):
    """ Returns the nearest power of 2 that is higher than x, e.g. 700 =&gt; 1024.
    """
    for y in pow2:
        if y &gt;= x: return y
            
</t>
<t tx="karstenw.20240123172852.4">def extent2(texture):
    """ Returns the extent of the image data (0.0-1.0, 0.0-1.0) inside its texture owner.
        Textures have a size power of 2 (512, 1024, ...), but the actual image can be smaller.
        For example: a 400x250 image will be loaded in a 512x256 texture.
        Its extent is (0.78, 0.98), the remainder of the texture is transparent.
    """
    return (texture.tex_coords[3], texture.tex_coords[7])
    
</t>
<t tx="karstenw.20240123172852.5">def ratio2(texture1, texture2):
    """ Returns the size ratio (0.0-1.0, 0.0-1.0) of two texture owners.
    """
    return (
        float(ceil2(texture1.width)) / ceil2(texture2.width), 
        float(ceil2(texture1.height)) / ceil2(texture2.height)
    )

#=====================================================================================================

#--- SHADER ------------------------------------------------------------------------------------------
# A shader is a pixel effect (motion blur, fog, glow) executed on the GPU.
# The effect has two distinct parts: a vertex shader and a fragment shader.
# The vertex shader retrieves the coordinates of the current pixel.
# The fragment shader manipulates the color of the current pixel.
# http://www.lighthouse3d.com/opengl/glsl/index.php?fragmentp
# Shaders are written in GLSL and expect their variables to be set from glUniform() calls.
# The Shader class compiles the source code and has an easy way to pass variables to GLSL.
# e.g. shader = Shader(fragment=open("colorize.frag").read())
#      shader.set("color", vec4(1, 0.8, 1, 1))
#      shader.push()
#      image("box.png", 0, 0)
#      shader.pop()

DEFAULT = "default"
DEFAULT_VERTEX_SHADER = '''
void main() { 
    gl_TexCoord[0] = gl_MultiTexCoord0; 
    gl_Position = ftransform(); 
}'''
DEFAULT_FRAGMENT_SHADER = '''
uniform sampler2D src;
void main() {
    gl_FragColor = texture2D(src, gl_TexCoord[0].xy);
}'''

</t>
<t tx="karstenw.20240123172852.6">class vector(tuple): 
    pass
    
</t>
<t tx="karstenw.20240123172852.7">def vec2(f1, f2):
    return vector((f1, f2))
</t>
<t tx="karstenw.20240123172852.8">def vec3(f1, f2, f3):
    return vector((f1, f2, f3))
</t>
<t tx="karstenw.20240123172852.9">def vec4(f1, f2, f3, f4):
    return vector((f1, f2, f3, f4))

COMPILE = "compile" # Error occurs during glCompileShader().
BUILD   = "build"   # Error occurs during glLinkProgram().
</t>
<t tx="karstenw.20240123172853.1">def push(self):
    """ Installs the program and sets its variables.
        When you use the image() command between shader.push() and shader.pop(),
        the shader's effect will be applied to the image before drawing it.
        To use shader effects in combination with paths,
        draw the path in an offscreen buffer, render it, and apply to effect to the render.
    """
    self._active = True
    glUseProgram(self._program)
    for k, v in self.variables.items():
        self._set(k, v)
        
</t>
<t tx="karstenw.20240123172853.10">def get(self, name):
    return None
</t>
<t tx="karstenw.20240123172853.100">def adjust(img, brightness=1.0, contrast=1.0, saturation=1.0, hue=0.0):
    """ Applies color adjustment filters to the image and returns the adjusted image.
        - brightness: the overall lightness or darkness (0.0 is a black image).
        - contrast  : the difference in brightness between regions.
        - saturation: the intensity of the colors (0.0 is a grayscale image).
        - hue       : the shift in hue (1.0 is 360 degrees on the color wheel).
    """
    if brightness != 1: img = filter(img, BrightnessAdjustment(img.texture, brightness))
    if contrast   != 1: img = filter(img, ContrastAdjustment(img.texture, contrast))
    if saturation != 1: img = filter(img, SaturationAdjustment(img.texture, saturation))
    if hue        != 0: img = filter(img, HueAdjustment(img.texture, hue))
    return img
    
</t>
<t tx="karstenw.20240123172853.101">def desaturate(img):
    """ Returns a grayscale version of the image.
    """
    return filter(img, SaturationAdjustment(img.texture, 0.0))
    
grayscale = desaturate

</t>
<t tx="karstenw.20240123172853.102">def brightpass(img, threshold=0.3):
    """ Applies a bright pass filter, where pixels whose luminance falls below the threshold are black.
    """
    return filter(img, BrightPass(img.texture, threshold))

</t>
<t tx="karstenw.20240123172853.103">def blur(img, kernel=5, scale=1.0, amount=1, cumulative=False):
    """ Applies a blur filter to the image and returns the blurred image.
        - kernel: the size of the convolution matrix (e.g. 9 = 9x9 convolution kernel).
        - scale : the radius of the effect, a higher scale will create a rougher but faster blur.
        - amount: the number of the times to apply the blur filter;
                  because blurred layers are pasted on top of each other cumulatively
                  this produces a nicer effect than repeatedly using blur() in a for-loop
                  (which blurs the blurred).
    """
    for i in range(amount):
        clear = i==0 or not cumulative
        img = filter(img, HorizontalBlur(img.texture, kernel, scale), clear=clear)
        img = filter(img, VerticalBlur(img.texture, kernel, scale), clear=clear)
    return img

</t>
<t tx="karstenw.20240123172853.104">def transparent(img, alpha=1.0):
    """ Returns a transparent version of the image.
        - alpha: the percentage of the original opacity of the image (0.0-1.0).
    """
    return filter(img, AlphaTransparency(img.texture, alpha))

</t>
<t tx="karstenw.20240123172853.105">def _q(img):
    # For images functioning as masks or blend layers,
    # apply any quad distortian and then use the texture of the distored image.
    if img.quad != (0,0,0,0,0,0,0,0):
        return filter(img)
    return img

</t>
<t tx="karstenw.20240123172853.106">def mask(img1, img2, alpha=1.0, dx=0, dy=0):
    """ Applies the second image as an alpha mask to the first image.
        The second image must be a grayscale image, where the black areas
        make the first image transparent (e.g. punch holes in it).
        - dx: horizontal offset (in pixels) of the alpha mask.
        - dy: vertical offset (in pixels) of the alpha mask.
    """
    return filter(img1, AlphaMask(img1.texture, _q(img2).texture, alpha, dx, dy))

</t>
<t tx="karstenw.20240123172853.107">def blend(img1, img2, mode=OVERLAY, alpha=1.0, dx=0, dy=0):
    """ Applies the second image as a blend layer with the first image.
        - dx: horizontal offset (in pixels) of the blend layer.
        - dy: vertical offset (in pixels) of the blend layer.
    """
    return filter(img1, Blend(mode, img1.texture, _q(img2).texture, alpha, dx, dy))

</t>
<t tx="karstenw.20240123172853.108">def add(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(ADD, img1.texture, _q(img2).texture, alpha, dx, dy))

</t>
<t tx="karstenw.20240123172853.109">def subtract(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(SUBTRACT, img1.texture, _q(img2).texture, alpha, dx, dy))

</t>
<t tx="karstenw.20240123172853.11">def set(self, name, value):
    pass
</t>
<t tx="karstenw.20240123172853.110">def lighten(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(LIGHTEN, img1.texture, _q(img2).texture, alpha, dx, dy))
    
</t>
<t tx="karstenw.20240123172853.111">def darken(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(DARKEN, img1.texture, _q(img2).texture, alpha, dx, dy))

</t>
<t tx="karstenw.20240123172853.112">def multiply(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(MULTIPLY, img1.texture, _q(img2).texture, alpha, dx, dy))
    
</t>
<t tx="karstenw.20240123172853.113">def screen(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(SCREEN, img1.texture, _q(img2).texture, alpha, dx, dy))
    
</t>
<t tx="karstenw.20240123172853.114">def overlay(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(OVERLAY, img1.texture, _q(img2).texture, alpha, dx, dy))

</t>
<t tx="karstenw.20240123172853.115">def hardlight(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(HARDLIGHT, img1.texture, _q(img2).texture, alpha, dx, dy))
    
</t>
<t tx="karstenw.20240123172853.116">def hue(img1, img2, alpha=1.0, dx=0, dy=0):
    return filter(img1, Blend(HUE, img1.texture, _q(img2).texture, alpha, dx, dy))
    
</t>
<t tx="karstenw.20240123172853.117">def glow(img, intensity=0.5, amount=1):
    """ Returns the image blended with a blurred version, yielding a glowing effect.
        - intensity: the opacity of the blur (0.0-1.0).
        - amount   : the number of times to blur. 
    """
    b = blur(img, kernel=9, scale=1.0, amount=max(1, amount))
    return add(img, b, alpha=intensity)

</t>
<t tx="karstenw.20240123172853.118">def bloom(img, intensity=0.5, amount=1, threshold=0.3):
    """ Returns the image blended with a blurred brightpass version, yielding a "magic glow" effect.
        - intensity: the opacity of the blur (0.0-1.0).
        - amount   : the number of times to blur.
        - threshold: the luminance threshold of pixels that light up.
    """
    b = brightpass(img, threshold)
    b = blur(img, kernel=9, scale=1.0, amount=max(1, amount))
    return add(img, b, alpha=intensity)

</t>
<t tx="karstenw.20240123172853.119">def distortion_mixin(type, dx, dy, **kwargs):
    # Each distortion filter has specific parameters to tweak the effect (usually radius and zoom).
    # Returns the magnitude m and intensity i from the keyword arguments,
    # which are the parameters expected by the Distortion Filter class.
    if type == BUMP:
        m = kwargs.get("radius", 0.5)
        i = lerp(-m*20, m*0.25, max(0, kwargs.get("zoom", 0.5))**0.1)
    elif type == DENT:
        m = max(0, 2 * kwargs.get("radius", 0.5))
        i = max(0, 1 * kwargs.get("zoom", 0.5))
    elif type == PINCH:
        m = 1.0
        i = max(0.2, 2 * kwargs.get("zoom", 0.75))
    elif type == TWIRL:
        m = kwargs.get("radius", 1.0)
        i = radians(kwargs.get("angle", 180.0))
    elif type == SPLASH:
        m = kwargs.get("radius", 0.5)
        i = 0
    elif type == MIRROR:
        m = int(kwargs.get("horizontal", True))
        i = int(kwargs.get("vertical", True))
        dx = clamp(dx, -0.5, 1.5)
        dy = clamp(dy, -0.5, 1.5)
    elif type == STRETCH:
        m = max(0, kwargs.get("radius", 0.5))
        i = max(0, min(1, 0.5 * kwargs.get("zoom", 1.0)))
    else:
        m = 0.5
        i = 0.5
    return dx, dy, m, i

#def bump(img, dx=0.5, dy=0.5, radius=0.5, zoom=0.5)
</t>
<t tx="karstenw.20240123172853.12">def push(self):
    pass
</t>
<t tx="karstenw.20240123172853.120">def bump(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image with a bump distortion applied to it.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - radius: the radius of the affected area, proportional to the image size.
        - zoom: the amount to zoom in.
    """
    dx, dy, m, i = distortion_mixin(BUMP, dx, dy, **kwargs)
    return filter(img, filter=Distortion(BUMP, img.texture, dx-0.5, dy-0.5, m, i))

#def dent(img, dx=0.5, dy=0.5, radius=0.5, zoom=0.5)    
</t>
<t tx="karstenw.20240123172853.121">def dent(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image with a dent distortion applied to it.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - radius: the radius of the affected area, proportional to the image size.
        - zoom: the amount to zoom in.
    """
    dx, dy, m, i = distortion_mixin(DENT, dx, dy, **kwargs)
    return filter(img, filter=Distortion(DENT, img.texture, dx-0.5, dy-0.5, m, i))

#def pinch(img, dx=0.5, dy=0.5, zoom=0.75)
</t>
<t tx="karstenw.20240123172853.122">def pinch(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image with a pinch distortion applied to it.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - zoom: the amount of bulge (0.1-0.5) or pinch (0.5-1.0):
    """
    dx, dy, m, i = distortion_mixin(PINCH, dx, dy, **kwargs)
    return filter(img, filter=Distortion(PINCH, img.texture, dx-0.5, dy-0.5, m, i))

#def twirl(img, dx=0.5, dy=0.5, radius=1.0, angle=180.0)
</t>
<t tx="karstenw.20240123172853.123">def twirl(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image with a twirl distortion applied to it.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - radius: the radius of the effect, proportional to the image size.
        - angle: the amount of rotation in degrees.
    """
    dx, dy, m, i = distortion_mixin(TWIRL, dx, dy, **kwargs)
    return filter(img, filter=Distortion(TWIRL, img.texture, dx-0.5, dy-0.5, m, i))

#def splash(img, dx=0.5, dy=0.5, radius=0.5)
</t>
<t tx="karstenw.20240123172853.124">def splash(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image with a light-tunnel distortion applied to it.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - radius: the radius of the unaffected area, proportional to the image size.
    """
    dx, dy, m, i = distortion_mixin(SPLASH, dx, dy, **kwargs)
    return filter(img, filter=Distortion(SPLASH, img.texture, dx-0.5, dy-0.5, m, i))

#def stretch(img, dx=0.5, dy=0.5, radius=0.5, zoom=1.0)
</t>
<t tx="karstenw.20240123172853.125">def stretch(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image with a zoom box distortion applied to it.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - radius: the radius of the affected area, proportional to the image size.
        - zoom: the amount to zoom in (0.0-2.0, where 1.0 means 1x zoomed in, or 200%).
    """
    dx, dy, m, i = distortion_mixin(STRETCH, dx, dy, **kwargs)
    return filter(img, filter=Distortion(STRETCH, img.texture, dx-0.5, dy-0.5, m, i))

#def mirror(img, dx=0.5, dy=0.5, horizontal=True, vertical=True)
</t>
<t tx="karstenw.20240123172853.126">def mirror(img, dx=0.5, dy=0.5, **kwargs):
    """ Returns the image mirrored along horizontal axis dx and vertical axis dy.
        - dx: horizontal origin of the effect, between 0.0 and 1.0.
        - dy: vertical origin of the effect, between 0.0 and 1.0.
        - horizontal: when True, mirrors the image horizontally.
        - vertical  : when True, mirrors the image vertically.
    """
    dx, dy, m, i = distortion_mixin(MIRROR, dx, dy, **kwargs)
    return filter(img, filter=Distortion(MIRROR, img.texture, dx-0.5, dy-0.5, m, i))

</t>
<t tx="karstenw.20240123172853.127">def dropshadow(img, alpha=0.5, amount=2, kernel=5):
    """ Returns a blurred and grayscale version of the image.
        If filters are not supported, returns a grayscale version without blur (using Image.color).
    """
    if not SUPPORTED:
        t = texture(img)
    else:
        t = blur(img, kernel=kernel, amount=amount).texture
    img = isinstance(img, Image) and img.copy(t) or Image(t)
    img.color.rgba = (0,0,0, alpha)
    return img

#--- ONSCREEN FILTERS --------------------------------------------------------------------------------
# These can be used directly as filter parameter for the image() command.
# This may be faster because no offscreen buffer is used to render the effect.

</t>
<t tx="karstenw.20240123172853.128">def inverted():
    return Invert(None)

</t>
<t tx="karstenw.20240123172853.129">def colorized(color=(1,1,1,1), bias=(0,0,0,0)):
    return Colorize(None, vec4(*color), vec4(*bias))
        
</t>
<t tx="karstenw.20240123172853.13">def pop(self):
    pass

</t>
<t tx="karstenw.20240123172853.130">def adjusted(mode, v):
    if mode == BRIGHTNESS: 
        return BrightnessAdjustment(None, v)
    if mode == CONTRAST:
        return ContrastAdjustment(None, v)
    if mode == SATURATION:
        return SaturationAdjustment(None, v)
    if mode == HUE:
        return HueAdjustment(None, v)
    
</t>
<t tx="karstenw.20240123172853.131">def desaturated():
    return SaturationAdjustment(None, 0.0)
    
</t>
<t tx="karstenw.20240123172853.132">def blurred(scale=1.0):
    return Gaussian3x3Blur(None, scale)

</t>
<t tx="karstenw.20240123172853.133">def masked(img, alpha=1.0, dx=0, dy=0):
    return AlphaMask(None, _q(img).texture, alpha, dx, dy)

</t>
<t tx="karstenw.20240123172853.134">def blended(mode, img, alpha=1.0, dx=0, dy=0):
    return Blend(mode, None, _q(img).texture, alpha, dx, dy)
    
</t>
<t tx="karstenw.20240123172853.135">def distorted(type, dx=0.5, dy=0.5, **kwargs):
    dx, dy, m, i = distortion_mixin(type, dx, dy, **kwargs)
    return Distortion(type, None, dx-0.5, dy-0.5, m, i)
</t>
<t tx="karstenw.20240123172853.14">def shader(vertex=DEFAULT_VERTEX_SHADER, fragment=DEFAULT_FRAGMENT_SHADER, silent=True):
    """ Returns a compiled Shader from the given GLSL source code.
        With silent=True, never raises an error but instead returns a ShaderFacade.
        During startup, a number of Shaders are created.
        This mechanisms ensures that the module doesn't crash while doing this,
        instead the shader simply won't have any visible effect and SUPPORTED will be False.
    """
    if not silent:
        return Shader(vertex, fragment)
    try:
        return Shader(vertex, fragment)
    except Exception as e:
        SUPPORTED = False
        return ShaderFacade()

#=====================================================================================================

#--- FILTER ------------------------------------------------------------------------------------------
# Stores a shader's variables and applies them once push() is called.
# The shader is created only once for perfomance while filters can exist multiple times.
# Textures that are drawn between Filter.push() and Filter.pop() have the effect applied to them.

</t>
<t tx="karstenw.20240123172853.15">class Filter(object):
    
    @others
#=====================================================================================================

#--- INVERT -----------------------------------------------------------------------------------------

_invert = shader(fragment='''
uniform sampler2D src;
void main() {
    gl_FragColor = texture2D(src, gl_TexCoord[0].xy);
    gl_FragColor.rgb = 1.0 - gl_FragColor.rgb;
}''')

</t>
<t tx="karstenw.20240123172853.16">def __init__(self):
    """ Filter combines a Shader with variable settings.
        Variables need to be prepared in Filter.push() before passing them to the shader:
        e.g. creating a list of kernel values, calculating a scale based on image height, ...
        Performance note: create the Shader separately, not during initialization.
    """
    # Shader and its variables need to be stored here.
    self.shader  = None
    self.texture = None
    
</t>
<t tx="karstenw.20240123172853.17">def push(self):
    """ Installs the filter so it will be applied to the next image() call.
    """
    # Shader needs to set its variables here:
    # self.shader.set(variable, value)
    self.shader.push()
    
</t>
<t tx="karstenw.20240123172853.18">def pop(self):
    """ Removes the filter.
    """
    self.shader.pop()

</t>
<t tx="karstenw.20240123172853.19">class Invert(Filter):
    
    @others
#--- GRADIENT ----------------------------------------------------------------------------------------

LINEAR = "linear"
RADIAL = "radial"

_gradient = {}
_gradient[LINEAR] = shader(fragment='''
uniform sampler2D src;
uniform vec4 clr1;
uniform vec4 clr2;
void main() {
    vec2 v = gl_TexCoord[0].xy;
    gl_FragColor = clr1 * v.y + clr2 * (1.0 - v.y);
}''')
_gradient[RADIAL] = shader(fragment='''
uniform sampler2D src;
uniform vec4 clr1;
uniform vec4 clr2;
void main() {
    vec2 v = gl_TexCoord[0].xy - 0.5;
    float d = 4.0 * (v.x * v.x + v.y * v.y);
    gl_FragColor = clr1 * (1.0 - d) + clr2 * d;
}''')

</t>
<t tx="karstenw.20240123172853.2">def pop(self):
    # Note that shaders can't be nested since they all have their own program,
    # pop() just removes any active program.
    if self._active == True:
        glUseProgram(0)
        self._active = False

</t>
<t tx="karstenw.20240123172853.20">def __init__(self, texture):
    self.shader  = _invert
    self.texture = texture
    
</t>
<t tx="karstenw.20240123172853.21">def push(self):
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.22">class LinearGradient(Filter):
    
    @others
</t>
<t tx="karstenw.20240123172853.23">def __init__(self, texture, clr1=vec4(0,0,0,1), clr2=vec4(1,1,1,1)):
    self.shader  = _gradient[LINEAR]
    self.texture = texture
    self.clr1    = clr1
    self.clr2    = clr2
    
</t>
<t tx="karstenw.20240123172853.24">def push(self):
    self.shader.set("clr1", self.clr1)
    self.shader.set("clr2", self.clr2)
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.25">class RadialGradient(Filter):
    
    @others
#--- COLORIZE ---------------------------------------------------------------------------------------

_colorize = shader(fragment='''
uniform sampler2D src;
uniform vec4 color;
uniform vec4 bias;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    gl_FragColor = clamp(p * color + bias, 0.0, 1.0);
}''')

</t>
<t tx="karstenw.20240123172853.26">def __init__(self, texture, clr1=vec4(0,0,0,1), clr2=vec4(1,1,1,1)):
    self.shader  = _gradient[RADIAL]
    self.texture = texture
    self.clr1    = clr1
    self.clr2    = clr2
    
</t>
<t tx="karstenw.20240123172853.27">def push(self):
    self.shader.set("clr1", self.clr1)
    self.shader.set("clr2", self.clr2)
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.28">class Colorize(Filter):
    
    @others
#--- COLORSPACE -------------------------------------------------------------------------------------
# Helper functions for conversion between RGB and HSB that we can use in other filters.
# Based on "Photoshop math with GLSL shaders" (2009), Romain Dura,
# http://blog.mouaif.org/?p=94

glsl_hsb2rgb = '''
float _hue2rgb(float a, float b, float hue) {
    hue = mod(hue, 1.0);
    if (6.0 * hue &lt; 1.0) return a + (b - a) * 6.0 * hue;
    if (2.0 * hue &lt; 1.0) return b;
    if (3.0 * hue &lt; 2.0) return a + (b - a) * 6.0 * (2.0/3.0 - hue);
    return a;
}
vec3 hsb2rgb(vec3 hsb) {
    if (hsb.y == 0.0) return vec3(hsb.z);
    float b = (hsb.z &lt; 0.5)? hsb.z * (1.0 + hsb.y) : (hsb.y + hsb.z) - (hsb.y * hsb.z);
    float a = 2.0 * hsb.z - b;
    return vec3(
        _hue2rgb(a, b, hsb.x + (1.0/3.0)),
        _hue2rgb(a, b, hsb.x),
        _hue2rgb(a, b, hsb.x - (1.0/3.0))
        );
}'''

glsl_rgb2hsb = '''
vec3 rgb2hsb(vec3 rgb) {
    vec3 hsb = vec3(0.0);
    float a = min(min(rgb.r, rgb.g), rgb.b);
    float b = max(max(rgb.r, rgb.g), rgb.b);
    float c = b - a;
    if (c != 0.0) {
        vec3 d = ((vec3(b) - rgb) / 6.0 + c / 2.0) / c;
             if (rgb.r == b) hsb.x = d.b - d.g;
        else if (rgb.g == b) hsb.x = d.r - d.b + 1.0/3.0;
        else if (rgb.b == b) hsb.x = d.g - d.r + 2.0/3.0;
        hsb.x = mod(hsb.x, 1.0);
        hsb.y = (hsb.z &lt; 0.5)? c / (a+b) : c / (2.0 - c);
    }
    hsb.z = (a+b) / 2.0;
    return hsb;
}''';

#--- ADJUSTMENTS ------------------------------------------------------------------------------------

BRIGHTNESS = "brightness"
CONTRAST   = "contrast"
SATURATION = "saturation"
HUE        = "hue"

_adjustment = {}
_adjustment[BRIGHTNESS] = shader(fragment='''
uniform sampler2D src;
uniform float m;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    gl_FragColor = vec4(clamp(p.rgb + m, 0.0, 1.0), p.a);
}''')
_adjustment[CONTRAST] = shader(fragment='''
uniform sampler2D src;
uniform float m;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    gl_FragColor = vec4(clamp((p.rgb - 0.5) * m + 0.5, 0.0, 1.0), p.a);
}''')
_adjustment[SATURATION] = shader(fragment='''
uniform sampler2D src;
uniform float m;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    float i = 0.3 * p.r + 0.59 * p.g + 0.11 * p.b;
    gl_FragColor = vec4(
        i * (1.0 - m) + p.r * m,
        i * (1.0 - m) + p.g * m,
        i * (1.0 - m) + p.b * m,
        p.a
    );
}''')
_adjustment[HUE] = shader(fragment=glsl_hsb2rgb+glsl_rgb2hsb+'''
uniform sampler2D src;
uniform float m;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    vec3 hsb = rgb2hsb(p.rgb);
    hsb.x = hsb.x + m;
    gl_FragColor = vec4(hsb2rgb(hsb).xyz, p.a);
}''') 

</t>
<t tx="karstenw.20240123172853.29">def __init__(self, texture, color=vec4(1,1,1,1), bias=vec4(0,0,0,0)):
    self.shader  = _colorize
    self.texture = texture
    self.color   = color
    self.bias    = bias
    
</t>
<t tx="karstenw.20240123172853.3">@property
def active(self):
    return self._active
    
</t>
<t tx="karstenw.20240123172853.30">def push(self):
    self.shader.set("color", self.color)
    self.shader.set("bias",  self.bias)
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.31">class BrightnessAdjustment(Filter):
    
    @others
</t>
<t tx="karstenw.20240123172853.32">def __init__(self, texture, m=1.0):
    self.shader  = _adjustment[BRIGHTNESS]
    self.texture = texture
    self.m       = m
    
</t>
<t tx="karstenw.20240123172853.33">def push(self):
    self.shader.set("m", float(self.m-1))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.34">class ContrastAdjustment(Filter):
    
    @others
</t>
<t tx="karstenw.20240123172853.35">def __init__(self, texture, m=1.0):
    self.shader  = _adjustment[CONTRAST]
    self.texture = texture
    self.m       = m
    
</t>
<t tx="karstenw.20240123172853.36">def push(self):
    self.shader.set("m", float(self.m))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.37">class SaturationAdjustment(Filter):
    
    @others
</t>
<t tx="karstenw.20240123172853.38">def __init__(self, texture, m=1.0):
    self.shader  = _adjustment[SATURATION]
    self.texture = texture
    self.m       = m
    
</t>
<t tx="karstenw.20240123172853.39">def push(self):
    self.shader.set("m", float(max(self.m, 0)))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.4">@property
def source(self):
    return (self._vertex, self._fragment)

</t>
<t tx="karstenw.20240123172853.40">class HueAdjustment(Filter):
    
    @others
#--- BRIGHTPASS --------------------------------------------------------------------------------------
# Note: the magic numbers 0.2125, 0.7154, 0.0721 represent how (in RGB) 
# green contributes the most to luminosity while blue hardly contributes anything.
# Thus, luminance L = R*0.2125 + G*0.7154 + B+0.0721

_brightpass = shader(fragment='''
uniform sampler2D src;
uniform float threshold;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    float L = dot(p.rgb, vec3(0.2125, 0.7154, 0.0721)); // luminance
    gl_FragColor = (L &gt; threshold)? vec4(p.rgb, p.a) : vec4(0.0, 0.0, 0.0, p.a);
}''')

</t>
<t tx="karstenw.20240123172853.41">def __init__(self, texture, m=0.0):
    self.shader  = _adjustment[HUE]
    self.texture = texture
    self.m       = m
    
</t>
<t tx="karstenw.20240123172853.42">def push(self):
    self.shader.set("m", float(self.m));
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.43">class BrightPass(Filter):
    
    @others
#--- BLUR --------------------------------------------------------------------------------------------
# Based on "Gaussian Blur Filter Shader" (2008), 
# http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
# Blurring occurs in two steps (requiring an FBO): horizontal blur and vertical blur.
# Separating these two steps reduces the problem to linear complexity (i.e. it is faster).

glsl_blur = '''
uniform sampler2D src;
uniform int kernel;
uniform float radius;
uniform vec2 extent;
void main() {
    vec2 v = gl_TexCoord[0].xy;
    vec4 p = vec4(0.0);
    float n = float(kernel * kernel);
    if (v.x &lt;= extent.x &amp;&amp; v.y &lt;= extent.y) {
        for (int i=1; i&lt;kernel; i++) {
            float a = float(i) * radius;
            float b = float(kernel - i) / n;
            p += texture2D(src, vec2(v.x%s, v.y%s)) * b;
            p += texture2D(src, vec2(v.x%s, v.y%s)) * b;
        }
        p += texture2D(src, vec2(v.x, v.y)) * float(kernel) / n;
    }
    gl_FragColor = p;
}'''
_blur = {
    "horizontal": shader(fragment=glsl_blur % ("-a","","+a","")), # vary v.x
    "vertical"  : shader(fragment=glsl_blur % ("","-a","","+a"))  # vary v.y
}

</t>
<t tx="karstenw.20240123172853.44">def __init__(self, texture, threshold=0.5):
    self.shader    = _brightpass
    self.texture   = texture
    self.threshold = threshold
    
</t>
<t tx="karstenw.20240123172853.45">def push(self):
    self.shader.set("threshold", float(self.threshold));
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.46">class HorizontalBlur(Filter):
    
    @others
</t>
<t tx="karstenw.20240123172853.47">def __init__(self, texture, kernel=9, scale=1.0):
    self.shader  = _blur["horizontal"]
    self.texture = texture
    self.kernel  = kernel
    self.scale   = scale
    
</t>
<t tx="karstenw.20240123172853.48">def push(self):
    self.shader.set("kernel", int(self.kernel));
    self.shader.set("radius", float(self.scale) / self.texture.width)
    self.shader.set("extent", vec2(*extent2(self.texture)))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.49">class VerticalBlur(Filter):
    
    @others
# It is useful to have a blur in a single pass as well,
# which we can use as a parameter for the image() command.
# However, for a simple 3x3 in separate steps =&gt; 6 calculations, single pass =&gt; 9 calculations.
_blur["gaussian3x3"] = shader(fragment='''
uniform sampler2D src;
uniform vec2 radius;
void main() {
    float dx = radius.x;
    float dy = radius.y;
    vec2 v = gl_TexCoord[0].xy;
    vec4 p = vec4(0.0);
    p  = 4.0 * texture2D(src, v);
    p += 2.0 * texture2D(src, v + vec2(+dx, 0.0));
    p += 2.0 * texture2D(src, v + vec2(-dx, 0.0));
    p += 2.0 * texture2D(src, v + vec2(0.0, +dy));
    p += 2.0 * texture2D(src, v + vec2(0.0, -dy));
    p += 1.0 * texture2D(src, v + vec2(+dx, +dy));
    p += 1.0 * texture2D(src, v + vec2(-dx, +dy));
    p += 1.0 * texture2D(src, v + vec2(-dx, -dy));
    p += 1.0 * texture2D(src, v + vec2(+dx, -dy));
    gl_FragColor = p / 16.0;
}''')

</t>
<t tx="karstenw.20240123172853.5">def __del__(self):
    try:
        for shader in self._compiled:
            if glDetachShader and self._program:
                glDetachShader(self._program, shader)
            if glDeleteShader: 
                glDeleteShader(shader)
        if glDeleteProgram: 
            glDeleteProgram(self._program)
    except:
        pass

</t>
<t tx="karstenw.20240123172853.50">def __init__(self, texture, kernel=9, scale=1.0):
    self.shader  = _blur["vertical"]
    self.texture = texture
    self.kernel  = kernel
    self.scale   = scale
    
</t>
<t tx="karstenw.20240123172853.51">def push(self):
    self.shader.set("kernel", int(self.kernel));
    self.shader.set("radius", float(self.scale) / self.texture.height)
    self.shader.set("extent", vec2(*extent2(self.texture)))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.52">class Gaussian3x3Blur(Filter):
    
    @others
#--- COMPOSITING -------------------------------------------------------------------------------------

# Compositing function.
# It will be reused in alpha compositing and blending filters below.
# It prepares pixels p1 and p2, which need to be mixed into vec4 p.
glsl_compositing = '''
uniform sampler2D src1;
uniform sampler2D src2;
uniform vec2 extent;
uniform vec2 offset;
uniform vec2 ratio;
uniform float alpha;
void main() {
    vec2 v1 = gl_TexCoord[0].xy;
    vec2 v2 = v1 * ratio - offset * extent;
    vec4 p1 = texture2D(src1, v1.xy);
    vec4 p2 = texture2D(src2, v2.xy);
    if (v2.x &lt; 0.0 || 
        v2.y &lt; 0.0 || 
        v2.x &gt; extent.x + 0.001 || 
        v2.y &gt; extent.y + 0.001) { 
        gl_FragColor = p1; 
        return; 
    }
    vec4 p  = vec4(0.0);
    %s
    gl_FragColor = p; 
}'''

</t>
<t tx="karstenw.20240123172853.53">def __init__(self, texture, scale=1.0):
    self.shader = _blur["gaussian3x3"]
    self.texture = texture
    self.scale = scale
    
</t>
<t tx="karstenw.20240123172853.54">def push(self):
    x = float(self.scale) / self.texture.width
    y = float(self.scale) / self.texture.height
    self.shader.set("radius", vec2(x, y))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.55">class Compositing(Filter):
    
    @others
#--- ALPHA TRANSPARENCY ------------------------------------------------------------------------------

_alpha = {}
_alpha["transparency"] = shader(fragment='''
uniform sampler2D src;
uniform float alpha;
void main() {
    vec4 p = texture2D(src, gl_TexCoord[0].xy);
    gl_FragColor = vec4(p.rgb, p.a * alpha);
}''')
_alpha["mask"] = shader(fragment=glsl_compositing % '''
    p = vec4(p1.rgb, p1.a * (p2.r * p2.a * alpha));
'''.strip())

</t>
<t tx="karstenw.20240123172853.56">def __init__(self, shader, texture, blend, alpha=1.0, dx=0, dy=0):
    """ A filter that mixes a base image (the destination) with a blend image (the source).
        Used to implement alpha compositing and blend modes.
        - dx: the horizontal offset (in pixels) of the blend layer.
        - dy: the vertical offset (in pixels) of the blend layer.
    """
    self.shader  = shader
    self.texture = texture
    self.blend   = blend
    self.alpha   = alpha   
    self.dx      = dx
    self.dy      = dy 

</t>
<t tx="karstenw.20240123172853.57">def push(self):
    w  = float(self.blend.width)
    h  = float(self.blend.height)
    w2 = float(ceil2(w))
    h2 = float(ceil2(h))
    dx = float(self.dx) / w
    dy = float(self.dy) / h
    glActiveTexture(GL_TEXTURE0)
    glBindTexture(self.texture.target, self.texture.id)        
    glActiveTexture(GL_TEXTURE1)
    glBindTexture(self.blend.target, self.blend.id)
    glActiveTexture(GL_TEXTURE0)
    self.shader.set("src1", 0)
    self.shader.set("src2", 1)
    self.shader.set("extent", vec2(w/w2, h/h2)) # Blend extent.
    self.shader.set("offset", vec2(dx, dy))     # Blend offset.
    self.shader.set("ratio", vec2(*ratio2(self.texture, self.blend))) # Image-blend proportion.
    self.shader.set("alpha", self.alpha)
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.58">class AlphaTransparency(Filter):

    @others
</t>
<t tx="karstenw.20240123172853.59">def __init__(self, texture, alpha=1.0):
    self.shader  = _alpha["transparency"]
    self.texture = texture
    self.alpha   = alpha
    
</t>
<t tx="karstenw.20240123172853.6">class ShaderFacade:
    @others
SUPPORTED = True # Graphics hardware supports shaders?

</t>
<t tx="karstenw.20240123172853.60">def push(self):
    self.shader.set("alpha", float(max(0, min(1, self.alpha))))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.61">class AlphaMask(Compositing):

    @others
#--- BLEND MODES -------------------------------------------------------------------------------------
# Based on "Photoshop math with GLSL shaders" (2009), Romain Dura,
# http://blog.mouaif.org/?p=94

ADD       = "add"       # Pixels are added.
SUBTRACT  = "subtract"  # Pixels are subtracted.
LIGHTEN   = "lighten"   # Lightest value for each pixel.
DARKEN    = "darken"    # Darkest value for each pixel.
MULTIPLY  = "multiply"  # Pixels are multiplied, resulting in a darker image.
SCREEN    = "screen"    # Pixels are inverted/multiplied/inverted, resulting in a brighter picture.
OVERLAY   = "overlay"   # Combines multiply and screen: light parts become ligher, dark parts darker.
HARDLIGHT = "hardlight" # Same as overlay, but uses the blend instead of base image for luminance.
HUE       = "hue"       # Hue from the blend image, brightness and saturation from the base image.

# If the blend is opaque (alpha=1.0), swap base and blend.
# This way lighten, darken, multiply and screen appear the same as in Photoshop and Core Image.
_blendx = '''if (p2.a == 1.0) { vec4 p3=p1; p1=p2; p2=p3; }
    '''
# Blending operates on RGB values, the A needs to be handled separately.
# Where both images are transparent, their transparency is blended.
# Where the base image is fully transparent, the blend image appears source over.
# There is a subtle transition at transparent edges, which makes the edges less jagged.
glsl_blend = glsl_compositing % '''
    vec3 w  = vec3(1.0); // white
    %s
    p = mix(p1, clamp(p, 0.0, 1.0), p2.a * alpha);
    p = (v1.x * ratio.x &gt; 1.0 || v1.y * ratio.y &gt; 1.0)? p1 : p;
    p = (p1.a &lt; 0.25)? p * p1.a + p2 * (1.0-p1.a) : p;
'''.strip()
_blend = {}
_blend[ADD]      =           'p = vec4(p1.rgb + p2.rgb, 1.0);'
_blend[SUBTRACT] =           'p = vec4(p1.rgb + p2.rgb - 1.0, 1.0);'
_blend[LIGHTEN]  = _blendx + 'p = vec4(max(p1.rgb, p2.rgb), 1.0);'
_blend[DARKEN]   = _blendx + 'p = vec4(min(p1.rgb, p2.rgb), 1.0);'
_blend[MULTIPLY] = _blendx + 'p = vec4(p1.rgb * p2.rgb, 1.0);'
_blend[SCREEN]   = _blendx + 'p = vec4(w - (w - p1.rgb) * (w - p2.rgb), 1.0);'
_blend[OVERLAY]  = '''
    float L = dot(p1.rgb, vec3(0.2125, 0.7154, 0.0721)); // luminance
    vec4 a = vec4(2.0 * p1.rgb * p2.rgb, 1.0);
    vec4 b = vec4(w - 2.0 * (w - p1.rgb) * (w - p2.rgb), 1.0);
    p = (L &lt; 0.45)? a : (L &gt; 0.55)? b : vec4(mix(a.rgb, b.rgb, (L - 0.45) * 10.0), 1.0);
'''
_blend[HARDLIGHT] = _blend[OVERLAY].replace("dot(p1", "dot(p2")
_blend[HUE] = '''
    vec3 h1 = rgb2hsb(p1.rgb);
    vec3 h2 = rgb2hsb(p2.rgb);
    p = vec4(hsb2rgb(vec3(h2.x, h1.yz)).rgb, p1.a);
'''

for f in _blend.keys():
    src = glsl_blend % _blend[f].strip()
    src = f==HUE and glsl_rgb2hsb + glsl_hsb2rgb + src or src # Hue blend requires rgb2hsb() function.
    _blend[f] = shader(fragment=src)

</t>
<t tx="karstenw.20240123172853.62">def __init__(self, texture, blend, alpha=1.0, dx=0, dy=0):
    Compositing.__init__(self, _alpha["mask"], texture, blend, alpha, dx, dy)
    self.shader = _alpha["mask"]

</t>
<t tx="karstenw.20240123172853.63">class Blend(Compositing):
    
    @others
#--- DISTORTION --------------------------------------------------------------------------------------
# Based on "PhotoBooth Demystified" (2007), Libero Spagnolini, 
# http://dem.ocracy.org/libero/photobooth/

PINCH   = "pinch"  # Radius grows faster near the center of the effect.
TWIRL   = "twirl"  # Decreasing offset is added to the angle while moving down the radius.
SPLASH  = "splash" # Light-tunnel effect by capping the radius.
BUMP    = "bump"   # Radius grows slower near the center of the effect.
DENT    = "dent"
FISHEYE = "fisheye"
STRETCH = "stretch"
MIRROR  = "mirror"

# Distortion function.
# - vec2 offset: horizontal and vertical offset from the image center (-0.5 to +0.5).
# - vec2 extent: the actual size of the image (0.0-1.0) in the texture.
#   Textures have a size power of 2 (512, 1024, ...) but the actual image may be smaller.
#   We need to know the extent of the image in the texture to calculate its center.
# - float ratio: the ratio between width and height, so the effect doesn't get stretched.
# - float m: the magnitude of the effect (e.g. radius, ...) 
# - float i: the intensity of the effect (e.g. number of rotations, ...) 
# - vec2 n: a normalized texture space between -1.0 and 1.0 (instead of 0.0-1.0).
glsl_distortion = '''
uniform sampler2D src;
uniform vec2 offset;
uniform vec2 extent;
uniform float ratio;
uniform float m;
uniform float i;
void main() {
    vec2 v = gl_TexCoord[0].xy;
    vec2 d = extent + extent * offset;
    vec2 n = 2.0 * v - 1.0 * d;
    n.x *= ratio;
    %s
    n.x /= ratio;
    v = n / 2.0 + 0.5 * d;
    %s
    gl_FragColor = p; 
}'''
# Polar coordinates.
# Most of the effects are based on simple angle and radius transformations.
# After the transformations, convert back to cartesian coordinates n.
glsl_polar = '''
    float r = length(n);
    float phi = atan(n.y, n.x);
    %s
    n = vec2(r*cos(phi), r*sin(phi));
'''.strip()
# For most effects, pixels are not wrapped around the edges.
# The second version wraps, with respect to the extent of the actual image in its power-of-2 texture.
# The third version wraps with a flipped image (transition).
glsl_wrap = (
    '''vec4 p = (v.x &lt; 0.0 || v.y &lt; 0.0 || v.x &gt; 0.999 || v.y &gt; 0.999)? vec4(0.0) : texture2D(src, v);''',
    '''
    v.x = (v.x &gt;= extent.x - 0.001)? mod(v.x, extent.x) - 0.002 : max(v.x, 0.001);
    v.y = (v.y &gt;= extent.y - 0.001)? mod(v.x, extent.x) - 0.002 : max(v.y, 0.001);
    vec4 p = texture2D(src, v);'''.strip(),
    '''
    v.x = (v.x &gt;= extent.x - 0.001)? (extent.x - (v.x-extent.x)) - 0.002 : max(v.x, 0.001);
    v.y = (v.y &gt;= extent.y - 0.001)? (extent.y - (v.y-extent.y)) - 0.002 : max(v.y, 0.001);
    vec4 p = texture2D(src, v);'''.strip())

_distortion = {}
_distortion[BUMP]    = 'r = r * smoothstep(i, m, r);'
_distortion[DENT]    = 'r = 2.0 * r - r * smoothstep(0.0, m, r/i);'
_distortion[PINCH]   = 'r = pow(r, m/i) * m;'
_distortion[FISHEYE] = 'r = r * r / sqrt(2.0);'
_distortion[SPLASH]  = 'if (r &gt; m) r = m;'
_distortion[TWIRL]   = 'phi = phi + (1.0 - smoothstep(-m, m, r)) * i;'
_distortion[MIRROR]  = '''
    if (m &gt; 0.0) { n.x += offset.x * extent.x * ratio; n.x = n.x * sign(n.x); }
    if (i &gt; 0.0) { n.y += offset.y * extent.y;         n.y = n.y * sign(n.y); }
'''.strip()
_distortion[STRETCH] = '''
    vec2 s = sign(n);
    n = abs(n);
    n = (1.0-i) * n + i * smoothstep(m*0.25, m, n) * n;
    n = s * n;
'''.strip()

for f in (BUMP, DENT, PINCH, FISHEYE, SPLASH, TWIRL):
    _distortion[f] = shader(fragment=glsl_distortion % (glsl_polar % _distortion[f], glsl_wrap[0]))
for f in (STRETCH, MIRROR):
    _distortion[f] = shader(fragment=glsl_distortion % (             _distortion[f], glsl_wrap[2]))

</t>
<t tx="karstenw.20240123172853.64">def __init__(self, mode, texture, blend, alpha=1.0, dx=0, dy=0):
    Compositing.__init__(self, _blend[mode], texture, blend, alpha, dx, dy)

</t>
<t tx="karstenw.20240123172853.65">class Distortion(Filter):
    
    @others
#=====================================================================================================

#--- FRAME BUFFER OBJECT -----------------------------------------------------------------------------
# Based on "Frame Buffer Object 101" (2006), Rob Jones, 
# http://www.gamedev.net/reference/articles/article2331.asp

_UID = 0
</t>
<t tx="karstenw.20240123172853.66">def __init__(self, effect, texture, dx=0, dy=0, m=1.0, i=1.0):
    """ Distortion filter with dx, dy offset from the center (between -0.5 and 0.5),
        magnitude m as the radius of effect, intensity i as the depth of the effect.
    """
    self.shader  = _distortion[effect]
    self.texture = texture
    self.dx      = dx
    self.dy      = dy
    self.m       = m
    self.i       = i

# Center offset can also be set in absolute coordinates (e.g. pixels):
</t>
<t tx="karstenw.20240123172853.67">def _get_abs_dx(self): 
    return int(self.dx * self.texture.width)
</t>
<t tx="karstenw.20240123172853.68">def _get_abs_dy(self): 
    return int(self.dy * self.texture.height)
</t>
<t tx="karstenw.20240123172853.69">def _set_abs_dx(self, v): 
    self.dx = float(v) / self.texture.width
</t>
<t tx="karstenw.20240123172853.7">def __init__(self, vertex=None, fragment=None):
    # Acts like a shader but doesn't do anything.
    pass
</t>
<t tx="karstenw.20240123172853.70">def _set_abs_dy(self, v): 
    self.dy = float(v) / self.texture.height
    
abs_dx = property(_get_abs_dx, _set_abs_dx)
abs_dy = property(_get_abs_dy, _set_abs_dy)

</t>
<t tx="karstenw.20240123172853.71">def push(self):
    w  = float(self.texture.width)
    h  = float(self.texture.height)
    w2 = float(ceil2(w))
    h2 = float(ceil2(h))
    self.shader.set("extent", vec2(w/w2, h/h2))
    self.shader.set("offset", vec2(float(2*self.dx), float(2*self.dy)))
    self.shader.set("ratio", w2/h2)
    self.shader.set("m", float(self.m))
    self.shader.set("i", float(self.i))
    self.shader.push()

</t>
<t tx="karstenw.20240123172853.72">def _uid():
    # Each FBO has a unique ID.
    global _UID; _UID+=1; return _UID;
    
</t>
<t tx="karstenw.20240123172853.73">def _texture(width, height):
    # Returns an empty texture of the given width and height.
    return Texture.create(width, height)

</t>
<t tx="karstenw.20240123172853.74">def glCurrentViewport(x=None, y=None, width=None, height=None):
    """ Returns a (x, y, width, height)-tuple with the current viewport bounds.
        If x, y, width and height are given, set the viewport bounds.
    """
    # Why? To switch between the size of the onscreen canvas and the offscreen buffer.
    # The canvas could be 256x256 while an offscreen buffer could be 1024x1024.
    # Without switching the viewport, information from the buffer would be lost.
    if x is not None and y is not None and width is not None and height is not None:
        glViewport(x, y, width, height)
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glOrtho(x, width, y, height, -1, 1)
        glMatrixMode(GL_MODELVIEW)
    xywh = (GLint*4)(); glGetIntegerv(GL_VIEWPORT, xywh)
    return tuple(xywh)

# The FBO stack keeps track of nested FBO's.
# When OffscreenBuffer.pop() is called, we revert to the previous buffer.
# Usually, this is the onscreen canvas, but in a render() function that contains
# filters or nested render() calls, this is the previous FBO.
_FBO_STACK = []

</t>
<t tx="karstenw.20240123172853.75">class OffscreenBufferError(Exception):
    pass

</t>
<t tx="karstenw.20240123172853.76">class OffscreenBuffer(object):
    
    @others
FBO = OffscreenBuffer

#=====================================================================================================

#--- OFFSCREEN RENDERING -----------------------------------------------------------------------------
# Uses an offscreen buffer to render filters and drawing commands to images.

try: 
    _buffer = OffscreenBuffer(640, 480)
except OffscreenBufferError:
    _buffer = None

</t>
<t tx="karstenw.20240123172853.77">def __init__(self, width, height):
    """ "FBO" is an OpenGL extension to do "Render to Texture", drawing in an offscreen buffer.
        It is useful as a place to chain multiple shaders,
        since each shader has its own program and we can only install one program at a time.
    """
    self.id = c_uint(_uid())
    try: glGenFramebuffersEXT(1, byref(self.id))
    except:
        raise OffscreenBufferError( "offscreen buffer not supported."  )
    self.texture   = None
    self._viewport = (None, None, None, None) # The canvas bounds, set in OffscreenBuffer.push().
    self._active   = False
    self._init(width, height)
    #self._init_depthbuffer()
    
</t>
<t tx="karstenw.20240123172853.78">def _init(self, width, height):
    self.texture = _texture(int(width), int(height))  

</t>
<t tx="karstenw.20240123172853.79">@property
def width(self):
    return self.texture.width

</t>
<t tx="karstenw.20240123172853.8">@property
def variables(self):
    return {}
</t>
<t tx="karstenw.20240123172853.80">@property
def height(self):
    return self.texture.height

</t>
<t tx="karstenw.20240123172853.81">@property
def active(self):
    return self._active

</t>
<t tx="karstenw.20240123172853.82">def push(self):
    """ Between push() and pop(), all drawing is done offscreen in OffscreenBuffer.texture.
        The offscreen buffer has its own transformation state,
        so any translate(), rotate() etc. does not affect the onscreen canvas.
    """
    _FBO_STACK.append(self)
    glBindTexture(self.texture.target, self.texture.id)
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, self.id.value)      
    glFramebufferTexture2DEXT(
        GL_FRAMEBUFFER_EXT, 
        GL_COLOR_ATTACHMENT0_EXT, 
        self.texture.target, 
        self.texture.id, 
        self.texture.level
    )
    # FBO's can fail when not supported by the graphics hardware,
    # or when supplied an image of size 0 or unequal width/height.
    # Check after glBindFramebufferEXT() and glFramebufferTexture2DEXT().
    if glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT) != GL_FRAMEBUFFER_COMPLETE_EXT:
        msg = self.texture.width == self.texture.height == 0 and "width=0, height=0." or ""
        raise OffscreenBufferError( msg )
    # Separate the offscreen from the onscreen transform state.
    # Separate the offscreen from the onscreen canvas size.
    self._viewport = glCurrentViewport()
    glPushMatrix()
    glLoadIdentity()
    glCurrentViewport(0, 0, self.texture.width, self.texture.height)
    glColor4f(1.0,1.0,1.0,1.0)
    # FBO's work with a simple GL_LINE_SMOOTH anti-aliasing.
    # The instructions on how to enable framebuffer multisampling are pretty clear:
    # (http://www.opengl.org/wiki/GL_EXT_framebuffer_multisample)
    # but glRenderbufferStorageMultisampleEXT doesn't appear to work (yet),
    # plus there is a performance drop.
    glEnable(GL_LINE_SMOOTH)
    # Blending transparent images in a transparent FBO is a bit tricky
    # because alpha is premultiplied, an image with 50% transparency
    # will come out 25% transparency with glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA).
    # http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&amp;Number=257630
    # http://www.openframeworks.cc/forum/viewtopic.php?f=9&amp;t=2215
    # This blend mode gives better results:
    glEnable(GL_BLEND)
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    self._active = True

</t>
<t tx="karstenw.20240123172853.83">def pop(self):
    """ Reverts to the onscreen canvas. 
        The contents of the offscreen buffer can be retrieved with OffscreenBuffer.texture.
    """
    # Switch to onscreen canvas size and transformation state.
    # Switch to onscreen canvas.
    # Reset to the normal blending mode.
    _FBO_STACK.pop(-1)
    glCurrentViewport(*self._viewport)
    glPopMatrix()
    glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, _FBO_STACK and _FBO_STACK[-1].id or 0)
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    #glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
    self._active = False

</t>
<t tx="karstenw.20240123172853.84">def render(self):
    """ Executes the drawing commands in OffscreenBuffer.draw() offscreen and returns image.
        This is useful if you have a class that inherits from FBO with a draw() method.
    """
    self.push()
    self.draw()
    self.pop()
    return self.texture
    
</t>
<t tx="karstenw.20240123172853.85">def draw(self):
    pass
    
</t>
<t tx="karstenw.20240123172853.86">def slice(self, x, y, width, height):
    """ Returns a portion of the offscreen buffer as an image.
    """
    return self.texture.get_region(x, y, width, height) 

</t>
<t tx="karstenw.20240123172853.87">def reset(self, width=None, height=None):
    """ Resizes the offscreen buffer by attaching a new texture to it.
        This will destroy the contents of the previous buffer.
        If you do not explicitly reset the buffer, the contents from previous drawing
        between OffscreenBuffer.push() and OffscreenBuffer.pop() is retained.
    """
    if self._active:
        raise OffscreenBufferError( "can't reset offscreen buffer when active" )
    if width is None:
        width = self.width
    if height is None:
        height = self.height
    self._init(width, height)
    
</t>
<t tx="karstenw.20240123172853.88">def clear(self):
    glClear(GL_COLOR_BUFFER_BIT)
    glClear(GL_DEPTH_BUFFER_BIT)
    glClear(GL_STENCIL_BUFFER_BIT)

</t>
<t tx="karstenw.20240123172853.89">def _init_depthbuffer(self):
    self._depthbuffer = c_uint(_uid())
    glGenRenderbuffersEXT(1, byref(self._depthbuffer))
    glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, self._depthbuffer)
    glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT, self.width, self.height)
    glFramebufferRenderbufferEXT(
        GL_FRAMEBUFFER_EXT,
        GL_DEPTH_ATTACHMENT_EXT,
        GL_RENDERBUFFER_EXT,
        self._depthbuffer
    )

</t>
<t tx="karstenw.20240123172853.9">@property
def active(self):
    return None
</t>
<t tx="karstenw.20240123172853.90">def __del__(self):
    try:
        if glDeleteFramebuffersEXT:
            glDeleteFramebuffersEXT(1, self.id)
        if glDeleteRenderbuffersEXT and hasattr(self, "_depthbuffer"):
            glDeleteRenderbuffersEXT(1, self._depthbuffer)
    except:
        pass

</t>
<t tx="karstenw.20240123172853.91">def filter(img, filter=None, clear=True):
    """ Returns a new Image object with the given filter applied to it.
        - img   : an image that can be passed to the image() command.
        - filter: an instance of the Filter class, with parameters set.
        - clear : if True, clears the contents of the offscreen buffer and resizes it to the image.
    """
    # For file paths, textures and Pixel objects, create an Image first.
    if not isinstance(img, Image):
        img = Image(img)
    # Reuse main _buffer when possible, otherwise create one on the fly
    # (this will be necessary when filter() or render() is nested inside render()).
    if not _buffer or _buffer.active:
        buffer = OffscreenBuffer(img.texture.width, img.texture.height)
    elif clear:
        buffer = _buffer
        buffer.reset(img.texture.width, img.texture.height)
    else:
        buffer = _buffer
    buffer.push()
    if filter != None:
        filter.texture = img.texture # Register the current texture with the filter.
        filter.push()
    # This blend mode gives better results for transparent images:
    glBlendFuncSeparate(GL_ONE, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    # Note: Image.alpha and Image.color attributes won't work here,
    # because the shader overrides the default drawing behavior.
    # Instead, add the transparent() and colorize() filters to the chain.
    img.draw(0, 0, img.texture.width, img.texture.height)
    if filter != None:
        filter.pop()
    buffer.pop()
    return img.copy(texture=buffer.texture)

</t>
<t tx="karstenw.20240123172853.92">class RenderedImage(Image):
    
    @others
</t>
<t tx="karstenw.20240123172853.93">def draw(self, *args, **kwargs):
    # Textures rendered in the FBO look slightly washed out.
    # The render() command yields a RenderedImage object,
    # which draw() method uses a blending trick to correct the colors:
    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA)
    Image.draw(self, *args, **kwargs)
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ONE_MINUS_SRC_ALPHA)

</t>
<t tx="karstenw.20240123172853.94">def save(self, path):
    # XXX Colors will appear washed out in the exported image.
    Image.save(self, path)

</t>
<t tx="karstenw.20240123172853.95">def render(function, width, height, clear=True, **kwargs):
    """ Returns an Image object from a function containing drawing commands (i.e. a procedural image).
        This is useful when, for example, you need to render filters on paths.
        - function: a function containing drawing commands.
        - width   : width of the offscreen canvas.
        - height  : height of the offscreen canvas.
        - clear   : when False, retains the contents of the offscreen canvas, without resizing it.
    """
    # Reuse main _buffer when possible, otherwise create one on the fly
    # (this will be necessary when render() is nested inside another render()).
    if not _buffer or _buffer.active:
        buffer = OffscreenBuffer(width, height)
    elif clear:
        buffer = _buffer
        buffer.reset(width, height)
    else:
        buffer = _buffer
    buffer.push()
    function(**kwargs)
    buffer.pop()
    return RenderedImage(buffer.texture)
    
#--- OFFSCREEN FILTERS -------------------------------------------------------------------------------
# Images are rendered offscreen with the filter applied, and the new image returned.

</t>
<t tx="karstenw.20240123172853.96">def invert(img):
    """ Returns an image with inverted colors (e.g. white becomes black).
    """
    return filter(img, Invert(img.texture))

</t>
<t tx="karstenw.20240123172853.97">def solid(width, height, fill=(0,0,0,0)):
    """ Generates an image filled with a solid color.
    """
    clr = tuple([int(v*255) for v in fill])
    return Image(SolidColorImagePattern(clr).create_image(width, height).get_texture())

</t>
<t tx="karstenw.20240123172853.98">def gradient(width, height, clr1=(0,0,0,1), clr2=(1,1,1,1), type=LINEAR):
    """ Generates a gradient image and returns it.
        - width : the width of the image.
        - height: the height of the image.
        - clr1  : a Color (or a tuple) that defines the bottom (or inner) color.
        - clr2  : a Color (or a tuple) that defines the top (or outer) color.
        - type  : either LINEAR or RADIAL.
    """
    f = type==LINEAR and LinearGradient or RadialGradient
    img = Image(_texture(ceil2(width), ceil2(height)))
    img = filter(img, f(img.texture, vec4(*clr1), vec4(*clr2)))
    # Reuse main _buffer when possible, otherwise create one on the fly
    # (this will be necessary when filter() or render() is nested inside render()).
    if not _buffer or _buffer.active:
        buffer = OffscreenBuffer(img.texture.width, img.texture.height)
    else:
        buffer = _buffer
    # If the given dimensions are not power of 2,
    # scale down the gradient to the given dimensions.
    if width != img.width or height != img.height:
        buffer.reset(width, height)
        buffer.push()
        img.width  = width
        img.height = height
        img.draw()
        buffer.pop()
        return img.copy(texture=buffer.texture)
    return img

</t>
<t tx="karstenw.20240123172853.99">def colorize(img, color=(1,1,1,1), bias=(0,0,0,0)):
    """ Applies a colorize filter to the image and returns the colorized image.
        - color: a Color (or a tuple) of RGBA-values to multiply with each image pixel.
        - bias : a Color (or a tuple) of RGBA-values to add to each image pixel.
    """
    return filter(img, Colorize(img.texture, vec4(*color), vec4(*bias)))

</t>
<t tx="karstenw.20240123172908.1">from math     import sqrt, pow
from math     import sin, cos, atan2, degrees, radians, pi
from random   import random
from heapq    import heappush, heappop
from warnings import warn

import pdb

try:
    basestring
except NameError:
    basestring = str

# float("inf") doesn't work on windows.
INFINITE = 1e20

# This module is standalone, line(), ellipse() and Text.draw() 
# must be either implemented or patched:
</t>
<t tx="karstenw.20240123172908.10">def copy(self):
    return Vector(self.x, self.y, self.z)
    
</t>
<t tx="karstenw.20240123172908.100">def append(self, force):
    self.insert(len(self), force)
</t>
<t tx="karstenw.20240123172908.101">def extend(self, forces):
    for f in forces: self.append(f)

</t>
<t tx="karstenw.20240123172908.102">def pop(self, i):
    f = list.pop(self, i)
    self.system._dynamics.pop(force.particle1._id)
    self.system._dynamics.pop(force.particle2._id)
    return f        
</t>
<t tx="karstenw.20240123172908.103">def remove(self, force):
    i = self.index(force); self.pop(i)

</t>
<t tx="karstenw.20240123172908.104">class System(object):
    
    @others
system = System

# Notes:
# While this system is interesting for many effects, it is unstable.
# If for example very strong springs are applied, particles will start "shaking".
# This is because the forces are simply added to the particle's position instead of integrated.
# See also:
# http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/particle/
# http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/particle/particlelib.c

#def euler_derive(particle, dt=0.1):
#    particle.x += particle.velocity.x * dt
#    particle.y += particle.velocity.y * dt
#    particle.velocity.x += particle.force.x / particle.mass * dt
#    particle.velocity.y += particle.force.y / particle.mass * dt

# If this is applied, springs will need a velocity dampener:
#fx = f + 0.01 + (self.particle2.velocity.x - self.particle1.velocity.x) * dx / d
#fy = f + 0.01 + (self.particle2.velocity.y - self.particle1.velocity.y) * dy / d

# In pure Python this is slow, since only 1/10 of the force is applied each System.update().

#--- EMITTER -----------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172908.105">def __init__(self, gravity=(0,0), drag=0.0):
    """ A collection of particles and the forces working on them.
    """
    self.particles = []
    self.emitters  = []
    self.forces    = flist(self)
    self.springs   = flist(self)
    self.gravity   = isinstance(gravity, tuple) and Vector(*gravity) or gravity
    self.drag      = drag
    self._dynamics = {} # Particle id linked to list of applied forces.

</t>
<t tx="karstenw.20240123172908.106">def __len__(self):
    return len(self.particles)
</t>
<t tx="karstenw.20240123172908.107">def __iter__(self):
    return iter(self.particles)
</t>
<t tx="karstenw.20240123172908.108">def __getitem__(self, i):
    return self.particles[i]

</t>
<t tx="karstenw.20240123172908.109">def extend(self, x):
    for x in x: self.append(x)
</t>
<t tx="karstenw.20240123172908.11">def __getitem__(self, i):
    return (self.x, self.y, self.z)[i]
</t>
<t tx="karstenw.20240123172908.110">def append(self, x):
    if isinstance(x, Particle) and not x in self.particles:
        self.particles.append(x)
    elif isinstance(x, Force):
        self.forces.append(x)
    elif isinstance(x, Spring):
        self.springs.append(x)
    elif isinstance(x, Emitter):
        self.emitters.append(x)
        self.extend(x.particles)
        x.system = self

</t>
<t tx="karstenw.20240123172908.111">def _cross(self, f=lambda particle1, particle2: None, source=None, particles=[]):
    # Applies function f to any two given particles in the list,
    # or between source and any other particle if source is given.
    P = particles or self.particles
    for i, p1 in enumerate(P):
        if source is None: 
            [f(p1, p2) for p2 in P[i+1:]]
        else:
            f(source, p1)

</t>
<t tx="karstenw.20240123172908.112">def force(self, strength=1.0, threshold=100, source=None, particles=[]):
    """ The given force is applied between each two particles.
        The effect this yields (with a repulsive force) is an explosion.
        - source: one vs. all, apply the force to this particle with all others.
        - particles: a list of particles to apply the force to (some vs. some or some vs. source).
        Be aware that 50 particles wield yield 1250 forces: O(n**2/2); or O(n) with source.
        The force is applied to particles present in the system,
        those added later on are not subjected to the force.
    """
    f = lambda p1, p2: self.forces.append(Force(p1, p2, strength, threshold))
    self._cross(f, source, particles)
    
</t>
<t tx="karstenw.20240123172908.113">def dynamics(self, particle, type=None):
    """ Returns a list of forces working on the particle, optionally filtered by type (e.g. Spring).
    """
    F = self._dynamics.get(isinstance(particle, Particle) and particle._id or particle, [])
    F = [f for f in F if type is None or isinstance(f, type)]
    return F
    
</t>
<t tx="karstenw.20240123172908.114">def limit(self, particle, m=None):
    """ Limits the movement of the particle to m.
        When repulsive particles are close to each other, their force can be very high.
        This results in large movement steps, and gaps in the animation.
        This can be remedied by limiting the total force.
    """
    # The right way to do it requires 4x sqrt():
    # if m and particle.force.length &gt; m: 
    #    particle.force.length = m
    # if m and particle.velocity.length &gt; m: 
    #    particle.velocity.length = m
    if m is not None:
        for f in (particle.force, particle.velocity):
            if abs(f.x) &gt; m: 
                f.y *= m / abs(f.x)
                f.x *= m / abs(f.x)
            if abs(f.y) &gt; m: 
                f.x *= m / abs(f.y)
                f.y *= m / abs(f.y)

</t>
<t tx="karstenw.20240123172908.115">def update(self, limit=30):
    """ Updates the location of the particles by applying all the forces.
    """
    for e in self.emitters:
        # Fire particles from emitters.
        e.update()
    for p in self.particles:
        # Apply gravity. Heavier objects have a stronger attraction.
        p.force.x = 0
        p.force.y = 0
        p.force.x += 0.1 *  self.gravity.x * p.mass
        p.force.y += 0.1 * -self.gravity.y * p.mass
    for f in self.forces:
        # Apply attractive and repulsive forces between particles.
        if not f.particle1.dead and \
           not f.particle2.dead:
            f.apply()
    for s in self.springs:
        # Apply spring forces between particles.
        if not s.particle1.dead and \
           not s.particle2.dead and \
           not s.snapped:
            s.apply()
    for p in self.particles:
        if not p.fixed:
            # Apply drag.
            p.velocity.x *= 1.0 - min(1.0, self.drag)
            p.velocity.y *= 1.0 - min(1.0, self.drag)
            # Apply velocity.
            p.force.x += p.velocity.x
            p.force.y += p.velocity.y
            # Limit the accumulated force and update the particle's position.
            self.limit(p, limit)
            p.x += p.force.x
            p.y += p.force.y
        if p.life:
            # Apply lifespan.
            p._age += 1
            p.dead = p._age &gt; p.life

</t>
<t tx="karstenw.20240123172908.116">@property
def dead(self):
    # Yields True when all particles are dead (and we don't need to update anymore).
    for p in self.particles:
        if not p.dead: return False
    return True

</t>
<t tx="karstenw.20240123172908.117">def draw(self, **kwargs):
    """ Draws the system at the current iteration.
    """
    for s in self.springs:
        if not s.particle1.dead and \
           not s.particle2.dead and \
           not s.snapped:
            s.draw(**kwargs)
    for p in self.particles:
        if not p.dead:
            p.draw(**kwargs)

</t>
<t tx="karstenw.20240123172908.118">def __repr__(self):
    return "System(particles=%i, forces=%i, springs=%i)" % \
        (len(self.particles), len(self.forces), len(self.springs))

</t>
<t tx="karstenw.20240123172908.119">class Emitter(object):
    
    @others
emitter = Emitter

#=== GRAPH ===========================================================================================
# Graph visualization is a way of representing information as diagrams of abstract graphs and networks.
# Automatic graph drawing has many important applications in software engineering, 
# database and web design, networking, and in visual interfaces for many other domains.

#--- NODE --------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172908.12">def __setitem__(self, i, v):
    setattr(self, ("x", "y", "z")[i], float(v))
        
</t>
<t tx="karstenw.20240123172908.120">def __init__(self, x, y, angle=0, strength=1.0, spread=10):
    """ A source that shoots particles in a given direction with a given strength.
    """
    self.system    = None   # Set when appended to System.
    self.particles = []
    self.x         = x
    self.y         = y
    self.velocity  = Vector(1, 1, length=strength, angle=angle)
    self.spread    = spread # Angle-of-view.
    self._i        = 0      # Current iteration.

</t>
<t tx="karstenw.20240123172908.121">def __len__(self):
    return len(self.particles)
</t>
<t tx="karstenw.20240123172908.122">def __iter__(self):
    return iter(self.particles)
</t>
<t tx="karstenw.20240123172908.123">def __getitem__(self, i):
    return self.particles[i]

</t>
<t tx="karstenw.20240123172908.124">def extend(self, x, life=100):
    for x in x: self.append(x, life)
</t>
<t tx="karstenw.20240123172908.125">def append(self, particle, life=100):
    particle.life = particle.life or life
    particle._age = particle.life
    particle.dead = True
    self.particles.append(particle)
    if self.system is not None:
        # Also append the particle to the system the emitter is part of.
        self.system.append(particle)

</t>
<t tx="karstenw.20240123172908.126">def _get_angle(self):
    return self.velocity.angle
</t>
<t tx="karstenw.20240123172908.127">def _set_angle(self, v):
    self.velocity.angle = v
    
angle = property(_get_angle, _set_angle)

</t>
<t tx="karstenw.20240123172908.128">def _get_strength(self):
    return self.velocity.length
</t>
<t tx="karstenw.20240123172908.129">def _set_strength(self, v):
    self.velocity.length = max(v, 0.01)
    
strength = length = magnitude = property(_get_strength, _set_strength)
        
</t>
<t tx="karstenw.20240123172908.13">def _get_xyz(self):
    return (self.x, self.y, self.z)

# (x,y,z) in def ???
</t>
<t tx="karstenw.20240123172908.130">def update(self):
    """ Update the system and respawn dead particles.
        When a particle dies, it can be reused as a new particle fired from the emitter.
        This is more efficient than creating a new Particle object.
    """
    self._i += 1 # Respawn occurs gradually.
    p = self.particles[self._i % len(self.particles)]
    if p.dead:
        p.x        = self.x
        p.y        = self.y
        p.velocity = self.velocity.rotated(self.spread * 0.5 * (random()*2-1))
        p._age     = 0
        p.dead     = False

</t>
<t tx="karstenw.20240123172908.131">def deepcopy(o):
    # A color can be represented as a tuple or as a nodeboxgl.graphics.Color object,
    # in which case it needs to be copied by invoking Color.copy().
    if o is None:
        return o
    if hasattr(o, "copy"):
        return o.copy()
    if isinstance(o, (basestring, bool, int, float, long, complex)):
        return o
    if isinstance(o, (list, tuple, set)):
        return o.__class__(deepcopy(v) for v in o)
    if isinstance(o, dict):
        return dict((deepcopy(k), deepcopy(v)) for k,v in o.items())
    raise Exception( "don't know how to copy %s" % (o.__class__.__name__,) )

</t>
<t tx="karstenw.20240123172908.132">class Node(object):
    
    @others
</t>
<t tx="karstenw.20240123172908.133">def __init__(self, id="", radius=5, **kwargs):
    """ A node with a unique id in the graph.
        Node.id is drawn as a text label, unless optional parameter text=False.
        Optional parameters include: fill, stroke, strokewidth, text, font, fontsize, fontweight.
    """
    self.graph       = None
    self.links       = Links()
    self.id          = id
    self._x          = 0.0 # Calculated by Graph.layout.update().
    self._y          = 0.0 # Calculated by Graph.layout.update().
    self.force       = Vector(0.0, 0.0)
    self.radius      = radius
    self.fixed       = kwargs.pop("fixed", False)
    self.fill        = kwargs.pop("fill", None)
    self.stroke      = kwargs.pop("stroke", (0,0,0,1))
    self.strokewidth = kwargs.pop("strokewidth", 1)
    self.text        = kwargs.get("text", True) and \
        Text(isinstance(id, str) and id or str(id).decode("utf-8", "ignore"), 
               width = 85,
                fill = kwargs.pop("text", (0,0,0,1)), 
            fontsize = kwargs.pop("fontsize", 11), **kwargs) or None
    self._weight     = None # Calculated by Graph.eigenvector_centrality().
    self._centrality = None # Calculated by Graph.betweenness_centrality().

</t>
<t tx="karstenw.20240123172908.134">@property
def _distance(self):
    # Graph.distance controls the (x,y) spacing between nodes.
    return self.graph and float(self.graph.distance) or 1.0

</t>
<t tx="karstenw.20240123172908.135">def _get_x(self):
    return self._x * self._distance
</t>
<t tx="karstenw.20240123172908.136">def _get_y(self):
    return self._y * self._distance
</t>
<t tx="karstenw.20240123172908.137">def _set_x(self, v):
    self._x = v / self._distance
</t>
<t tx="karstenw.20240123172908.138">def _set_y(self, v):
    self._y = v / self._distance

x = property(_get_x, _set_x)
y = property(_get_y, _set_y)

</t>
<t tx="karstenw.20240123172908.139">@property
def edges(self):
    """ Yields a list of edges from/to the node.
    """
    return self.graph is not None \
       and [e for e in self.graph.edges if self.id in (e.node1.id, e.node2.id)] \
        or []

</t>
<t tx="karstenw.20240123172908.14">def _set_xyz(self, triplet):
    x,y,z = triplet
    self.x = float(x)
    self.y = float(y)
    self.z = float(z)
xyz = property(_get_xyz, _set_xyz)
    
</t>
<t tx="karstenw.20240123172908.140">@property
def weight(self):
    """ Yields eigenvector centrality as a number between 0.0-1.0.
    """
    if self.graph and self._weight is None:
        self.graph.eigenvector_centrality()
    return self._weight
    
</t>
<t tx="karstenw.20240123172908.141">@property
def centrality(self):
    """ Yields betweenness centrality as a number between 0.0-1.0.
    """
    if self.graph and self._centrality is None:
        self.graph.betweenness_centrality()
    return self._centrality
    
</t>
<t tx="karstenw.20240123172908.142">def flatten(self, depth=1, traversable=lambda node, edge: True, _visited=None):
    """ Recursively lists the node and nodes linked to it.
        Depth 0 returns a list with the node.
        Depth 1 returns a list with the node and all the directly linked nodes.
        Depth 2 includes the linked nodes' links, and so on.
    """
    _visited = _visited or {}
    _visited[self.id] = (self, depth)
    if depth &gt;= 1:
        for n in self.links: 
            if n.id not in _visited or _visited[n.id][1] &lt; depth-1:
                if traversable(self, self.links.edges[n.id]):
                    n.flatten(depth-1, traversable, _visited)
    return [n for n,d in _visited.values()] # Fast, but not order-preserving.

</t>
<t tx="karstenw.20240123172908.143">def draw(self, weighted=False):
    """ Draws the node as a circle with the given radius, fill, stroke and strokewidth.
        Draws the node centrality as a shadow effect when weighted=True.
        Draws the node text label.
        Override this method in a subclass for custom drawing.
    """
    # Draw the node weight as a shadow (based on node betweenness centrality).
    if weighted is not False and self.centrality &gt; (weighted==True and -1 or weighted):
        w = self.centrality * 35
        ellipse(
            self.x, 
            self.y, 
            self.radius*2 + w, 
            self.radius*2 + w, fill=(0,0,0,0.2), stroke=None)
    # Draw the node.
    ellipse(
        self.x, 
        self.y, 
        self.radius*2, 
        self.radius*2, fill=self.fill, stroke=self.stroke, strokewidth=self.strokewidth)
    # Draw the node text label.
    if self.text:
        self.text.draw(
            self.x + self.radius, 
            self.y + self.radius)
    
</t>
<t tx="karstenw.20240123172908.144">def contains(self, x, y):
    """ Returns True if the given coordinates (x, y) are inside the node radius.
    """
    return abs(self.x - x) &lt; self.radius*2 and \
           abs(self.y - y) &lt; self.radius*2
           
</t>
<t tx="karstenw.20240123172908.145">def __repr__(self):
    return "%s(id=%s, _weight=%s)" % (self.__class__.__name__, str(self.id), str(self._weight))

</t>
<t tx="karstenw.20240123172908.146">def __eq__(self, node):
    # return isinstance(node, Node) and self.id == node.id
    return self.id == node.id

</t>
<t tx="karstenw.20240123172908.147">def __ne__(self, node):
    return not self.__eq__(node)

</t>
<t tx="karstenw.20240123172908.148">class Links(list):
    
    @others
#--- EDGE --------------------------------------------------------------------------------------------

coordinates = lambda x, y, d, a: (x + d*cos(radians(a)), y + d*sin(radians(a)))

</t>
<t tx="karstenw.20240123172908.149">def __init__(self): 
    """ A list in which each node has an associated edge.
        The edge() method returns the edge for a given node id.
    """
    self.edges = dict()

</t>
<t tx="karstenw.20240123172908.15">def _get_xy(self):
    return (self.x, self.y)

# (x,y) in def ???
</t>
<t tx="karstenw.20240123172908.150">def append(self, node, edge=None):
    if node.id not in self.edges:
        list.append(self, node)
    self.edges[node.id] = edge

</t>
<t tx="karstenw.20240123172908.151">def remove(self, node):
    list.remove(self, node)
    self.edges.pop(node.id, None)

</t>
<t tx="karstenw.20240123172908.152">def edge(self, node): 
    return self.edges.get(isinstance(node, Node) and node.id or node)

</t>
<t tx="karstenw.20240123172908.153">class Edge(object):

    @others


</t>
<t tx="karstenw.20240123172908.154">def __init__(self, node1, node2, weight=0.0, length=1.0, type=None, stroke=(0,0,0,1), strokewidth=1):
    """ A connection between two nodes.
        Its weight indicates the importance (not the cost) of the connection.
        Its type is useful in a semantic network (e.g. "is-a", "is-part-of", ...)
    """
    self.node1       = node1
    self.node2       = node2
    self._weight     = weight
    self.length      = length
    self.type        = type
    self.stroke      = stroke
    self.strokewidth = strokewidth

</t>
<t tx="karstenw.20240123172908.155">def _get_weight(self): 
    return self._weight
</t>
<t tx="karstenw.20240123172908.156">def _set_weight(self, v):
    self._weight = v
    # Clear cached adjacency map in the graph, since edge weights have changed.
    if self.node1.graph is not None: 
        self.node1.graph._adjacency = None
    if self.node2.graph is not None: 
        self.node2.graph._adjacency = None

weight = property(_get_weight, _set_weight)
    
</t>
<t tx="karstenw.20240123172908.157">def draw(self, weighted=False, directed=False):
    """ Draws the edge as a line with the given stroke and strokewidth (increased with Edge.weight).
        Override this method in a subclass for custom drawing.
    """
    w = weighted and self.weight or 0
    line(
        self.node1.x, 
        self.node1.y, 
        self.node2.x, 
        self.node2.y, stroke=self.stroke, strokewidth=self.strokewidth+w)
    if directed:
        self.draw_arrow(stroke=self.stroke, strokewidth=self.strokewidth+w)
        
</t>
<t tx="karstenw.20240123172908.158">def draw_arrow(self, **kwargs):
    """ Draws the direction of the edge as an arrow on the rim of the receiving node.
    """
    x0, y0 = self.node1.x, self.node1.y
    x1, y1 = self.node2.x, self.node2.y
    # Find the edge's angle based on node1 and node2 position.
    a = degrees(atan2(y1-y0, x1-x0))
    # The arrow points to node2's rim instead of it's center.
    r = self.node2.radius
    d = sqrt(pow(x1-x0, 2) + pow(y1-y0, 2))
    x01, y01 = coordinates(x0, y0, d-r-1, a)
    # Find the two other arrow corners under the given angle.
    r = max(kwargs.get("strokewidth", 1) * 3, 6)
    dx1, dy1 = coordinates(x01, y01, -r, a-20)
    dx2, dy2 = coordinates(x01, y01, -r, a+20)
    line(x01, y01, dx1, dy1, **kwargs)
    line(x01, y01, dx2, dy2, **kwargs)
    line(dx1, dy1, dx2, dy2, **kwargs)

</t>
<t tx="karstenw.20240123172908.159">def __repr__(self):
    return "%s(id1=%s, id2=%s)" % (self.__class__.__name__, repr(self.node1.id), repr(self.node2.id))

</t>
<t tx="karstenw.20240123172908.16">def _set_xy(self, doublet):
    x,y = doublet
    self.x = float(x)
    self.y = float(y)
xy = property(_get_xy, _set_xy)

</t>
<t tx="karstenw.20240123172908.160">class nodedict(dict):
    @others
</t>
<t tx="karstenw.20240123172908.161">def __init__(self, graph, *args, **kwargs):
    dict.__init__(self, *args, **kwargs)
    self.graph = graph
</t>
<t tx="karstenw.20240123172908.162">def __contains__(self, node):
    return dict.__contains__(self, self.graph.get(node, node))
</t>
<t tx="karstenw.20240123172908.163">def __getitem__(self, node):
    return dict.__getitem__(self, isinstance(node, Node) and node or self.graph[node])
</t>
<t tx="karstenw.20240123172908.164">def get(self, node, default=None):
    return dict.get(self, self.graph.get(node, node), default)

</t>
<t tx="karstenw.20240123172908.165">def unique( thelist ):
    u, b = [], {}
    for item in thelist: 
        if item not in b:
            u.append(item)
            b[item]=True
    return u

# Graph layouts:
SPRING = "spring"

# Graph node sort order:
WEIGHT, CENTRALITY = "weight", "centrality"

ALL = "all"

</t>
<t tx="karstenw.20240123172908.166">class Graph(dict):
    
    @others
</t>
<t tx="karstenw.20240123172908.167">def __init__(self, layout=SPRING, distance=10.0):
    """ A network of nodes connected by edges that can be drawn with a given layout.
    """
    self.nodes      = []   # List of Node objects.
    self.edges      = []   # List of Edge objects.
    self.root       = None
    self._adjacency = None # Cached adjacency() dict.
    self.layout     = layout==SPRING and GraphSpringLayout(self) or GraphLayout(self)
    self.distance   = distance

</t>
<t tx="karstenw.20240123172908.168">def __getitem__(self, id):
    try: 
        return dict.__getitem__(self, id)
    except KeyError:
        raise KeyError( "no node with id '%s' in graph" % (id,) )

</t>
<t tx="karstenw.20240123172908.169">def append(self, base, *args, **kwargs):
    """ Appends a Node or Edge to the graph: Graph.append(Node, id="rabbit").
    """
    kwargs["base"] = base
    if issubclass(base, Node):
        return self.add_node(*args, **kwargs)
    if issubclass(base, Edge):
        return self.add_edge(*args, **kwargs)

</t>
<t tx="karstenw.20240123172908.17">def _get_length(self):
    return sqrt(self.x**2 + self.y**2 + self.z**2)
</t>
<t tx="karstenw.20240123172908.170">def add_node(self, id, *args, **kwargs):
    """ Appends a new Node to the graph.
        An optional base parameter can be used to pass a subclass of Node.
    """
    n = kwargs.pop("base", Node)
    n = isinstance(id, Node) and id or self.get(id) or n(id, *args, **kwargs)
    if n.id not in self:
        self.nodes.append(n)
        self[n.id] = n; n.graph = self
        self.root = kwargs.get("root", False) and n or self.root
        # Clear adjacency cache.
        self._adjacency = None
    return n

</t>
<t tx="karstenw.20240123172908.171">def add_edge(self, id1, id2, *args, **kwargs):
    """ Appends a new Edge to the graph.
        An optional base parameter can be used to pass a subclass of Edge:
        Graph.add_edge("cold", "winter", base=IsPropertyOf)
    """
    # Create nodes that are not yet part of the graph.
    n1 = self.add_node(id1)
    n2 = self.add_node(id2)
    # Creates an Edge instance.
    # If an edge (in the same direction) already exists, yields that edge instead.
    e1 = n1.links.edge(n2)
    if e1 and e1.node1 == n1 and e1.node2 == n2:
        return e1
    e2 = kwargs.pop("base", Edge)
    e2 = e2(n1, n2, *args, **kwargs)
    self.edges.append(e2)
    # Synchronizes Node.links:
    # A.links.edge(B) yields edge A-&gt;B
    # B.links.edge(A) yields edge B-&gt;A
    n1.links.append(n2, edge=e2)
    n2.links.append(n1, edge=e1 or e2)
    # Clear adjacency cache.
    self._adjacency = None
    return e2        
        
</t>
<t tx="karstenw.20240123172908.172">def remove(self, x):
    """ Removes the given Node (and all its edges) or Edge from the graph.
        Note: removing Edge a-&gt;b does not remove Edge b-&gt;a.
    """
    if isinstance(x, Node) and x.id in self:
        self.pop(x.id)
        self.nodes.remove(x); x.graph = None
        # Remove all edges involving the given node.
        for e in list(self.edges):
            if x in (e.node1, e.node2):
                if x in e.node1.links: e.node1.links.remove(x)
                if x in e.node2.links: e.node2.links.remove(x)
                self.edges.remove(e) 
    if isinstance(x, Edge):
        self.edges.remove(x)
    # Clear adjacency cache.
    self._adjacency = None

</t>
<t tx="karstenw.20240123172908.173">def node(self, id):
    """ Returns the node in the graph with the given id.
    """
    return self.get(id)

</t>
<t tx="karstenw.20240123172908.174">def edge(self, id1, id2):
    """ Returns the edge between the nodes with given id1 and id2.
    """
    return id1 in self and id2 in self and self[id1].links.edge(id2) or None

</t>
<t tx="karstenw.20240123172908.175">def paths(self, node1, node2, length=4, path=[]):
    """ Returns a list of paths (shorter than or equal to given length) connecting the two nodes.
    """
    if not isinstance(node1, Node): 
        node1 = self[node1]
    if not isinstance(node2, Node): 
        node2 = self[node2]
    return [[self[id] for id in p] for p in paths(self, node1.id, node2.id, length, path)]

</t>
<t tx="karstenw.20240123172908.176">def shortest_path(self, node1, node2, heuristic=None, directed=False):
    """ Returns a list of nodes connecting the two nodes.
    """
    if not isinstance(node1, Node): 
        node1 = self[node1]
    if not isinstance(node2, Node): 
        node2 = self[node2]
    try: 
        p = dijkstra_shortest_path(self, node1.id, node2.id, heuristic, directed)
        p = [self[id] for id in p]
        return p
    except IndexError:
        return None
        
</t>
<t tx="karstenw.20240123172908.177">def shortest_paths(self, node, heuristic=None, directed=False):
    """ Returns a dictionary of nodes, each linked to a list of nodes (shortest path).
    """
    if not isinstance(node, Node): 
        node = self[node]
    p = nodedict(self)
    for id, path in dijkstra_shortest_paths(self, node.id, heuristic, directed).items():
        p[self[id]] = path and [self[id] for id in path] or None
    return p 
        
</t>
<t tx="karstenw.20240123172908.178">def eigenvector_centrality(self, normalized=True, reversed=True, rating={}, iterations=100, tolerance=0.0001):
    """ Calculates eigenvector centrality and returns a node =&gt; weight dictionary.
        Node.weight is updated in the process.
        Node.weight is higher for nodes with a lot of (indirect) incoming traffic.
    """
    ec1 = eigenvector_centrality(self, normalized, reversed, rating, iterations, tolerance)
    idweights = list((self[_id], w) for _id, w in ec1.items())
    pdb.set_trace()
    # ec2 = nodedict(self, ( (self[_id], w) for _id, w in ec1.items()) )
    ec2 = nodedict(self, idweights )
    for n, w in ec2.items(): 
        n._weight = w
    return ec2

</t>
<t tx="karstenw.20240123172908.179">def betweenness_centrality(self, normalized=True, directed=False):
    """ Calculates betweenness centrality and returns a node =&gt; weight dictionary.
        Node.centrality is updated in the process.
        Node.centrality is higher for nodes with a lot of passing traffic.
    """
    bc = brandes_betweenness_centrality(self, normalized, directed)
    bc = nodedict(self, ((self[id], w) for id, w in bc.items()))
    for n, w in bc.items(): 
        n._centrality = w
    return bc
    
</t>
<t tx="karstenw.20240123172908.18">def _set_length(self, n):
    d = self.length or 1
    self.x *= n/d
    self.y *= n/d
    self.z *= n/d
length = magnitude = property(_get_length, _set_length)

</t>
<t tx="karstenw.20240123172908.180">def sorted(self, order=WEIGHT, threshold=0.0):
    """ Returns a list of nodes sorted by WEIGHT or CENTRALITY.
        Nodes with a lot of traffic will be at the start of the list.
    """
    o = lambda node: getattr(node, order)
    nodes = ((o(n), n) for n in self.nodes if o(n) &gt;= threshold)
    nodes = reversed(sorted(nodes))
    return [n for w, n in nodes]
    
</t>
<t tx="karstenw.20240123172908.181">def prune(self, depth=0):
    """ Removes all nodes with less or equal links than depth.
    """
    for n in (n for n in self.nodes if len(n.links) &lt;= depth):
        self.remove(n)
        
</t>
<t tx="karstenw.20240123172908.182">def fringe(self, depth=0):
    """ For depth=0, returns the list of leaf nodes (nodes with only one connection).
        For depth=1, returns the list of leaf nodes and their connected nodes, and so on.
    """
    u = []; [u.extend(n.flatten(depth)) for n in self.nodes if len(n.links) == 1]
    return unique(u)
    
</t>
<t tx="karstenw.20240123172908.183">@property
def density(self):
    """ Yields the number of edges vs. the maximum number of possible edges.
        For example, &lt;0.35 =&gt; sparse, &gt;0.65 =&gt; dense, 1.0 =&gt; complete.
    """
    return 2.0*len(self.edges) / (len(self.nodes) * (len(self.nodes)-1))
    
</t>
<t tx="karstenw.20240123172908.184">@property
def is_complete(self):
    return self.density == 1.0
</t>
<t tx="karstenw.20240123172908.185">@property
def is_dense(self):
    return self.density &gt; 0.65
</t>
<t tx="karstenw.20240123172908.186">@property
def is_sparse(self):
    return self.density &lt; 0.35
    
</t>
<t tx="karstenw.20240123172908.187">def split(self):
    """ Returns the list of unconnected subgraphs.
    """
    return partition(self)

</t>
<t tx="karstenw.20240123172908.188">def update(self, iterations=10, **kwargs):
    """ Graph.layout.update() is called the given number of iterations.
    """
    for i in range(iterations):
        self.layout.update(**kwargs)
    
</t>
<t tx="karstenw.20240123172908.189">def draw(self, weighted=False, directed=False):
    """ Draws all nodes and edges.
    """
    for e in self.edges: 
        e.draw(weighted, directed)
    for n in reversed(self.nodes): # New nodes (with Node._weight=None) first. 
        n.draw(weighted)
        
</t>
<t tx="karstenw.20240123172908.19">def distance(self, v):
    """ Returns the distance between two vectors,
        e.g. if two vectors would be two sides of a triangle, returns the third side.
    """
    dx = v.x - self.x
    dy = v.y - self.y
    dz = v.z - self.z
    return sqrt(dx**2 + dy**2 + dz**2)

</t>
<t tx="karstenw.20240123172908.190">def node_at(self, x, y):
    """ Returns the node at (x,y) or None.
    """
    for n in self.nodes:
        if n.contains(x, y): return n

</t>
<t tx="karstenw.20240123172908.191">def _add_node_copy(self, n, **kwargs):
    # Magical fairy dust to copy subclasses of Node.
    # We assume that the subclass constructor takes an optional "text" parameter
    # (Text objects in NodeBox for OpenGL's implementation are expensive).
    try:
        new = self.add_node(n.id, root=kwargs.get("root",False), text=False)
    except TypeError:
        new = self.add_node(n.id, root=kwargs.get("root",False))
    new.__class__ = n.__class__
    new.__dict__.update((k, deepcopy(v)) for k,v in n.__dict__.items() 
        if k not in ("graph", "links", "_x", "_y", "force", "_weight", "_centrality"))

</t>
<t tx="karstenw.20240123172908.192">def _add_edge_copy(self, e, **kwargs):
    if kwargs.get("node1", e.node1).id not in self \
    or kwargs.get("node2", e.node2).id not in self: 
        return
    new = self.add_edge(
        kwargs.get("node1", self[e.node1.id]), 
        kwargs.get("node2", self[e.node2.id]))
    new.__class__ = e.__class__
    new.__dict__.update((k, deepcopy(v)) for k,v in e.__dict__.items()
        if k not in ("node1", "node2"))

</t>
<t tx="karstenw.20240123172908.193">def copy(self, nodes=ALL):
    """ Returns a copy of the graph with the given list of nodes (and connecting edges).
        The layout will be reset.
    """
    g = Graph(layout=None, distance=self.distance)
    g.layout = self.layout.copy(graph=g)
    for n in (nodes==ALL and self.nodes or (isinstance(n, Node) and n or self[n] for n in nodes)):
        g._add_node_copy(n, root=self.root==n)
    for e in self.edges: 
        g._add_edge_copy(e)
    return g

</t>
<t tx="karstenw.20240123172908.194">#--- GRAPH LAYOUT ------------------------------------------------------------------------------------
# Graph drawing or graph layout, as a branch of graph theory, 
# applies topology and geometry to derive two-dimensional representations of graphs.

class GraphLayout:
    
    @others
</t>
<t tx="karstenw.20240123172908.195">def __init__(self, graph):
    """ Calculates node positions iteratively when GraphLayout.update() is called.
    """
    self.graph = graph
    self.iterations = 0

</t>
<t tx="karstenw.20240123172908.196">def update(self):
    self.iterations += 1

</t>
<t tx="karstenw.20240123172908.197">def reset(self):
    self.iterations = 0
    for n in self.graph.nodes:
        n._x = 0
        n._y = 0
        n.force = Vector(0,0)
        
</t>
<t tx="karstenw.20240123172908.198">@property
def bounds(self):
    """ Returns a (x, y, width, height)-tuple of the approximate layout dimensions.
    """
    x0, y0 = +INFINITE, +INFINITE
    x1, y1 = -INFINITE, -INFINITE
    for n in self.graph.nodes:
        if (n.x &lt; x0): x0 = n.x
        if (n.y &lt; y0): y0 = n.y
        if (n.x &gt; x1): x1 = n.x
        if (n.y &gt; y1): y1 = n.y
    return (x0, y0, x1-x0, y1-y0)

</t>
<t tx="karstenw.20240123172908.199">def copy(self, graph):
    return GraphLayout(self, graph)

</t>
<t tx="karstenw.20240123172908.2">def line(x1, y1, x2, y2, stroke=(0,0,0,1), strokewidth=1):
    pass
</t>
<t tx="karstenw.20240123172908.20">def distance2(self, v):
    # Squared distance, avoiding the costly root calculation.
    return (v.x-self.x)**2 + (v.y-self.y)**2 + (v.z-self.z)**2

</t>
<t tx="karstenw.20240123172908.200">class GraphSpringLayout(GraphLayout):
    
    @others

</t>
<t tx="karstenw.20240123172908.201">def __init__(self, graph):
    """ A force-based layout in which edges are regarded as springs.
        The forces are applied to the nodes, pulling them closer or pushing them apart.
    """
    # Based on: http://snipplr.com/view/1950/graph-javascript-framework-version-001/
    GraphLayout.__init__(self, graph)
    self.k         = 4.0  # Force constant.
    self.force     = 0.01 # Force multiplier.
    self.repulsion = 15   # Maximum repulsive force radius.

</t>
<t tx="karstenw.20240123172908.202">def _distance(self, node1, node2):
    # Yields a tuple with distances (dx, dy, d, d**2).
    # Ensures that the distance is never zero (which deadlocks the animation).
    dx = node2._x - node1._x
    dy = node2._y - node1._y
    d2 = dx*dx + dy*dy
    if d2 &lt; 0.01:
        dx = random() * 0.1 + 0.1
        dy = random() * 0.1 + 0.1
        d2 = dx*dx + dy*dy
    return dx, dy, sqrt(d2), d2

</t>
<t tx="karstenw.20240123172908.203">def _repulse(self, node1, node2):
    # Updates Node.force with the repulsive force.
    dx, dy, d, d2 = self._distance(node1, node2)
    if d &lt; self.repulsion:
        f = self.k**2 / d2
        node2.force.x += f * dx
        node2.force.y += f * dy
        node1.force.x -= f * dx
        node1.force.y -= f * dy
        
</t>
<t tx="karstenw.20240123172908.204">def _attract(self, node1, node2, weight=0, length=1.0):
    # Updates Node.force with the attractive edge force.
    dx, dy, d, d2 = self._distance(node1, node2)
    d = min(d, self.repulsion)
    f = (d2 - self.k**2) / self.k * length
    f *= weight * 0.5 + 1
    f /= d
    node2.force.x -= f * dx
    node2.force.y -= f * dy
    node1.force.x += f * dx
    node1.force.y += f * dy
    
</t>
<t tx="karstenw.20240123172908.205">def update(self, weight=10.0, limit=0.5):
    """ Updates the position of nodes in the graph.
        The weight parameter determines the impact of edge weight.
        The limit parameter determines the maximum movement each update().
    """
    GraphLayout.update(self)
    # Forces on all nodes due to node-node repulsions.
    for i, n1 in enumerate(self.graph.nodes):
        for j, n2 in enumerate(self.graph.nodes[i+1:]):          
            self._repulse(n1, n2)
    # Forces on nodes due to edge attractions.
    for e in self.graph.edges:
        self._attract(e.node1, e.node2, weight*e.weight, 1.0/(e.length or 0.01))
    # Move nodes by given force.
    for n in self.graph.nodes:
        if not n.fixed:
            n._x += max(-limit, min(self.force * n.force.x, limit))
            n._y += max(-limit, min(self.force * n.force.y, limit))
        n.force.x = 0
        n.force.y = 0
        
</t>
<t tx="karstenw.20240123172908.206">def copy(self, graph):
    g = GraphSpringLayout(graph)
    g.k, g.force, g.repulsion = self.k, self.force, self.repulsion
    return g

</t>
<t tx="karstenw.20240123172908.207">def depth_first_search(node, visit=lambda node: False, traversable=lambda node, edge: True, _visited=None):
    """ Visits all the nodes connected to the given root node, depth-first.
        The visit function is called on each node.
        Recursion will stop if it returns True, and subsequently dfs() will return True.
        The traversable function takes the current node and edge,
        and returns True if we are allowed to follow this connection to the next node.
        For example, the traversable for directed edges is follows:
         lambda node, edge: node == edge.node1
    """
    stop = visit(node)
    _visited = _visited or {}
    _visited[node.id] = True
    for n in node.links:
        if stop: return True
        if traversable(node, node.links.edge(n)) is False: continue
        if not n.id in _visited:
            stop = depth_first_search(n, visit, traversable, _visited)
    return stop
    
dfs = depth_first_search;

</t>
<t tx="karstenw.20240123172908.208">def breadth_first_search(node, visit=lambda node: False, traversable=lambda node, edge: True):
    """ Visits all the nodes connected to the given root node, breadth-first.
    """
    q = [node]
    _visited = {}
    while q:
        node = q.pop(0)
        if not node.id in _visited:
            if visit(node):
                return True
            q.extend((n for n in node.links if traversable(node, node.links.edge(n)) is not False))
            _visited[node.id] = True
    return False
        
bfs = breadth_first_search;

</t>
<t tx="karstenw.20240123172908.209">def paths(graph, id1, id2, length=4, path=[], _root=True):
    """ Returns a list of paths from node with id1 to node with id2.
        Only paths shorter than or equal to the given length are included.
        Uses a brute-force DFS approach (performance drops exponentially for longer paths).
    """
    if len(path) &gt;= length:
        return []
    if id1 not in graph:
        return []
    if id1 == id2:
        return [path + [id1]]
    path = path + [id1]
    p = []
    s = set(path) # 5% speedup.
    for node in graph[id1].links:
        if node.id not in s: 
            p.extend(paths(graph, node.id, id2, length, path, False))
    return _root and sorted(p, key=len) or p

</t>
<t tx="karstenw.20240123172908.21">def normalize(self):
    """ Normalizes the vector to a unit vector with length=1.
    """
    d = self.length or 1
    self.x /= d
    self.y /= d
    self.z /= d

</t>
<t tx="karstenw.20240123172908.210">def edges(path):
    """ Returns an iterator of Edge objects for the given list of nodes.
        It yields None where two successive nodes are not connected.
    """
    # For example, the distance (i.e., edge weight sum) of a path:
    # sum(e.weight for e in edges(path))
    return len(path) &gt; 1 and (n.links.edge(path[i+1]) for i,n in enumerate(path[:-1])) or iter(())
    
</t>
<t tx="karstenw.20240123172908.211">def adjacency(graph, directed=False, reversed=False, stochastic=False, heuristic=None):
    """ Returns a dictionary indexed by node id1's,
        in which each value is a dictionary of connected node id2's linking to the edge weight.
        If directed=True, edges go from id1 to id2, but not the other way.
        If stochastic=True, all the weights for the neighbors of a given node sum to 1.
        A heuristic function can be given that takes two node id's and returns
        an additional cost for movement between the two nodes.
    """
    # Caching a heuristic from a method won't work.
    # Bound method objects are transient, 
    # i.e., id(object.method) returns a new value each time.
    if graph._adjacency is not None and \
       graph._adjacency[1:] == (directed, reversed, stochastic, heuristic and id(heuristic)):
        return graph._adjacency[0]
    map = {}
    for n in graph.nodes:
        map[n.id] = {}
    for e in graph.edges:
        id1, id2 = not reversed and (e.node1.id, e.node2.id) or (e.node2.id, e.node1.id)
        map[id1][id2] = 1.0 - 0.5 * e.weight
        if heuristic:
            map[id1][id2] += heuristic(id1, id2)
        if not directed: 
            map[id2][id1] = map[id1][id2]
    if stochastic:
        for id1 in map:
            n = sum(map[id1].values())
            for id2 in map[id1]: 
                map[id1][id2] /= n
    # Cache the adjacency map: this makes dijkstra_shortest_path() 2x faster in repeated use.
    graph._adjacency = (map, directed, reversed, stochastic, heuristic and id(heuristic))
    return map

</t>
<t tx="karstenw.20240123172908.212">def dijkstra_shortest_path(graph, id1, id2, heuristic=None, directed=False):
    """ Dijkstra algorithm for finding the shortest path between two nodes.
        Returns a list of node id's, starting with id1 and ending with id2.
        Raises an IndexError between nodes on unconnected graphs.
    """
    # Based on: Connelly Barnes, http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/119466
    def flatten(list):
        # Flattens a linked list of the form [0,[1,[2,[]]]]
        while len(list) &gt; 0:
            yield list[0]; list=list[1]
    G = adjacency(graph, directed=directed, heuristic=heuristic)
    q = [(0, id1, ())] # Heap of (cost, path_head, path_rest).
    visited = set()    # Visited nodes.
    while True:
        (cost1, n1, path) = heappop(q)
        if n1 not in visited:
            visited.add(n1)
        if n1 == id2:
            return list(flatten(path))[::-1] + [n1]
        path = (n1, path)
        for (n2, cost2) in G[n1].items():
            if n2 not in visited:
                heappush(q, (cost1 + cost2, n2, path))

</t>
<t tx="karstenw.20240123172908.213">def dijkstra_shortest_paths(graph, id, heuristic=None, directed=False):
    """ Dijkstra algorithm for finding the shortest paths from the given node to all other nodes.
        Returns a dictionary of node id's, each linking to a list of node id's (i.e., the path).
    """
    # Based on: Dijkstra's algorithm for shortest paths modified from Eppstein.
    # Based on: NetworkX 1.4.1: Aric Hagberg, Dan Schult and Pieter Swart.
    # This is 5x faster than:
    # for n in g: dijkstra_shortest_path(g, id, n.id)
    W = adjacency(graph, directed=directed, heuristic=heuristic)
    Q = [] # Use Q as a heap with (distance, node id)-tuples.
    D = {} # Dictionary of final distances.
    P = {} # Dictionary of paths.
    P[id] = [id] 
    seen = {id: 0} 
    heappush(Q, (0, id))
    while Q:
        (dist, v) = heappop(Q)
        if v in D: continue
        D[v] = dist
        for w in W[v].keys():
            vw_dist = D[v] + W[v][w]
            if w not in D and (w not in seen or vw_dist &lt; seen[w]):
                seen[w] = vw_dist
                heappush(Q, (vw_dist, w))
                P[w] = P[v] + [w]
    for n in graph:
        if n not in P: P[n]=None
    return P

</t>
<t tx="karstenw.20240123172908.214">def floyd_warshall_all_pairs_distance(graph, heuristic=None, directed=False):
    """ Floyd-Warshall's algorithm for finding the path length for all pairs for nodes.
        Returns a dictionary of node id's, 
        each linking to a dictionary of node id's linking to path length.
    """
    from collections import defaultdict # Requires Python 2.5+.
    g = list( graph.keys() )
    d = defaultdict(lambda: defaultdict(lambda: 1e30)) # float('inf')
    p = defaultdict(dict) # Predecessors.
    for e in graph.edges:
        u = e.node1.id
        v = e.node2.id
        w = 1.0 - 0.5 * e.weight
        w = heuristic and heuristic(u, v) + w or w
        d[u][v] = min(w, d[u][v])
        d[u][u] = 0
        p[u][v] = u
        if not directed:
            d[v][u] = min(w, d[v][u])
            p[v][u] = v
    for w in g:
        dw = d[w]
        for u in g:
            du, duw = d[u], d[u][w]
            for v in g:
                # Performance optimization, assumes d[w][v] &gt; 0.
                #if du[v] &gt; duw + dw[v]:
                if du[v] &gt; duw and du[v] &gt; duw + dw[v]:
                    d[u][v] = duw + dw[v]
                    p[u][v] = p[w][v]
    class pdict(dict):
        def __init__(self, predecessors, *args, **kwargs):
            dict.__init__(self, *args, **kwargs)
            self.predecessors = predecessors
    return pdict(p, ((u, dict((v, w) for v,w in d[u].items() if w &lt; 1e30)) for u in d))

</t>
<t tx="karstenw.20240123172908.215">def predecessor_path(tree, u, v):
    """ Returns the path between node u and node v as a list of node id's.
        The given tree is the return value of floyd_warshall_all_pairs_distance().predecessors.
    """
    def _traverse(u, v):
        w = tree[u][v]
        if w == u:
            return []
        return _traverse(u,w) + [w] + _traverse(w,v)
    return [u] + _traverse(u,v) + [v]

</t>
<t tx="karstenw.20240123172908.216">def brandes_betweenness_centrality(graph, normalized=True, directed=False):
    """ Betweenness centrality for nodes in the graph.
        Betweenness centrality is a measure of the number of shortests paths that pass through a node.
        Nodes in high-density areas will get a good score.
    """
    # Ulrik Brandes, A Faster Algorithm for Betweenness Centrality,
    # Journal of Mathematical Sociology 25(2):163-177, 2001,
    # http://www.inf.uni-konstanz.de/algo/publications/b-fabc-01.pdf
    # Based on: Dijkstra's algorithm for shortest paths modified from Eppstein.
    # Based on: NetworkX 1.0.1: Aric Hagberg, Dan Schult and Pieter Swart.
    # http://python-networkx.sourcearchive.com/documentation/1.0.1/centrality_8py-source.html
    W = adjacency(graph, directed=directed)
    b = dict.fromkeys(graph, 0.0)
    for id in graph:
        Q = [] # Use Q as a heap with (distance, node id)-tuples.
        D = {} # Dictionary of final distances.
        P = {} # Dictionary of paths.
        for n in graph: P[n]=[]
        seen = {id: 0} 
        heappush(Q, (0, id, id))
        S = []
        E = dict.fromkeys(graph, 0) # sigma
        E[id] = 1.0
        while Q:    
            (dist, pred, v) = heappop(Q) 
            if v in D: 
                continue
            D[v] = dist
            S.append(v)
            E[v] += E[pred]
            for w in W[v]:
                vw_dist = D[v] + W[v][w]
                if w not in D and (w not in seen or vw_dist &lt; seen[w]): 
                    seen[w] = vw_dist 
                    heappush(Q, (vw_dist, v, w))
                    P[w] = [v]
                    E[w] = 0.0
                elif vw_dist == seen[w]: # Handle equal paths.
                    P[w].append(v)
                    E[w] += E[v] 
        d = dict.fromkeys(graph, 0.0)  
        for w in reversed(S):
            for v in P[w]:
                d[v] += (1.0 + d[w]) * E[v] / E[w]
            if w != id: 
                b[w] += d[w]
    # Normalize between 0.0 and 1.0.
    m = normalized and max( list( b.values() )) or 1
    b = dict((id, w/m) for id, w in b.items())
    return b

</t>
<t tx="karstenw.20240123172908.217">def eigenvector_centrality(graph, normalized=True, reversed=True, rating={}, iterations=100, tolerance=0.0001):
    """ Eigenvector centrality for nodes in the graph (cfr. Google's PageRank).
        Eigenvector centrality is a measure of the importance of a node in a directed network. 
        It rewards nodes with a high potential of (indirectly) connecting to high-scoring nodes.
        Nodes with no incoming connections have a score of zero.
        If you want to measure outgoing connections, reversed should be False.        
    """
    # Based on: NetworkX, Aric Hagberg (hagberg@lanl.gov)
    # http://python-networkx.sourcearchive.com/documentation/1.0.1/centrality_8py-source.html
    # Note: much faster than betweenness centrality (which grows exponentially).
    def normalize(vector):
        w = 1.0 / (sum( list(vector.values()) ) or 1)
        for node in vector: 
            vector[node] *= w
        return vector
    G = adjacency(graph, directed=True, reversed=reversed)
    v = normalize(dict([(n, random()) for n in graph])) # Node ID =&gt; weight vector.
    # Eigenvector calculation using the power iteration method: y = Ax.
    # It has no guarantee of convergence.
    for i in range(iterations):
        v0 = v
        v  = dict.fromkeys(v0.keys(), 0)
        for n1 in v:
            for n2 in G[n1]:
                v[n1] += 0.01 + v0[n2] * G[n1][n2] * rating.get(n1, 1)
        normalize(v)
        e = sum([abs(v[n]-v0[n]) for n in v]) # Check for convergence.
        if e &lt; len(G) * tolerance:
            # Normalize between 0.0 and 1.0.
            m = normalized and max( list(v.values()) ) or 1
            v = dict((id, w/m) for id, w in v.items())
            return v
    warn("node weight is 0 because eigenvector_centrality() did not converge.", Warning)
    return dict((n, 0) for n in G)

# a | b =&gt; all elements from a and all the elements from b. 
# a &amp; b =&gt; elements that appear in a as well as in b.
# a - b =&gt; elements that appear in a but not in b.
</t>
<t tx="karstenw.20240123172908.218">def union(a, b):
    return list(set(a) | set(b))
</t>
<t tx="karstenw.20240123172908.219">def intersection(a, b):
    return list(set(a) &amp; set(b))
</t>
<t tx="karstenw.20240123172908.22">def _normalized(self):
    """ Yields a new vector that is the normalized vector of this vector.
    """
    d = self.length
    if d == 0: 
        return self.copy()
    return Vector(self.x/d, self.y/d, self.z/d)
normalized = unit = property(_normalized)

</t>
<t tx="karstenw.20240123172908.220">def difference(a, b):
    return list(set(a) - set(b))

</t>
<t tx="karstenw.20240123172908.221">def partition(graph):
    """ Returns a list of unconnected subgraphs.
    """
    # Creates clusters of nodes and directly connected nodes.
    # Iteratively merges two clusters if they overlap.
    g = []
    for n in graph.nodes:
        g.append(dict.fromkeys((n.id for n in n.flatten()), True))
    for i in reversed(range(len(g))):
        for j in reversed(range(i+1, len(g))):
            if g[i] and g[j] and len(intersection(g[i], g[j])) &gt; 0:
                g[i] = union(g[i], g[j])
                g[j] = []
    g = [graph.copy(nodes=[graph[id] for id in n]) for n in g if n]
    g.sort(lambda a, b: len(b) - len(a))
    return g

</t>
<t tx="karstenw.20240123172908.222">def is_clique(graph):
    """ A clique is a set of nodes in which each node is connected to all other nodes.
    """
    #for n1 in graph.nodes:
    #    for n2 in graph.nodes:
    #        if n1 != n2 and graph.edge(n1.id, n2.id) is None:
    #            return False
    return graph.density == 1.0
    
</t>
<t tx="karstenw.20240123172908.223">def clique(graph, id):
    """ Returns the largest possible clique for the node with given id.
    """
    if isinstance(id, Node):
        id = id.id
    a = [id]
    for n in graph.nodes:
        try:
            # Raises StopIteration if all nodes in the clique are connected to n:
            (id for id in a if n.id==id or graph.edge(n.id, id) is None).next()
        except StopIteration:
            a.append(n.id)
    return a
    
</t>
<t tx="karstenw.20240123172908.224">def cliques(graph, threshold=3):
    """ Returns all cliques in the graph with at least the given number of nodes.
    """
    a = []
    for n in graph.nodes:
        c = clique(graph, n.id)
        if len(c) &gt;= threshold: 
            c.sort()
            if c not in a: a.append(c)
    return a

</t>
<t tx="karstenw.20240123172908.225">def unlink(graph, node1, node2=None):
    """ Removes the edges between node1 and node2.
        If only node1 is given, removes all edges to and from it.
        This does not remove node1 from the graph.
    """
    if not isinstance(node1, Node):
        node1 = graph[node1]
    if not isinstance(node2, Node) and node2 is not None:
        node2 = graph[node2]
    for e in list(graph.edges):
        if node1 in (e.node1, e.node2) and node2 in (e.node1, e.node2, None):
            graph.edges.remove(e)
            try:
                node1.links.remove(node2)
                node2.links.remove(node1)
            except: # 'NoneType' object has no attribute 'links'
                pass

</t>
<t tx="karstenw.20240123172908.226">def redirect(graph, node1, node2):
    """ Connects all of node1's edges to node2 and unlinks node1.
    """
    if not isinstance(node1, Node):
        node1 = graph[node1]
    if not isinstance(node2, Node):
        node2 = graph[node2]
    for e in graph.edges:
        if node1 in (e.node1, e.node2):
            if e.node1 == node1 and e.node2 != node2:
                graph._add_edge_copy(e, node1=node2, node2=e.node2) 
            if e.node2 == node1 and e.node1 != node2: 
                graph._add_edge_copy(e, node1=e.node1, node2=node2) 
    unlink(graph, node1)

</t>
<t tx="karstenw.20240123172908.227">def cut(graph, node):
    """ Unlinks the given node, but keeps edges intact by connecting the surrounding nodes.
        If A, B, C, D are nodes and A-&gt;B, B-&gt;C, B-&gt;D, if we then cut B: A-&gt;C, A-&gt;D.
    """
    if not isinstance(node, Node):
        node = graph[node]
    for e in graph.edges:
        if node in (e.node1, e.node2):
            for n in node.links:
                if e.node1 == node and e.node2 != n: 
                    graph._add_edge_copy(e, node1=n, node2=e.node2) 
                if e.node2 == node and e.node1 != n: 
                    graph._add_edge_copy(e, node1=e.node1, node2=n) 
    unlink(graph, node)

</t>
<t tx="karstenw.20240123172908.228">def insert(graph, node, a, b):
    """ Inserts the given node between node a and node b.
        If A, B, C are nodes and A-&gt;B, if we then insert C: A-&gt;C, C-&gt;B.
    """
    if not isinstance(node, Node):
        node = graph[node]
    if not isinstance(a, Node): 
        a = graph[a]
    if not isinstance(b, Node): 
        b = graph[b]
    for e in graph.edges:
        if e.node1 == a and e.node2 == b: 
            graph._add_edge_copy(e, node1=a, node2=node) 
            graph._add_edge_copy(e, node1=node, node2=b) 
        if e.node1 == b and e.node2 == a: 
            graph._add_edge_copy(e, node1=b, node2=node) 
            graph._add_edge_copy(e, node1=node, node2=a) 
    unlink(graph, a, b)
</t>
<t tx="karstenw.20240123172908.23">def reverse(self):
    """ Reverses the direction of the vector so it points in the opposite direction.
    """
    self.x = -self.x
    self.y = -self.y
    self.z = -self.z
flip = reverse

</t>
<t tx="karstenw.20240123172908.24">def _reversed(self):
    """ Yields a new vector pointing in the opposite direction of this vector.
    """
    return Vector(-self.x, -self.y, -self.z)
reversed = flipped = inverse = property(_reversed)

# v.normal, v.angle, v.rotate(), v.rotated() and v.angle_to() are defined in 2D.
# v.in2D.rotate() is here for decorational purposes.
</t>
<t tx="karstenw.20240123172908.25">@property
def in2D(self):
    return self

</t>
<t tx="karstenw.20240123172908.26">def _orthogonal(self):
    """ Yields a new vector whose 2D angle is 90 degrees (perpendicular) to this vector.
        In 3D, there would be many perpendicular vectors.
    """
    return Vector(self.y, -self.x, self.z)
orthogonal = perpendicular = normal = property(_orthogonal)

</t>
<t tx="karstenw.20240123172908.27">def _get_angle(self):
    """ Yields the 2D direction of the vector.
    """
    return degrees(atan2(self.y, self.x))
</t>
<t tx="karstenw.20240123172908.28">def _set_angle(self, degrees):
    d = self.length
    self.x = cos(radians(degrees)) * d
    self.y = sin(radians(degrees)) * d
angle = direction = property(_get_angle, _set_angle)

</t>
<t tx="karstenw.20240123172908.29">def rotate(self, degrees):
    """ Rotates the direction of the vector in 2D.
    """
    self.angle += degrees
    
</t>
<t tx="karstenw.20240123172908.3">def ellipse(x, y, width, height, fill=(0,0,0,1), stroke=None, strokewidth=1):
    pass

</t>
<t tx="karstenw.20240123172908.30">def rotated(self, degrees):
    """ Returns a copy of the vector with direction rotated in 2D.
    """
    v = self.copy()
    v.rotate(degrees)
    return v

</t>
<t tx="karstenw.20240123172908.31">def angle_to(self, v):
    """ Returns the 2D angle between two vectors.
    """
    return degrees(atan2(v.y, v.x) - atan2(self.y, self.x))
angle_between = angle_to

# Arithmetic operators.
# + - * / returns new vector objects.
</t>
<t tx="karstenw.20240123172908.32">def __add__(self, v):
    if isinstance(v, (int, float)): 
        return Vector(self.x+v, self.y+v, self.z+v)
    return Vector(self.x+v.x, self.y+v.y, self.z+v.z)
</t>
<t tx="karstenw.20240123172908.33">def __sub__(self, v):
    if isinstance(v, (int, float)): 
        return Vector(self.x-v, self.y-v, self.z-v)
    return Vector(self.x-v.x, self.y-v.y, self.z-v.z)
</t>
<t tx="karstenw.20240123172908.34">def __mul__(self, v):
    if isinstance(v, (int, float)): 
        return Vector(self.x*v, self.y*v, self.z*v)
    return Vector(self.x*v.x, self.y*v.y, self.z*v.z)
</t>
<t tx="karstenw.20240123172908.35">def __div__(self, v):
    if isinstance(v, (int, float)): 
        return Vector(self.x/v, self.y/v, self.z/v)
    return Vector(self.x/v.x, self.y/v.y, self.z/v.z)

# += -= *= /= modify the vector coordinates in-place.
</t>
<t tx="karstenw.20240123172908.36">def __iadd__(self, v):
    if isinstance(v, (int, float)):
        self.x+=v; self.y+=v; self.z+=v; return self
    self.x+=v.x; self.y+=v.y; self.z+=v.z; return self
</t>
<t tx="karstenw.20240123172908.37">def __isub__(self, v):
    if isinstance(v, (int, float)):
        self.x-=v; self.y-=v; self.z-=v; return self
    self.x-=v.x; self.y-=v.y; self.z-=v.z; return self
</t>
<t tx="karstenw.20240123172908.38">def __imul__(self, v):
    if isinstance(v, (int, float)):
        self.x*=v; self.y*=v; self.z*=v; return self
    self.x*=v.x; self.y*=v.y; self.z*=v.z; return self
</t>
<t tx="karstenw.20240123172908.39">def __idiv__(self, v):
    if isinstance(v, (int, float)):
        self.x/=v; self.y/=v; self.z/=v; return self
    self.x/=v.x; self.y/=v.y; self.z/=v.z; return self

</t>
<t tx="karstenw.20240123172908.4">class Text:
    @others
#=====================================================================================================

#--- VECTOR ------------------------------------------------------------------------------------------
# A Euclidean vector (sometimes called a geometric or spatial vector, or - as here - simply a vector) 
# is a geometric object that has both a magnitude (or length) and direction. 
# A vector is frequently represented by a line segment with an arrow.

</t>
<t tx="karstenw.20240123172908.40">def dot(self, v):
    """ Returns a scalar that is the dot product between the two vectors.
    """
    return self.x*v.x + self.y*v.y + self.z*v.z
    
</t>
<t tx="karstenw.20240123172908.41">def cross(self, v):
    """ Returns a new vector that is the cross product between the two vectors.
    """
    return Vector(self.y*v.z - self.z*v.y, 
                  self.z*v.x - self.x*v.z, 
                  self.x*v.y - self.y*v.x)

</t>
<t tx="karstenw.20240123172908.42">def __neg__(self):
    return Vector(-self.x, -self.y, -self.z)

</t>
<t tx="karstenw.20240123172908.43">def __eq__(self, v):
    return isinstance(v, Vector) and self.x == v.x and self.y == v.y and self.z == v.z
</t>
<t tx="karstenw.20240123172908.44">def __ne__(self, v):
    return not self.__eq__(v)

</t>
<t tx="karstenw.20240123172908.45">def __repr__(self): 
    return "%s(%.2f, %.2f, %.2f)" % (self.__class__.__name__, self.x, self.y, self.z)

</t>
<t tx="karstenw.20240123172908.46">def draw(self, x, y):
    """ Draws the vector in 2D (z-axis is ignored). 
        Set stroke() and strokewidth() first.
    """
    ellipse(x, y, 4, 4)
    line(x, y, x+self.x, y+self.y)

</t>
<t tx="karstenw.20240123172908.47">def _uid():
    global _UID; _UID+=1; return _UID

</t>
<t tx="karstenw.20240123172908.48">class Boid:
    
    @others
</t>
<t tx="karstenw.20240123172908.49">def __init__(self, flock, x=0, y=0, z=0, sight=70, space=30):
    """ An agent in a flock with an (x,y,z)-position subject to different forces.
        - sight : radius of local flockmates when calculating cohesion and alignment.
        - space : radius of personal space when calculating separation.
    """
    self._id      = _uid()
    self.flock    = flock
    self.x        = x
    self.y        = y
    self.z        = z
    self.velocity = Vector(random()*2-1, random()*2-1, random()*2-1)
    self.target   = None  # A target Vector towards which the boid will steer.
    self.sight    = sight # The radius of cohesion and alignment, and visible obstacles.
    self.space    = space # The radius of separation.
    self.dodge    = False # Avoiding an obstacle?
    self.crowd    = 0     # Percentage (0.0-1.0) of flockmates within sight.

</t>
<t tx="karstenw.20240123172908.5">def __init__(self, string, **kwargs):
    self.string = string
    self.__dict__.update(kwargs)
</t>
<t tx="karstenw.20240123172908.50">def __eq__(self, other):
    # Comparing boids by id makes it significantly faster.
    return isinstance(other, Boid) and self._id == other._id
</t>
<t tx="karstenw.20240123172908.51">def __ne__(self, other):
    return not self.__eq__(other)
            
</t>
<t tx="karstenw.20240123172908.52">def copy(self):
    b = Boid(self.flock, self.x, self.y, self.z, self.sight, self.space)
    b.velocity = self.velocity.copy()
    b.target   = self.target
    return b
    
</t>
<t tx="karstenw.20240123172908.53">@property
def heading(self):
    """ The boid's heading as an angle in degrees.
    """
    return self.velocity.angle
    
</t>
<t tx="karstenw.20240123172908.54">@property
def depth(self):
    """ The boid's relative depth (0.0-1.0) in the flock's container box.
    """
    return not self.flock.depth and 1.0 or max(0.0, min(1.0, self.z / self.flock.depth))

</t>
<t tx="karstenw.20240123172908.55">def near(self, boid, distance=50):
    """ Returns True if the given boid is within distance.
    """
    # Distance is measured in a box instead of a sphere for performance.
    return abs(self.x - boid.x) &lt; distance and \
           abs(self.y - boid.y) &lt; distance and \
           abs(self.z - boid.z) &lt; distance

</t>
<t tx="karstenw.20240123172908.56">def separation(self, distance=25):
    """ Returns steering velocity (vx,vy,vz) to avoid crowding local flockmates.
    """
    vx = vy = vz = 0.0
    for b in self.flock:
        if b != self:
            if abs(self.x-b.x) &lt; distance: vx += self.x - b.x
            if abs(self.y-b.y) &lt; distance: vy += self.y - b.y
            if abs(self.z-b.z) &lt; distance: vz += self.z - b.z
    return vx, vy, vz
    
</t>
<t tx="karstenw.20240123172908.57">def alignment(self, distance=50):
    """ Returns steering velocity (vx,vy,vz) towards the average heading of local flockmates.
    """
    vx = vy = vz = n = 0.0
    for b in self.flock:
        if b != self and b.near(self, distance):
            vx += b.velocity.x
            vy += b.velocity.y
            vz += b.velocity.z; n += 1
    if n: 
        return (vx/n-self.velocity.x), (vy/n-self.velocity.y), (vz/n-self.velocity.z)
    return vx, vy, vz

</t>
<t tx="karstenw.20240123172908.58">def cohesion(self, distance=40):
    """ Returns steering velocity (vx,vy,vz) towards the average position of local flockmates.
    """
    vx = vy = vz = n = 0.0
    for b in self.flock:
        if b != self and b.near(self, distance):
            vx += b.x
            vy += b.y 
            vz += b.z; n += 1
    # Calculate percentage of flockmates within sight.
    self.crowd = float(n) / (len(self.flock) or 1)
    if n: 
        return (vx/n-self.x), (vy/n-self.y), (vz/n-self.z)
    return vx, vy, vz

</t>
<t tx="karstenw.20240123172908.59">def avoidance(self):
    """ Returns steering velocity (vx,vy,0) to avoid 2D obstacles.
        The boid is not guaranteed to avoid collision.
    """
    vx = vy = 0.0
    self.dodge = False
    for o in self.flock.obstacles:
        dx = o.x - self.x
        dy = o.y - self.y
        d = sqrt(dx**2 + dy**2)     # Distance to obstacle.
        s = (self.sight + o.radius) # Visibility range.
        if d &lt; s:
            self.dodge = True
            # Force grows exponentially from 0.0 to 1.0, 
            # where 1.0 means the boid touches the obstacle circumference.
            f = (d-o.radius) / (s-o.radius)
            f = (1-f)**2
            if d &lt; o.radius:
                f *= 4
                #self.velocity.reverse()
            vx -= dx * f
            vy -= dy * f
    return (vx, vy, 0)
    
</t>
<t tx="karstenw.20240123172908.6">def copy(self):
    k = self.__dict__.copy()
    k.pop("string")
    return Text(self.string, **k)
</t>
<t tx="karstenw.20240123172908.60">def limit(self, speed=10.0):
    """ Limits the boid's velocity (the boid can momentarily go very fast).
    """
    v = self.velocity
    m = max(abs(v.x), abs(v.y), abs(v.z)) or 1
    if abs(v.x) &gt; speed: v.x = v.x / m * speed
    if abs(v.y) &gt; speed: v.y = v.y / m * speed
    if abs(v.z) &gt; speed: v.z = v.z / m * speed

</t>
<t tx="karstenw.20240123172908.61">def update(self, separation=0.2, cohesion=0.2, alignment=0.6, avoidance=0.6, target=0.2, limit=15.0):
    """ Updates the boid's velocity based on the cohesion, separation and alignment forces.
        - separation: force that keeps boids apart.
        - cohesion  : force that keeps boids closer together.
        - alignment : force that makes boids move in the same direction.
        - avoidance : force that steers the boid away from obstacles.
        - target    : force that steers the boid towards a target vector.
        - limit     : maximum velocity.
    """
    f = 0.1
    m1, m2, m3, m4, m5 = separation*f, cohesion*f, alignment*f, avoidance*f, target*f
    vx1, vy1, vz1 = self.separation(self.space)
    vx2, vy2, vz2 = self.cohesion(self.sight)
    vx3, vy3, vz3 = self.alignment(self.sight)
    vx4, vy4, vz4 = self.avoidance()
    vx5, vy5, vz5 = self.target and (
        (self.target.x-self.x), 
        (self.target.y-self.y), 
        (self.target.z-self.z)) or (0,0,0)
    self.velocity.x += m1*vx1 + m2*vx2 + m3*vx3 + m4*vx4 + m5*vx5
    self.velocity.y += m1*vy1 + m2*vy2 + m3*vy3 + m4*vy4 + m5*vy5
    self.velocity.z += m1*vz1 + m2*vz2 + m3*vz3 + m4*vz4 + m5*vz5
    self.velocity.z  = self.flock.depth and self.velocity.z or 0 # No z-axis for Flock.depth=0 
    self.limit(speed=limit)
    self.x += self.velocity.x
    self.y += self.velocity.y
    self.z += self.velocity.z

</t>
<t tx="karstenw.20240123172908.62">def seek(self, vector):
    """ Sets the given Vector as the boid's target.
    """
    self.target = vector
    
</t>
<t tx="karstenw.20240123172908.63">def __repr__(self):
    return "Boid(x=%.1f, y=%.1f, z=%.1f)" % (self.x, self.y, self.z)

</t>
<t tx="karstenw.20240123172908.64">class Obstacle:
    
    @others
</t>
<t tx="karstenw.20240123172908.65">def __init__(self, x=0, y=0, z=0, radius=10):
    """ An obstacle with an (x, y, z) position and a radius.
        Boids will steer around obstacles that the flock is aware of, and that they can see.
    """
    self.x = x
    self.y = y
    self.z = z
    self.radius = radius
    
</t>
<t tx="karstenw.20240123172908.66">def copy(self):
    return Obstacle(self.x, self.y, self.z, self.radius)

</t>
<t tx="karstenw.20240123172908.67">def __repr__(self):
    return "Obstacle(x=%.1f, y=%.1f, z=%.1f, radius=%.1f)" % (self.x, self.y, self.z, self.radius)

</t>
<t tx="karstenw.20240123172908.68">class Flock(list):
    
    @others
flock = Flock

#=== SYSTEM ==========================================================================================
# A computer graphics technique to simulate certain fuzzy phenomena, 
# which are otherwise very hard to reproduce with conventional rendering techniques: 
# fire, explosions, smoke, moving water, sparks, falling leaves, clouds, fog, snow, dust, 
# meteor tails, hair, fur, grass, or abstract visual effects like glowing trails, magic spells.

#--- FORCE -------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172908.69">def __init__(self, amount, x, y, width, height, depth=100.0, obstacles=[]):
    """ A flock of the given amount of boids, confined to a box.
        Obstacles can be added to Flock.obstacles (boids will steer away from them).
    """
    self.x         = x
    self.y         = y
    self.width     = width
    self.height    = height
    self.depth     = depth
    self.scattered = False
    self.gather    = 0.05
    self.obstacles = []
    for i in range(amount):
        # Boids will originate from the center of the flocking area.
        b = Boid(self, 
            self.x + 0.5 * (width  or 0), 
            self.y + 0.5 * (height or 0), 
                     0.5 * (depth  or 0))
        self.append(b)

</t>
<t tx="karstenw.20240123172908.7">def draw(self):
    pass

</t>
<t tx="karstenw.20240123172908.70">@property
def boids(self):
    return self

</t>
<t tx="karstenw.20240123172908.71">def copy(self):
    f = Flock(0, self.x, self.y, self.width, self.height, self.depth)        
    f.scattered = self.scattered
    f.gather    = self.gather
    f.obstacles = [o.copy() for o in self.obstacles]
    for b in self:
        f.append(b.copy())
    return f

</t>
<t tx="karstenw.20240123172908.72">def seek(self, target):
    """ Sets the target vector of all boids in the flock (None for no target).
    """
    for b in self: 
        b.seek(target)

</t>
<t tx="karstenw.20240123172908.73">def sight(self, distance):
    for b in self: 
        b.sight = distance
        
</t>
<t tx="karstenw.20240123172908.74">def space(self, distance):
    for b in self: 
        b.space = distance

</t>
<t tx="karstenw.20240123172908.75">def constrain(self, force=1.0, teleport=False):
    """ Keep the flock inside the rectangular flocking area.
        The given force determines how fast the boids will swivel when near an edge.
        Alternatively, with teleport=True boids that cross a 2D edge teleport to the opposite side.
    """
    f = 5
    def _teleport(b):
        if b.x &lt; self.x:
            b.x = self.x + self.width
        if b.x &gt; self.x + self.width: 
            b.x = self.x
        if b.y &lt; self.y: 
            b.y = self.y + self.height
        if b.y &gt; self.y + self.height:
            b.y = self.y
    def _constrain(b):
        if b.x &lt; self.x:
            b.velocity.x += force * f * random()
        if b.x &gt; self.x + self.width: 
            b.velocity.x -= force * f * random()
        if b.y &lt; self.y: 
            b.velocity.y += force * f * random()
        if b.y &gt; self.y + self.height:
            b.velocity.y -= force * f * random()
    for b in self:
        if b.z &lt; 0: 
            b.velocity.z += force * f * random()
        if b.z &gt; self.depth: 
            b.velocity.z -= force * f * random()
        teleport and _teleport(b) \
                  or _constrain(b)

</t>
<t tx="karstenw.20240123172908.76">def scatter(self, gather=0.05):
    """ Scatters the flock, until Flock.scattered=False.
        Flock.gather is the chance (0.0-1.0, or True/False) that the flock will reunite by itself.
    """
    self.scattered = True
    self.gather = gather

</t>
<t tx="karstenw.20240123172908.77">def update(self, separation=0.2, cohesion=0.2, alignment=0.6, avoidance=0.6, target=0.2, limit=15.0, constrain=1.0, teleport=False):
    """ Updates the boid velocities based on the given forces.
        Different forces elicit different flocking behavior; fine-tuning them can be delicate.
    """
    if self.scattered:
        # When scattered, make the boid cohesion negative and diminish alignment.
        self.scattered = (random() &gt; self.gather)
        cohesion = -0.01
        alignment *= 0.25
    for b in self:
        b.update(separation, cohesion, alignment, avoidance, target, limit)
    self.constrain(force=constrain, teleport=teleport)

</t>
<t tx="karstenw.20240123172908.78">def by_depth(self):
    """ Returns the boids in the flock sorted by depth (z-axis).
    """
    return sorted(self, key=lambda boid: boid.z)

</t>
<t tx="karstenw.20240123172908.79">def __repr__(self):
    return "Flock(%s)" % repr(list(self))

</t>
<t tx="karstenw.20240123172908.8">class Vector(object):
    
    @others
#=====================================================================================================

#--- FLOCKING ----------------------------------------------------------------------------------------
# Boids is an artificial life program, developed by Craig Reynolds in 1986, 
# which simulates the flocking behavior of birds.
# Boids is an example of emergent behavior, the complexity of Boids arises 
# from the interaction of individual agents adhering to a set of simple rules:
# - separation: steer to avoid crowding local flockmates,
# - alignment: steer towards the average heading of local flockmates,
# - cohesion: steer to move toward the average position of local flockmates.
# Unexpected behavior, such as splitting flocks and reuniting after avoiding obstacles, 
# can be considered emergent. The boids framework is often used in computer graphics, 
# providing realistic-looking representations of flocks of birds and other creatures, 
# such as schools of fish or herds of animals.

_UID = 0
</t>
<t tx="karstenw.20240123172908.80">class Force:
    
    @others
force = Force

#--- SPRING ------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172908.81">def __init__(self, particle1, particle2, strength=1.0, threshold=100.0):
    """ An attractive or repulsive force that causes objects with a mass to accelerate.
        A negative strength indicates an attractive force.
    """
    self.particle1 = particle1
    self.particle2 = particle2
    self.strength  = strength
    self.threshold = threshold
            
</t>
<t tx="karstenw.20240123172908.82">def apply(self):
    """ Applies the force between two particles, based on the distance and mass of the particles.
    """
    # Distance has a minimum threshold to keep forces from growing too large,
    # e.g. distance 100 divides force by 10000, distance 5 only by 25.
    # Decreasing the threshold moves particles that are very close to each other away faster.
    dx = self.particle2.x - self.particle1.x
    dy = self.particle2.y - self.particle1.y
    d = sqrt(dx*dx + dy*dy)
    d = max(d, self.threshold)
    # The force between particles increases according to their weight.
    # The force decreases as distance between them increases.
    f = 10.0 * -self.strength * self.particle1.mass * self.particle2.mass
    f = f / (d*d)
    fx = f * dx / d
    fy = f * dy / d
    self.particle1.force.x += fx
    self.particle1.force.y += fy
    self.particle2.force.x -= fx
    self.particle2.force.y -= fy

</t>
<t tx="karstenw.20240123172908.83">def __repr__(self):
    return "Force(strength=%.2f)" % self.strength

</t>
<t tx="karstenw.20240123172908.84">class Spring:
    
    @others
spring = Spring

#--- PARTICLE ----------------------------------------------------------------------------------------

MASS = "mass"

</t>
<t tx="karstenw.20240123172908.85">def __init__(self, particle1, particle2, length, strength=1.0):
    """ A force that exerts attractive resistance when its length changes.
        A spring acts as a flexible (but secure) connection between two particles.
    """
    self.particle1 = particle1
    self.particle2 = particle2
    self.strength  = strength
    self.length    = length
    self.snapped   = False

</t>
<t tx="karstenw.20240123172908.86">def snap(self):
    """ Breaks the connection between the two particles.
    """
    self.snapped = True

</t>
<t tx="karstenw.20240123172908.87">def apply(self):
    """ Applies the force between two particles.
    """
    # Distance between two particles.
    dx = self.particle2.x - self.particle1.x
    dy = self.particle2.y - self.particle1.y
    d = sqrt(dx*dx + dy*dy)
    if d == 0: 
        return
    # The attractive strength decreases for heavy particles.
    # The attractive strength increases when the spring is stretched.
    f = 10.0 * self.strength / (self.particle1.mass * self.particle2.mass)
    f = f * (d - self.length)
    fx = f * dx / d
    fy = f * dy / d
    self.particle1.force.x += fx
    self.particle1.force.y += fy
    self.particle2.force.x -= fx
    self.particle2.force.y -= fy
    
</t>
<t tx="karstenw.20240123172908.88">def draw(self, **kwargs):
    line(self.particle1.x, self.particle1.y, 
         self.particle2.x, self.particle2.y, **kwargs)

</t>
<t tx="karstenw.20240123172908.89">def __repr__(self):
    return "Spring(strength='%.2f', length='%.2f')" % (self.strength, self.length)

</t>
<t tx="karstenw.20240123172908.9">def __init__(self, x=0, y=0, z=0, length=None, angle=None):
    """ A vector represents a direction and a magnitude (or length).
        Vectors can be added, subtracted, multiplied, divided, flipped, and 2D rotated.
        Vectors are used in physics to represent velocity and acceleration.
    """
    self.x = float(x)
    self.y = float(y)
    self.z = float(z)
    if length is not None: 
        self.length = length
    if angle is not None: 
        self.angle = angle

</t>
<t tx="karstenw.20240123172908.90">class Particle:
    
    @others
particle = Particle

#--- SYSTEM ------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172908.91">def __init__(self, x, y, velocity=(0.0,0.0), mass=10.0, radius=10.0, life=None, fixed=False):
    """ An object with a mass subjected to attractive and repulsive forces.
        The object's velocity is an inherent force (e.g. a rocket propeller to escape gravity).
    """
    self._id      = _uid()
    self.x        = x + random()
    self.y        = y + random()
    self.mass     = mass
    self.radius   = radius == MASS and mass or radius
    self.velocity = isinstance(velocity, tuple) and Vector(*velocity) or velocity
    self.force    = Vector(0.0, 0.0) # Force accumulator.
    self.life     = life
    self._age     = 0.0
    self.dead     = False
    self.fixed    = fixed

</t>
<t tx="karstenw.20240123172908.92">@property
def age(self):
    # Yields the particle's age as a number between 0.0 and 1.0.
    return self.life and min(1.0, float(self._age) / self.life) or 0.0

</t>
<t tx="karstenw.20240123172908.93">def draw(self, **kwargs):
    r = self.radius * (1 - self.age)
    ellipse(self.x, self.y, r*2, r*2, **kwargs)
    
</t>
<t tx="karstenw.20240123172908.94">def __eq__(self, other):
    return isinstance(other, Particle) and self._id == other._id
</t>
<t tx="karstenw.20240123172908.95">def __ne__(self, other):
    return not self.__eq__(other)

</t>
<t tx="karstenw.20240123172908.96">def __repr__(self):
    return "Particle(x=%.1f, y=%.1f, radius=%.1f, mass=%.1f)" % (
        self.x, self.y, self.radius, self.mass)

</t>
<t tx="karstenw.20240123172908.97">class flist(list):
    
    @others
</t>
<t tx="karstenw.20240123172908.98">def __init__(self, system):
    # List of forces or springs that keeps System.dynamics in synch.
    self.system = system

</t>
<t tx="karstenw.20240123172908.99">def insert(self, i, force):
    list.insert(self, i, force)
    self.system._dynamics.setdefault(force.particle1._id, []).append(force)
    self.system._dynamics.setdefault(force.particle2._id, []).append(force)
</t>
<t tx="karstenw.20240123172911.1">
__ALL__=["noise"]

from random import random
from math   import floor

</t>
<t tx="karstenw.20240123172911.2">class PerlinNoise:
    
    @others
try:
    # Fast C implementations:
    from nglnoise import init, generate
    PerlinNoise._init = init
    PerlinNoise.generate = generate
    print( "FAST NOISE" )
except Exception as err:
    print( err )
    print( "SLOW NOISE" )
    # pass

_generator = PerlinNoise()
</t>
<t tx="karstenw.20240123172911.3">def __init__(self, permutation=None):
    """ Initializes a Perlin noise generator with the given permutation pattern,
        which is a list of 256 integers between 0-255.
    """
    if not permutation:
        permutation = [random()*256 for i in range(256)]
    self._init([int(x) for x in permutation] * 2)

</t>
<t tx="karstenw.20240123172911.4">def _init(self, p):
    self._p = p
</t>
<t tx="karstenw.20240123172911.5">def _fade(self, t): 
    return t * t * t * (t * (t * 6 - 15) + 10)
</t>
<t tx="karstenw.20240123172911.6">def _lerp(self, t, a, b): 
    return a + t * (b - a)
</t>
<t tx="karstenw.20240123172911.7">def _grad(self, hash, x, y, z):
    u, v, h = x, y, hash &amp; 15 
    if h &gt;= 8: u = y
    if h &gt;= 4:
        v = x
        if h != 12 and h != 14: v = z
    if (h&amp;1) != 0: u = -u
    if (h&amp;2) != 0: v = -v
    return u + v

</t>
<t tx="karstenw.20240123172911.8">def generate(self, x, y=0, z=0):
    """ Returns a smooth value between -1.0 and 1.0.
        The x, y, z parameters determine the coordinates in the noise landscape. 
        Since the landscape is infinite, the actual value of a coordinate doesn't matter, 
        only the distance between successive steps. 
        The smaller the difference between steps, the smoother the noise sequence. 
        Steps between 0.005 and 0.1 usually work best.
    """
    lerp, grad, fade, p = self._lerp, self._grad, self._fade, self._p
    # Find unit cuve that contains point (x,y,z).
    X = int(floor(x)) &amp; 255
    Y = int(floor(y)) &amp; 255
    Z = int(floor(z)) &amp; 255
    # Find relative (x,y,z) of point in cube.
    # Compute fade curves.
    x, y, z = x-floor(x), y-floor(y), z-floor(z)
    u, v, w = fade(x), fade(y), fade(z)
    # Hash coordinates of the cube corners.
    A = Y + p[X]
    B = Y + p[X+1]
    AA, AB, BA, BB = Z+p[A], Z+p[A+1], Z+p[B], Z+p[B+1]
    # Add blended results from the cube corners.
    return lerp(w, 
        lerp(v, lerp(u, grad(p[AA  ], x  , y  , z  ), 
                        grad(p[BA  ], x-1, y  , z  )),
                lerp(u, grad(p[AB  ], x  , y-1, z  ), 
                        grad(p[BB  ], x-1, y-1, z  ))),
        lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1), 
                        grad(p[BA+1], x-1, y  , z-1)),
                lerp(u, grad(p[AB+1], x  , y-1, z-1), 
                        grad(p[BB+1], x-1, y-1, z-1))))

</t>
<t tx="karstenw.20240123172911.9">def noise(x, y=0, z=0):
    return _generator.generate(x, y, z)
</t>
<t tx="karstenw.20240123172914.1">#=== SHADER ==========================================================================================
# 2D geometry functions.
# Authors: Tom De Smedt
# License: BSD (see LICENSE.txt for details).
# Copyright (c) 2008-2012 City In A Bottle (cityinabottle.org)
# http://cityinabottle.org/nodebox

from math import sqrt, pow
from math import sin, cos, atan2, degrees, radians, pi

INFINITE = 1e15 # float("inf") doesn't work on windows.

#=====================================================================================================

#--- ROTATION ----------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172914.10">def clamp(v, a, b):
    return max(a, min(v, b))
    
# Fast C implementations:
try:
    from nglgeometry import smoothstep
    print( "FAST SMOOTHSTEP" )
except Exception as err:
    print( err )
    print( "SLOW SMOOTHSTEP" )
    # pass

#--- INTERSECTION ------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172914.11">def line_line_intersection(x1, y1, x2, y2, x3, y3, x4, y4, infinite=False):
    """ Determines the intersection point of two lines, or two finite line segments if infinite=False.
        When the lines do not intersect, returns an empty list.
    """
    # Based on: P. Bourke, http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/
    ua = (x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)
    ub = (x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)
    d  = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
    if d == 0:
        if ua == ub == 0:
            # The lines are coincident
            return []
        else:
            # The lines are parallel.
            return []
    ua /= float(d)
    ub /= float(d)
    if not infinite and not (0&lt;=ua&lt;=1 and 0&lt;=ub&lt;=1):
        # Intersection point is not within both line segments.
        return None, None
    return [(x1+ua*(x2-x1), y1+ua*(y2-y1))]
    
</t>
<t tx="karstenw.20240123172914.12">def circle_line_intersection(cx, cy, radius, x1, y1, x2, y2, infinite=False):
    """ Returns a list of points where the circle and the line intersect.
        Returns an empty list when the circle and the line do not intersect.
    """	
    # Based on: http://www.vb-helper.com/howto_net_line_circle_intersections.html
    dx = x2-x1
    dy = y2-y1
    A = dx*dx + dy*dy
    B = 2 * (dx*(x1-cx) + dy*(y1-cy))
    C = pow(x1-cx, 2) + pow(y1-cy, 2) - radius*radius
    det = B*B - 4*A*C
    if A &lt;= 0.0000001 or det &lt; 0: 
        return []
    elif det == 0:
        # One point of intersection.
        t = -B / (2*A)
        return [(x1+t*dx, y1+t*dy)]
    else:
        # Two points of intersection.
        # A point of intersection lies on the line segment if 0 &lt;= t &lt;= 1,
        # and on an extension of the segment otherwise.
        points = []
        det2 = sqrt(det)
        t1 = (-B+det2) / (2*A)
        t2 = (-B-det2) / (2*A)
        if infinite or 0 &lt;= t1 &lt;= 1: points.append((x1+t1*dx, y1+t1*dy))  
        if infinite or 0 &lt;= t2 &lt;= 1: points.append((x1+t2*dx, y1+t2*dy))
        return points

</t>
<t tx="karstenw.20240123172914.13">def intersection(*args, **kwargs):
    if len(args) == 8:
        return line_line_intersection(*args, **kwargs)
    if len(args) == 7:
        return circle_line_intersection(*args, **kwargs)

</t>
<t tx="karstenw.20240123172914.14">def point_in_polygon(points, x, y):
    """ Ray casting algorithm.
        Determines how many times a horizontal ray starting from the point 
        intersects with the sides of the polygon. 
        If it is an even number of times, the point is outside, if odd, inside.
        The algorithm does not always report correctly when the point is very close to the boundary.
        The polygon is passed as a list of (x,y)-tuples.
    """
    odd = False
    n = len(points)
    for i in range(n):
        j = i&lt;n-1 and i+1 or 0
        x0, y0 = points[i][0], points[i][1]
        x1, y1 = points[j][0], points[j][1]
        if (y0 &lt; y and y1 &gt;= y) or (y1 &lt; y and y0 &gt;= y):
            if x0 + (y-y0) / (y1-y0) * (x1-x0) &lt; x:
                odd = not odd
    return odd

#=====================================================================================================

#--- AFFINE TRANSFORM --------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172914.15">def superformula(m, n1, n2, n3, phi):
    """ A generalization of the superellipse first proposed by Johan Gielis.
        It can be used to describe many complex shapes and curves that are found in nature.
    """
    if n1 == 0: 
        return (0,0)
    a = 1.0
    b = 1.0
    r = pow(pow(abs(cos(m * phi/4) / a), n2) + \
            pow(abs(sin(m * phi/4) / b), n3), 1/n1)
    if abs(r) == 0:
        return (0,0)
    r = 1 / r
    return (r*cos(phi), r*sin(phi))

# Fast C implementation:
try:
    from nglgeometry import superformula
    # print "FAST GEOMETRY"
except Exception as err:
    # print err
    # print "SLOW GEOMETRY"
    pass

#=====================================================================================================

#--- AFFINE TRANSFORM --------------------------------------------------------------------------------
# Based on http://www.senocular.com/flash/tutorials/transformmatrix/

</t>
<t tx="karstenw.20240123172914.16">class AffineTransform:
    
    @others
Transform = AffineTransform

#=====================================================================================================

#--- POINT -------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172914.17">def __init__(self, transform=None):
    """ A geometric transformation in Euclidean space (i.e. 2D)
        that preserves collinearity and ratio of distance between points.
        Linear transformations include rotation, translation, scaling, shear.
    """
    if isinstance(transform, AffineTransform):
        self.matrix = list(transform.matrix)
    else:
        self.matrix = self.identity
        
</t>
<t tx="karstenw.20240123172914.18">def copy(self):
    return AffineTransform(self)

</t>
<t tx="karstenw.20240123172914.19">def prepend(self, transform):
    self.matrix = self._mmult(self.matrix, transform.matrix)        
</t>
<t tx="karstenw.20240123172914.2">def angle(x0, y0, x1, y1):
    """ Returns the angle between two points.
    """
    return degrees(atan2(y1-y0, x1-x0))

</t>
<t tx="karstenw.20240123172914.20">def append(self, transform):
    self.matrix = self._mmult(transform.matrix, self.matrix)
    
concat = append

</t>
<t tx="karstenw.20240123172914.21">def _mmult(self, a, b):
    """ Returns the 3x3 matrix multiplication of A and B.
        Note that scale(), translate(), rotate() work with premultiplication,
        e.g. the matrix A followed by B = BA and not AB.
    """
    # No need to optimize (C version is just as fast).
    return [
        a[0]*b[0] + a[1]*b[3], 
        a[0]*b[1] + a[1]*b[4], 
        0,
        a[3]*b[0] + a[4]*b[3], 
        a[3]*b[1] + a[4]*b[4], 
        0,
        a[6]*b[0] + a[7]*b[3] + b[6], 
        a[6]*b[1] + a[7]*b[4] + b[7], 
        1
    ]
          
</t>
<t tx="karstenw.20240123172914.22">def invert(self):
    """ Multiplying a matrix by its inverse produces the identity matrix.
    """
    m = self.matrix
    d = m[0]*m[4] - m[1]*m[3]
    self.matrix = [
         m[4]/d, -m[1]/d, 0,
        -m[3]/d,  m[0]/d, 0,
         (m[3]*m[7]-m[4]*m[6])/d,
        -(m[0]*m[7]-m[1]*m[6])/d, 
         1
    ]

</t>
<t tx="karstenw.20240123172914.23">@property
def inverse(self):
    m = self.copy(); m.invert(); return m;

</t>
<t tx="karstenw.20240123172914.24">@property
def identity(self):
    return [1,0,0, 0,1,0, 0,0,1]
    
</t>
<t tx="karstenw.20240123172914.25">@property
def rotation(self):
    return (degrees(atan2(self.matrix[1], self.matrix[0])) + 360) % 360 # 0.0 =&gt; 360.0
    
</t>
<t tx="karstenw.20240123172914.26">def scale(self, x, y=None):
    if y==None: y = x
    self.matrix = self._mmult([x,0,0, 0,y,0, 0,0,1], self.matrix)

</t>
<t tx="karstenw.20240123172914.27">def translate(self, x, y):
    self.matrix = self._mmult([1,0,0, 0,1,0, x,y,1], self.matrix)

</t>
<t tx="karstenw.20240123172914.28">def rotate(self, degrees=0, radians=0):
    radians = degrees and degrees*pi/180 or radians
    c = cos(radians)
    s = sin(radians)
    self.matrix = self._mmult([c,s,0, -s,c,0, 0,0,1], self.matrix)

</t>
<t tx="karstenw.20240123172914.29">def transform_point(self, x, y):
    """ Returns the new coordinates of (x,y) after transformation.
    """
    m = self.matrix
    return (x*m[0]+y*m[3]+m[6], x*m[1]+y*m[4]+m[7])
    
apply = transform_point

</t>
<t tx="karstenw.20240123172914.3">def distance(x0, y0, x1, y1):
    """ Returns the distance between two points.
    """
    return sqrt(pow(x1-x0, 2) + pow(y1-y0, 2))

</t>
<t tx="karstenw.20240123172914.30">def transform_path(self, path):
    """ Returns a BezierPath object with the transformation applied.
    """
    p = path.__class__() # Create a new BezierPath.
    for pt in path:
        if pt.cmd == "close":
            p.closepath()
        elif pt.cmd == "moveto":
            p.moveto(*self.apply(pt.x, pt.y))
        elif pt.cmd == "lineto":
            p.lineto(*self.apply(pt.x, pt.y))
        elif pt.cmd == "curveto":
            vx1, vy1 = self.apply(pt.ctrl1.x, pt.ctrl1.y)
            vx2, vy2 = self.apply(pt.ctrl2.x, pt.ctrl2.y)
            x, y = self.apply(pt.x, pt.y)
            p.curveto(vx1, vy1, vx2, vy2, x, y)
    return p

# Compatibility with NodeBox.
transformPoint = transform_point
transformBezierPath = transform_path

</t>
<t tx="karstenw.20240123172914.31">def map(self, points):
    return [self.apply(*pt) for pt in points]

</t>
<t tx="karstenw.20240123172914.32">class Point(object):
    
    @others
#--- BOUNDS ------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172914.33">def __init__(self, x=0, y=0):
    self.x = x
    self.y = y

</t>
<t tx="karstenw.20240123172914.34">def _get_xy(self):
    return (self.x, self.y)
# (x,y)
</t>
<t tx="karstenw.20240123172914.35">def _set_xy(self, doublet):
    x,y = doublet
    self.x = x
    self.y = y
    
xy = property(_get_xy, _set_xy)

</t>
<t tx="karstenw.20240123172914.36">def __iter__(self):
    return iter((self.x, self.y))

</t>
<t tx="karstenw.20240123172914.37">def __repr__(self):
    return "Point(x=%.1f, y=%.1f)" % (self.x, self.y)
    
</t>
<t tx="karstenw.20240123172914.38">def __eq__(self, pt):
    if not isinstance(pt, Point): return False
    return self.x == pt.x \
       and self.y == pt.y

</t>
<t tx="karstenw.20240123172914.39">def __ne__(self, pt):
    return not self.__eq__(pt)

</t>
<t tx="karstenw.20240123172914.4">def coordinates(x0, y0, distance, angle):
    """ Returns the location of a point by rotating around origin (x0,y0).
    """
    return (x0 + cos(radians(angle)) * distance,
            y0 + sin(radians(angle)) * distance)

</t>
<t tx="karstenw.20240123172914.40">class Bounds:
    
    @others
#=====================================================================================================

#--- TESSELLATION ------------------------------------------------------------------------------------
# OpenGL can only display simple convex polygons directly.
# A polygon is simple if the edges intersect only at vertices, there are no duplicate vertices, 
# and exactly two edges meet at any vertex. 
# Polygons containing holes or polygons with intersecting edges must first be subdivided 
# into simple convex polygons before they can be displayed.
# Such subdivision is called tessellation.

# Algorithm adopted from Squirtle:
#
#  Copyright (c) 2008 Martin O'Leary. 
#
#  All rights reserved.  
#
#  Redistribution and use in source and binary forms, with or without modification, 
#  are permitted provided that the following conditions are met:   
#  * Redistributions of source code must retain the above copyright notice, 
#    this list of conditions and the following disclaimer. 
#  * Redistributions in binary form must reproduce the above copyright notice, 
#    this list of conditions and the following disclaimer in the documentation 
#    and/or other materials provided with the distribution. 
#  * Neither the name(s) of the copyright holders nor the names of its contributors may be used to 
#    endorse or promote products derived from this software without specific prior written permission.  
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
#  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, 
#  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
#  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from sys import platform
from ctypes import CFUNCTYPE, POINTER, byref, cast, pointer
from ctypes import CFUNCTYPE as _CFUNCTYPE

from pyglet.gl import \
    GLdouble, GLvoid, GLenum, GLfloat, \
    gluNewTess, gluTessProperty, gluTessNormal, gluTessCallback, gluTessVertex, \
    gluTessBeginPolygon, gluTessEndPolygon, \
    gluTessBeginContour, gluTessEndContour, \
    GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO, \
    GLU_TESS_VERTEX, GLU_TESS_BEGIN, GLU_TESS_END, GLU_TESS_ERROR, GLU_TESS_COMBINE, \
    GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, GL_TRIANGLES, GL_LINE_LOOP

if platform == "win32":
    from ctypes import WINFUNCTYPE as CFUNCTYPE

_tessellator = gluNewTess()

# Winding rule determines the regions that should be filled and those that should remain unshaded.
# Winding direction is determined by the normal.
gluTessProperty(_tessellator, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO)
gluTessNormal(_tessellator, 0, 0, 1)

# As tessellation proceeds, callback routines are called in a manner 
# similar to OpenGL commands glBegin(), glEdgeFlag*(), glVertex*(), and glEnd().
# The callback functions must be C functions so we need to cast our Python callbacks to C.
_tessellate_callback_type = {
    GLU_TESS_VERTEX  : CFUNCTYPE(None, POINTER(GLvoid)),
    GLU_TESS_BEGIN   : CFUNCTYPE(None, GLenum),
    GLU_TESS_END     : CFUNCTYPE(None),
    GLU_TESS_ERROR   : CFUNCTYPE(None, GLenum),
    GLU_TESS_COMBINE : CFUNCTYPE(None, 
        POINTER(GLdouble), 
        POINTER(POINTER(GLvoid)), 
        POINTER(GLfloat), 
        POINTER(POINTER(GLvoid))) 
}

# One path with a 100 points is somewhere around 15KB.
TESSELLATION_CACHE = 100

</t>
<t tx="karstenw.20240123172914.41">def __init__(self, x, y, width, height):
    """ Creates a bounding box.
        The bounding box is an untransformed rectangle that encompasses a shape or group of shapes.
    """
    # context.Layer does not always have a width or height defined (i.e. infinite layer):
    if width == None: width = INFINITE
    if height == None: height = INFINITE
    # Normalize if width or height is negative:
    if width &lt; 0: x, width = x+width,  -width
    if height &lt; 0: y, height = y+height, -height
    self.x = x
    self.y = y
    self.width = width 
    self.height = height

</t>
<t tx="karstenw.20240123172914.42">def copy(self):
    return Bounds(self.x, self.y, self.width, self.height)

</t>
<t tx="karstenw.20240123172914.43">def __iter__(self):
    """ You can conveniently unpack bounds: x,y,w,h = Bounds(0,0,100,100)
    """
    return iter((self.x, self.y, self.width, self.height))

</t>
<t tx="karstenw.20240123172914.44">def intersects(self, b):
    """ Return True if a part of the two bounds overlaps.
    """
    return max(self.x, b.x) &lt; min(self.x+self.width, b.x+b.width) \
       and max(self.y, b.y) &lt; min(self.y+self.height, b.y+b.height)

</t>
<t tx="karstenw.20240123172914.45">def intersection(self, b):
    """ Returns bounds that encompass the intersection of the two.
        If there is no overlap between the two, None is returned.
    """
    if not self.intersects(b): 
        return None
    mx, my = max(self.x, b.x), max(self.y, b.y)
    return Bounds(mx, my, 
        min(self.x+self.width, b.x+b.width) - mx, 
        min(self.y+self.height, b.y+b.height) - my)

</t>
<t tx="karstenw.20240123172914.46">def union(self, b):
    """ Returns bounds that encompass the union of the two.
    """
    # Note: this will also work with ghost points.
    # Bounds(20, 20, 5, 5).union(Bounds(100, 100, 0, 0)) =&gt; Bounds(20, 20, 100, 100). 
    mx, my = min(self.x, b.x), min(self.y, b.y)
    return Bounds(mx, my, 
        max(self.x+self.width, b.x+b.width) - mx, 
        max(self.y+self.height, b.y+b.height) - my)

</t>
<t tx="karstenw.20240123172914.47">def contains(self, *a):
    """ Returns True if the given point or rectangle falls within the bounds.
    """
    if len(a) == 2: a = [Point(a[0], a[1])]
    if len(a) == 1:
        a = a[0]
        if isinstance(a, Point):
            return a.x &gt;= self.x and a.x &lt;= self.x+self.width \
               and a.y &gt;= self.y and a.y &lt;= self.y+self.height
        if isinstance(a, Bounds):
            return a.x &gt;= self.x and a.x+a.width &lt;= self.x+self.width \
               and a.y &gt;= self.y and a.y+a.height &lt;= self.y+self.height
        
</t>
<t tx="karstenw.20240123172914.48">def __eq__(self, b):
    if not isinstance(b, Bounds): 
        return False
    return (    self.x == b.x
            and self.y == b.y
            and self.width == b.width
            and self.height == b.height )

</t>
<t tx="karstenw.20240123172914.49">def __ne__(self, b):
    return not self.__eq__(b)

</t>
<t tx="karstenw.20240123172914.5">def rotate(x, y, x0, y0, angle):
    """ Returns the coordinates of (x,y) rotated around origin (x0,y0).
    """
    x, y = x-x0, y-y0
    a, b = cos(radians(angle)), sin(radians(angle))
    return (x*a-y*b+x0, y*a+x*b+y0)

</t>
<t tx="karstenw.20240123172914.50">def __repr__(self):
    return "Bounds(%.1f, %.1f, %.1f, %.1f)" % (self.x, self.y, self.width, self.height)

</t>
<t tx="karstenw.20240123172914.51">class TessellationError(Exception):
    pass

</t>
<t tx="karstenw.20240123172914.52">class Tessellate(list):
    """ Tessellation state that stores data from the callback functions
        while tessellate() is processing.
    """
    @others
_tessellate = Tessellate()

</t>
<t tx="karstenw.20240123172914.53">def __init__(self): 
    self.cache = {}         # Cache of previously triangulated contours
    self.queue = []         # Latest contours appear at the end of the list.
    self.reset()
</t>
<t tx="karstenw.20240123172914.54">def clear(self):
    list.__init__(self, []) # Populated during _tessellate_vertex().
</t>
<t tx="karstenw.20240123172914.55">def reset(self):
    self.clear()
    self.mode      = None   # GL_TRIANGLE_FAN | GL_TRIANGLE_STRIP | GL_TRIANGLES.
    self.triangles = []     # After tessellation, contains lists of (x,y)-vertices,
    self._combined = []     # which can be drawn with glBegin(GL_TRIANGLES) mode.

</t>
<t tx="karstenw.20240123172914.56">def _tessellate_callback(type):
    # Registers a C version of a Python callback function for gluTessCallback().
    def _C(function):
        f = _tessellate_callback_type[type](function)
        gluTessCallback(_tessellator, type, cast(f, _CFUNCTYPE(None)))
        return f
    return _C

</t>
<t tx="karstenw.20240123172914.57">@_tessellate_callback(GLU_TESS_BEGIN)
def _tessellate_begin(mode):
    # Called to indicate the start of a triangle.
    _tessellate.mode = mode
    
</t>
<t tx="karstenw.20240123172914.58">@_tessellate_callback(GLU_TESS_VERTEX)
def _tessellate_vertex(vertex):
    # Called to define the vertices of triangles created by the tessellation.
    _tessellate.append(list(cast(vertex, POINTER(GLdouble))[0:2]))

</t>
<t tx="karstenw.20240123172914.59">@_tessellate_callback(GLU_TESS_END)
def _tessellate_end():
    # Called to indicate the end of a primitive.
    # GL_TRIANGLE_FAN defines triangles with a same origin (pt1).
    if _tessellate.mode in (GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP):
        pt1 = _tessellate.pop(0)
        pt2 = _tessellate.pop(0)
        while _tessellate:
            pt3 = _tessellate.pop(0)
            _tessellate.triangles.extend([pt1, pt2, pt3])
            if _tessellate.mode == GL_TRIANGLE_STRIP: 
                pt1 = pt2
            pt2 = pt3
    elif _tessellate.mode == GL_TRIANGLES:
        _tessellate.triangles.extend(_tessellate)
    elif _tessellate.mode == GL_LINE_LOOP:
        pass
    _tessellate.mode  = None
    _tessellate.clear()
    
</t>
<t tx="karstenw.20240123172914.6">def reflect(x, y, x0, y0, d=1.0, a=180):
    """ Returns the reflection of a point through origin (x0,y0).
    """
    return coordinates(x0, y0, d*distance(x0,y0,x,y), a+angle(x0,y0,x,y))
    
# Fast C implementations:
try:
    from nglgeometry import angle, distance, coordinates, rotate
    print( "FAST GEOMETRY" )
except Exception as err:
    print( err )
    print( "SLOW GEOMETRY" )
    # pass

#--- INTERPOLATION -----------------------------------------------------------------------------------
    
</t>
<t tx="karstenw.20240123172914.60">@_tessellate_callback(GLU_TESS_COMBINE)
def _tessellate_combine(coords, vertex_data, weights, dataOut):
    # Called when the tessellation detects an intersection.
    x, y, z = coords[0:3]
    data = (GLdouble * 3)(x, y, z)
    dataOut[0] = cast(pointer(data), POINTER(GLvoid))
    _tessellate._combined.append(data)
    
</t>
<t tx="karstenw.20240123172914.61">@_tessellate_callback(GLU_TESS_ERROR)
def _tessellate_error(code):
    # Called when an error occurs.
    e, s, i = gluErrorString(code), "", 0
    while e[i]: 
        s += chr(e[i])
        i += 1
    raise TessellationError( s )

_cache = {}

</t>
<t tx="karstenw.20240123172914.62">def tessellate(contours):
    """ Returns a list of triangulated (x,y)-vertices from the given list of path contours,
        where each contour is a list of (x,y)-tuples.
        The vertices can be drawn with GL_TRIANGLES to render a complex polygon, for example:
        glBegin(GL_TRIANGLES)
        for x, y in tessellate(contours):
            glVertex3f(x, y, 0)
        glEnd()
    """
    id = repr(contours)
    if id in _tessellate.cache:
        return _tessellate.cache[id]
    # Push the given contours to C and call gluTessVertex().
    _tessellate.reset()
    contours = [[(GLdouble * 3)(x, y, 0) for x, y in points] for points in contours]
    gluTessBeginPolygon(_tessellator, None)
    for vertices in contours:
        gluTessBeginContour(_tessellator)
        for v in vertices:
            gluTessVertex(_tessellator, v, v)
        gluTessEndContour(_tessellator)
    gluTessEndPolygon(_tessellator)
    # Update the tessellation cache with the results.
    if len(_tessellate.cache) &gt; TESSELLATION_CACHE:
        del _tessellate.cache[_tessellate.queue.pop(0)]
    _tessellate.queue.append(id)
    _tessellate.cache[id] = _tessellate.triangles
    return _tessellate.triangles
    
tesselate = tessellate # Common spelling error.
</t>
<t tx="karstenw.20240123172914.7">def lerp(a, b, t):
    """ Returns the linear interpolation between a and b for time t between 0.0-1.0.
        For example: lerp(100, 200, 0.5) =&gt; 150.
    """
    if t &lt; 0.0:
        return a
    if t &gt; 1.0:
        return b
    return a + (b-a)*t
    
</t>
<t tx="karstenw.20240123172914.8">def smoothstep(a, b, x):
    """ Returns a smooth transition between 0.0 and 1.0 using Hermite interpolation (cubic spline),
        where x is a number between a and b. The return value will ease (slow down) as x nears a or b.
        For x smaller than a, returns 0.0. For x bigger than b, returns 1.0.
    """
    if x &lt; a:
        return 0.0
    if x &gt;=b:
        return 1.0
    x = float(x-a) / (b-a)
    return x*x * (3-2*x)

</t>
<t tx="karstenw.20240123172914.9">def bounce(x):
    """ Returns a bouncing value between 0.0 and 1.0 (e.g. Mac OS X Dock) for a value between 0.0-1.0.
    """
    return abs(sin(2*pi * (x+1) * (x+1)) * (1-x))

</t>
<t tx="karstenw.20240123172917.1">#=== CONTEXT =========================================================================================
# 2D NodeBox API in OpenGL.
# Authors: Tom De Smedt, Frederik De Bleser
# License: BSD (see LICENSE.txt for details).
# Copyright (c) 2008-2012 City In A Bottle (cityinabottle.org)
# http://cityinabottle.org/nodebox

# All graphics are drawn directly to the screen.
# No scenegraph is kept for obvious performance reasons (therefore, no canvas._grobs as in NodeBox).

# Debugging must be switched on or of before other modules are imported.

import pickle

import pyglet
pyglet.options['debug_gl'] = False

from pyglet.gl      import *

from pyglet.image import Texture
from math         import cos, sin, radians, pi, floor
from time         import time
from random       import seed, choice, shuffle, random as rnd

# from new          import instancemethod
from types        import MethodType as instancemethod

from glob         import glob
from os           import path, remove
from sys          import getrefcount
from io           import StringIO
from hashlib      import md5
from types        import FunctionType
from datetime     import datetime
from numbers      import Number

from . import geometry

try:
    basestring
except NameError:
    basestring = str


</t>
<t tx="karstenw.20240123172917.10">def _get_g(self): return self[1]
</t>
<t tx="karstenw.20240123172917.100">def copy(self):
    return BezierPath(self, **self._kwargs)

</t>
<t tx="karstenw.20240123172917.101">def append(self, pt):
    self._dirty = True; list.append(self, pt)
</t>
<t tx="karstenw.20240123172917.102">def extend(self, points):
    self._dirty = True; list.extend(self, points)
</t>
<t tx="karstenw.20240123172917.103">def insert(self, i, pt):
    self._dirty = True; self._index={}; list.insert(self, i, pt)
</t>
<t tx="karstenw.20240123172917.104">def remove(self, pt):
    self._dirty = True; self._index={}; list.remove(self, pt)
</t>
<t tx="karstenw.20240123172917.105">def pop(self, i):
    self._dirty = True; self._index={}; list.pop(self, i)
</t>
<t tx="karstenw.20240123172917.106">def __setitem__(self, i, pt):
    self._dirty = True; self._index={}; list.__setitem__(self, i, pt)
</t>
<t tx="karstenw.20240123172917.107">def __delitem__(self, i):
    self._dirty = True; self._index={}; list.__delitem__(self, i)
</t>
<t tx="karstenw.20240123172917.108">def sort(self):
    self._dirty = True; self._index={}; list.sort(self)
</t>
<t tx="karstenw.20240123172917.109">def reverse(self):
    self._dirty = True; self._index={}; list.reverse(self)
</t>
<t tx="karstenw.20240123172917.11">def _get_b(self): return self[2]
</t>
<t tx="karstenw.20240123172917.110">def index(self, pt):
    return self._index.setdefault(pt, list.index(self, pt))

</t>
<t tx="karstenw.20240123172917.111">def _update(self):
    # Called from BezierPath.draw().
    # If points were added or removed, clear the cache.
    b = self._dirty
    for pt in self: b = b or pt._dirty; pt._dirty = False
    if b:
        if self._cache is not None:
            if self._cache[0]: flush(self._cache[0])
            if self._cache[1]: flush(self._cache[1])
        self._cache = self._segments = self._bounds = self._polygon = None
        self._dirty = False

</t>
<t tx="karstenw.20240123172917.112">def moveto(self, x, y):
    """ Adds a new point to the path at x, y.
    """
    self.append(PathElement(MOVETO, ((x, y),)))

</t>
<t tx="karstenw.20240123172917.113">def lineto(self, x, y):
    """ Adds a line from the previous point to x, y.
    """
    self.append(PathElement(LINETO, ((x, y),)))
    
</t>
<t tx="karstenw.20240123172917.114">def curveto(self, x1, y1, x2, y2, x3, y3):
    """ Adds a Bezier-curve from the previous point to x3, y3.
        The curvature is determined by control handles x1, y1 and x2, y2.
    """
    self.append(PathElement(CURVETO, ((x1, y1), (x2, y2), (x3, y3))))

</t>
<t tx="karstenw.20240123172917.115">def arcto(self, x, y, radius=1, clockwise=True, short=False):
    """ Adds a number of Bezier-curves that draw an arc with the given radius to (x,y).
        The short parameter selects either the "long way" around or the "shortcut".
    """
    x0, y0 = self[-1].x, self[-1].y
    phi = geometry.angle(x0,y0,x,y)
    for p in bezier.arcto(x0, y0, radius, radius, phi, short, not clockwise, x, y):
        f = len(p) == 2 and self.lineto or self.curveto
        f(*p)

</t>
<t tx="karstenw.20240123172917.116">def closepath(self):
    """ Adds a line from the previous point to the last MOVETO.
    """
    self.append(PathElement(CLOSE))

</t>
<t tx="karstenw.20240123172917.117">def rect(self, x, y, width, height, roundness=0.0):
    """ Adds a (rounded) rectangle to the path.
        Corner roundness can be given as a relative float or absolute int.
    """
    if roundness &lt;= 0:
        self.moveto(x, y)
        self.lineto(x+width, y)
        self.lineto(x+width, y+height)
        self.lineto(x, y+height)
        self.lineto(x, y)
    else:
        if isinstance(roundness, int):
            r = min(roundness, width/2, height/2)
        else:
            r = min(width, height)
            r = min(roundness, 1) * r * 0.5
        self.moveto(x+r, y)
        self.lineto(x+width-r, y)
        self.arcto(x+width, y+r, radius=r, clockwise=False)
        self.lineto(x+width, y+height-r)
        self.arcto(x+width-r, y+height, radius=r, clockwise=False)
        self.lineto(x+r, y+height)
        self.arcto(x, y+height-r, radius=r, clockwise=False)
        self.lineto(x, y+r)
        self.arcto(x+r, y, radius=r, clockwise=False)

</t>
<t tx="karstenw.20240123172917.118">def ellipse(self, x, y, width, height):
    """ Adds an ellipse to the path.
    """
    w, h = width*0.5, height*0.5
    k = 0.5522847498    # kappa: (-1 + sqrt(2)) / 3 * 4
    self.moveto(x, y-h) # http://www.whizkidtech.redprince.net/bezier/circle/
    self.curveto(x+w*k, y-h,   x+w,   y-h*k, x+w, y, )
    self.curveto(x+w,   y+h*k, x+w*k, y+h,   x,   y+h)
    self.curveto(x-w*k, y+h,   x-w,   y+h*k, x-w, y, )
    self.curveto(x-w,   y-h*k, x-w*k, y-h,   x,   y-h)
    self.closepath()
    
oval = ellipse

</t>
<t tx="karstenw.20240123172917.119">def arc(self, x, y, width, height, start=0, stop=90):
    """ Adds an arc to the path.
        The arc follows the ellipse defined by (x, y, width, height),
        with start and stop specifying what angle range to draw.
    """
    w, h = width*0.5, height*0.5
    for i, p in enumerate(bezier.arc(x-w, y-h, x+w, y+h, start, stop)):
        if i == 0:
            self.moveto(*p[:2])
        self.curveto(*p[2:])

</t>
<t tx="karstenw.20240123172917.12">def _get_a(self): return self[3]

</t>
<t tx="karstenw.20240123172917.120">def smooth(self, *args, **kwargs):
    """ Smooths the path by making the curve handles colinear.
        With mode=EQUIDISTANT, the curve handles will be of equal (average) length.
    """
    e = BezierEditor(self)
    for i, pt in enumerate(self):
        self._index[pt] = i
        e.smooth(pt, *args, **kwargs)

</t>
<t tx="karstenw.20240123172917.121">def flatten(self, precision=RELATIVE):
    """ Returns a list of contours, in which each contour is a list of (x,y)-tuples.
        The precision determines the number of straight lines to use as a substition for a curve.
        It can be a fixed number (int) or relative to the curve length (float or RELATIVE).
    """
    if precision == RELATIVE:
        precision = RELATIVE_PRECISION
    contours = [[]]
    x0, y0 = None, None
    closeto = None
    for pt in self:
        if (pt.cmd == LINETO or pt.cmd == CURVETO) and x0 == y0 is None:
            raise NoCurrentPointForPath()
        elif pt.cmd == LINETO:
            contours[-1].append((x0, y0))
            contours[-1].append((pt.x, pt.y))
        elif pt.cmd == CURVETO:
            # Curves are interpolated from a number of straight line segments.
            # With relative precision, we use the (rough) curve length to determine the number of lines.
            x1, y1, x2, y2, x3, y3 =  pt.ctrl1.x, pt.ctrl1.y, pt.ctrl2.x, pt.ctrl2.y, pt.x, pt.y
            if isinstance(precision, float):
                n = int(max(0, precision) * bezier.curvelength(x0, y0, x1, y1, x2, y2, x3, y3, 3))
            else:
                n = int(max(0, precision))
            if n &gt; 0:
                xi, yi = x0, y0
                for i in range(n+1):
                    xj, yj, vx1, vy1, vx2, vy2 = bezier.curvepoint(float(i)/n, x0, y0, x1, y1, x2, y2, x3, y3)
                    contours[-1].append((xi, yi))
                    contours[-1].append((xj, yj))
                    xi, yi = xj, yj
        elif pt.cmd == MOVETO:
            contours.append([]) # Start a new contour.
            closeto = pt
        elif pt.cmd == CLOSE and closeto is not None:
            contours[-1].append((x0, y0))
            contours[-1].append((closeto.x, closeto.y))
        x0, y0 = pt.x, pt.y
    return contours

</t>
<t tx="karstenw.20240123172917.122">def draw(self, precision=RELATIVE, **kwargs):
    """ Draws the path.
        The precision determines the number of straight lines to use as a substition for a curve.
        It can be a fixed number (int) or relative to the curve length (float or RELATIVE).
    """
    if len(kwargs) &gt; 0:
        # Optional parameters in draw() overrule those set during initialization. 
        kw = dict(self._kwargs)
        kw.update(kwargs)
        fill, stroke, strokewidth, strokestyle = color_mixin(**kw)
    else:
        fill, stroke, strokewidth, strokestyle = color_mixin(**self._kwargs)
    def _draw_fill(contours):
        # Drawing commands for the path fill (as triangles by tessellating the contours).
        v = geometry.tesselate(contours)
        glBegin(GL_TRIANGLES)
        for x, y in v:
            glVertex3f(x, y, 0)
        glEnd()
    def _draw_stroke(contours):
        # Drawing commands for the path stroke.
        for path in contours:
            glBegin(GL_LINE_STRIP)
            for x, y in path:
                glVertex2f(x, y)
            glEnd()
    self._update() # Remove the cache if points were modified.
    if self._cache is None \
    or self._cache[0] is None and fill \
    or self._cache[1] is None and stroke \
    or self._cache[-1] != precision:
        # Calculate and cache the vertices as Display Lists.
        # If the path requires a fill color, it will have to be tessellated.
        if self._cache is not None:
            if self._cache[0]: flush(self._cache[0])
            if self._cache[1]: flush(self._cache[1])
        contours = self.flatten(precision)
        self._cache = [None, None, precision]
        if fill   : self._cache[0] = precompile(_draw_fill, contours)
        if stroke : self._cache[1] = precompile(_draw_stroke, contours)
    if fill is not None:
        glColor4f(fill[0], fill[1], fill[2], fill[3] * _alpha)
        glCallList(self._cache[0])
    if stroke is not None and strokewidth &gt; 0:
        glColor4f(stroke[0], stroke[1], stroke[2], stroke[3] * _alpha)
        glLineWidth(strokewidth)
        glLineDash(strokestyle)
        glCallList(self._cache[1])

</t>
<t tx="karstenw.20240123172917.123">def angle(self, t):
    """ Returns the directional angle at time t (0.0-1.0) on the path.
    """
    # The directed() enumerator is much faster but less precise.
    pt0, pt1 = t==0 and (self.point(t), self.point(t+0.001)) or (self.point(t-0.001), self.point(t))
    return geometry.angle(pt0.x, pt0.y, pt1.x, pt1.y)

</t>
<t tx="karstenw.20240123172917.124">def point(self, t):
    """ Returns the PathElement at time t (0.0-1.0) on the path.
        See the linear interpolation math in bezier.py.
    """
    if self._segments is None:
        self._segments = bezier.length(self, segmented=True, n=10)
    return bezier.point(self, t, segments=self._segments)

</t>
<t tx="karstenw.20240123172917.125">def points(self, amount=2, start=0.0, end=1.0):
    """ Returns a list of PathElements along the path.
        To omit the last point on closed paths: end=1-1.0/amount
    """
    if self._segments is None:
        self._segments = bezier.length(self, segmented=True, n=10)
    return bezier.points(self, amount, start, end, segments=self._segments)

</t>
<t tx="karstenw.20240123172917.126">def addpoint(self, t):
    """ Inserts a new PathElement at time t (0.0-1.0) on the path.
    """
    self._segments = None
    self._index = {}
    return bezier.insert_point(self, t)
    
split = addpoint

</t>
<t tx="karstenw.20240123172917.127">@property 
def length(self, precision=10):
    """ Returns an approximation of the total length of the path.
    """
    return bezier.length(self, segmented=False, n=precision)

</t>
<t tx="karstenw.20240123172917.128">@property
def contours(self):
    """ Returns a list of contours (i.e. segments separated by a MOVETO) in the path.
        Each contour is a BezierPath object.
    """
    return bezier.contours(self)

</t>
<t tx="karstenw.20240123172917.129">@property
def bounds(self, precision=100):
    """ Returns a (x, y, width, height)-tuple of the approximate path dimensions.
    """
    # In _update(), traverse all the points and check if they have changed.
    # If so, the bounds must be recalculated.
    self._update()
    if self._bounds is None:
        l = t = float( "inf")
        r = b = float("-inf")
        for pt in self.points(precision):
            if pt.x &lt; l: l = pt.x
            if pt.y &lt; t: t = pt.y
            if pt.x &gt; r: r = pt.x
            if pt.y &gt; b: b = pt.y
        self._bounds = (l, t, r-l, b-t)
    return self._bounds

</t>
<t tx="karstenw.20240123172917.13">def _set_r(self, v): self[0] = v
</t>
<t tx="karstenw.20240123172917.130">def contains(self, x, y, precision=100):
    """ Returns True when point (x,y) falls within the contours of the path.
    """
    bx, by, bw, bh = self.bounds
    if bx &lt;= x &lt;= bx+bw and \
       by &lt;= y &lt;= by+bh:
            if self._polygon is None \
            or self._polygon[1] != precision:
                self._polygon = [(pt.x,pt.y) for pt in self.points(precision)], precision
            # Ray casting algorithm:
            return geometry.point_in_polygon(self._polygon[0], x, y)
    return False

</t>
<t tx="karstenw.20240123172917.131">def hash(self, state=None, decimal=1):
    """ Returns the path id, based on the position and handles of its PathElements.
        Two distinct BezierPath objects that draw the same path therefore have the same id.
    """
    f = lambda x: int(x*10**decimal) # Format floats as strings with given decimal precision.
    id = [state]
    for pt in self: id.extend((
        pt.cmd, f(pt.x), f(pt.y), f(pt.ctrl1.x), f(pt.ctrl1.y), f(pt.ctrl2.x), f(pt.ctrl2.y)))
    id = str(id)
    id = md5(id).hexdigest()
    return id

</t>
<t tx="karstenw.20240123172917.132">def __repr__(self):
    return "BezierPath(%s)" % repr(list(self))

</t>
<t tx="karstenw.20240123172917.133">def __del__(self):
    # Note: it is important that __del__() is called since it unloads the cache from GPU.
    # BezierPath and PathElement should contain no circular references, e.g. no PathElement.parent.
    if hasattr(self, "_cache") and self._cache is not None and flush:
        if self._cache[0]: flush(self._cache[0])
        if self._cache[1]: flush(self._cache[1])

</t>
<t tx="karstenw.20240123172917.134">def drawpath(path, **kwargs):
    """ Draws the given BezierPath (or list of PathElements).
        The current stroke, strokewidth and fill color are applied.
    """
    if not isinstance(path, BezierPath):
        path = BezierPath(path)
    path.draw(**kwargs)

_autoclosepath = True
</t>
<t tx="karstenw.20240123172917.135">def autoclosepath(close=False):
    """ Paths constructed with beginpath() and endpath() are automatically closed.
    """
    global _autoclosepath
    _autoclosepath = close

_path = None
</t>
<t tx="karstenw.20240123172917.136">def beginpath(x, y):
    """ Starts a new path at (x,y).
        The commands moveto(), lineto(), curveto() and closepath() 
        can then be used between beginpath() and endpath() calls.
    """
    global _path
    _path = BezierPath()
    _path.moveto(x, y)

</t>
<t tx="karstenw.20240123172917.137">def moveto(x, y):
    """ Moves the current point in the current path to (x,y).
    """
    if _path is None: 
        raise NoCurrentPath()
    _path.moveto(x, y)

</t>
<t tx="karstenw.20240123172917.138">def lineto(x, y):
    """ Draws a line from the current point in the current path to (x,y).
    """
    if _path is None: 
        raise NoCurrentPath()
    _path.lineto(x, y)

</t>
<t tx="karstenw.20240123172917.139">def curveto(x1, y1, x2, y2, x3, y3):
    """ Draws a curve from the current point in the current path to (x3,y3).
        The curvature is determined by control handles x1, y1 and x2, y2.
    """
    if _path is None: 
        raise NoCurrentPath()
    _path.curveto(x1, y1, x2, y2, x3, y3)

</t>
<t tx="karstenw.20240123172917.14">def _set_g(self, v): self[1] = v
</t>
<t tx="karstenw.20240123172917.140">def closepath():
    """ Closes the current path with a straight line to the last MOVETO.
    """
    if _path is None: 
        raise NoCurrentPath()
    _path.closepath()

</t>
<t tx="karstenw.20240123172917.141">def endpath(draw=True, **kwargs):
    """ Draws and returns the current path.
        With draw=False, only returns the path so it can be manipulated and drawn with drawpath().
    """
    global _path, _autoclosepath
    if _path is None: 
        raise NoCurrentPath()
    if _autoclosepath is True:
        _path.closepath()
    if draw:
        _path.draw(**kwargs)
    p, _path = _path, None
    return p

</t>
<t tx="karstenw.20240123172917.142">def findpath(points, curvature=1.0):
    """ Returns a smooth BezierPath from the given list of (x,y)-tuples.
    """
    return bezier.findpath(list(points), curvature)

Path = BezierPath

</t>
<t tx="karstenw.20240123172917.143">class BezierEditor:
    
    @others

</t>
<t tx="karstenw.20240123172917.144">def __init__(self, path):
    self.path = path
    
</t>
<t tx="karstenw.20240123172917.145">def _nextpoint(self, pt):
    i = self.path.index(pt) # BezierPath caches this operation.
    return i &lt; len(self.path)-1 and self.path[i+1] or None

</t>
<t tx="karstenw.20240123172917.146">def translate(self, pt, x=0, y=0, h1=(0,0), h2=(0,0)):
    """ Translates the point and its control handles by (x,y).
        Translates the incoming handle by h1 and the outgoing handle by h2.
    """
    pt1, pt2 = pt, self._nextpoint(pt)
    pt1.x += x
    pt1.y += y
    pt1.ctrl2.x += x + h1[0]
    pt1.ctrl2.y += y + h1[1]
    if pt2 is not None:
        pt2.ctrl1.x += x + (pt2.cmd == CURVETO and h2[0] or 0)
        pt2.ctrl1.y += y + (pt2.cmd == CURVETO and h2[1] or 0)
        
</t>
<t tx="karstenw.20240123172917.147">def rotate(self, pt, angle, handle=BOTH):
    """ Rotates the point control handles by the given angle.
    """
    pt1, pt2 = pt, self._nextpoint(pt)
    if handle == BOTH or handle == IN:
        pt1.ctrl2.x, pt1.ctrl2.y = geometry.rotate(pt1.ctrl2.x, pt1.ctrl2.y, pt1.x, pt1.y, angle)
    if handle == BOTH or handle == OUT and pt2 is not None and pt2.cmd == CURVETO:
        pt2.ctrl1.x, pt2.ctrl1.y = geometry.rotate(pt2.ctrl1.x, pt2.ctrl1.y, pt1.x, pt1.y, angle)
        
</t>
<t tx="karstenw.20240123172917.148">def scale(self, pt, v, handle=BOTH):
    """ Scales the point control handles by the given factor.
    """
    pt1, pt2 = pt, self._nextpoint(pt)
    if handle == BOTH or handle == IN:
        pt1.ctrl2.x, pt1.ctrl2.y = bezier.linepoint(v, pt1.x, pt1.y, pt1.ctrl2.x, pt1.ctrl2.y)
    if handle == BOTH or handle == OUT and pt2 is not None and pt2.cmd == CURVETO:
        pt2.ctrl1.x, pt2.ctrl1.y = bezier.linepoint(v, pt1.x, pt1.y, pt2.ctrl1.x, pt2.ctrl1.y)

</t>
<t tx="karstenw.20240123172917.149">def smooth(self, pt, mode=None, handle=BOTH):
    pt1, pt2, i = pt, self._nextpoint(pt), self.path.index(pt)
    if pt2 is None:
        return
    if pt1.cmd == pt2.cmd == CURVETO:
        if mode == EQUIDISTANT:
            d1 = d2 = 0.5 * (
                 geometry.distance(pt1.x, pt1.y, pt1.ctrl2.x, pt1.ctrl2.y) + \
                 geometry.distance(pt1.x, pt1.y, pt2.ctrl1.x, pt2.ctrl1.y))
        else:
            d1 = geometry.distance(pt1.x, pt1.y, pt1.ctrl2.x, pt1.ctrl2.y)
            d2 = geometry.distance(pt1.x, pt1.y, pt2.ctrl1.x, pt2.ctrl1.y)            
        if handle == IN: 
            a = geometry.angle(pt1.x, pt1.y, pt1.ctrl2.x, pt1.ctrl2.y)
        if handle == OUT: 
            a = geometry.angle(pt2.ctrl1.x, pt2.ctrl1.y, pt1.x, pt1.y)
        if handle == BOTH: 
            a = geometry.angle(pt2.ctrl1.x, pt2.ctrl1.y, pt1.ctrl2.x, pt1.ctrl2.y)
        pt1.ctrl2.x, pt1.ctrl2.y = geometry.coordinates(pt1.x, pt1.y, d1, a)
        pt2.ctrl1.x, pt2.ctrl1.y = geometry.coordinates(pt1.x, pt1.y, d2, a-180)
    elif pt1.cmd == CURVETO and pt2.cmd == LINETO:
        d = mode == EQUIDISTANT and \
            geometry.distance(pt1.x, pt1.y, pt2.x, pt2.y) or \
            geometry.distance(pt1.x, pt1.y, pt1.ctrl2.x, pt1.ctrl2.y)
        a = geometry.angle(pt1.x, pt1.y, pt2.x, pt2.y)
        pt1.ctrl2.x, pt1.ctrl2.y = geometry.coordinates(pt1.x, pt1.y, d, a-180)
    elif pt1.cmd == LINETO and pt2.cmd == CURVETO and i &gt; 0:
        d = mode == EQUIDISTANT and \
            geometry.distance(pt1.x, pt1.y, self.path[i-1].x, self.path[i-1].y) or \
            geometry.distance(pt1.x, pt1.y, pt2.ctrl1.x, pt2.ctrl1.y)
        a = geometry.angle(self.path[i-1].x, self.path[i-1].y, pt1.x, pt1.y)
        pt2.ctrl1.x, pt2.ctrl1.y = geometry.coordinates(pt1.x, pt1.y, d, a)

</t>
<t tx="karstenw.20240123172917.15">def _set_b(self, v): self[2] = v
</t>
<t tx="karstenw.20240123172917.150">def directed(points):
    """ Returns an iterator that yields (angle, point)-tuples for the given list of points.
        The angle represents the direction of the point on the path.
        This works with BezierPath, Bezierpath.points, [pt1, pt2, pt2, ...]
        For example:
        for a, pt in directed(path.points(30)):
            push()
            translate(pt.x, pt.y)
            rotate(a)
            arrow(0, 0, 10)
            pop()
        This is useful if you want to have shapes following a path.
        To put text on a path, rotate the angle by +-90 to get the normal (i.e. perpendicular).
    """
    p = list(points)
    n = len(p)
    for i, pt in enumerate(p):
        if 0 &lt; i &lt; n-1 and pt.__dict__.get("_cmd") == CURVETO:
            # For a point on a curve, the control handle gives the best direction.
            # For PathElement (fixed point in BezierPath), ctrl2 tells us how the curve arrives.
            # For DynamicPathElement (returnd from BezierPath.point()), ctrl1 tell how the curve arrives.
            ctrl = isinstance(pt, bezier.DynamicPathElement) and pt.ctrl1 or pt.ctrl2
            angle = geometry.angle(ctrl.x, ctrl.y, pt.x, pt.y)
        elif 0 &lt; i &lt; n-1 and pt.__dict__.get("_cmd") == LINETO and p[i-1].__dict__.get("_cmd") == CURVETO:
            # For a point on a line preceded by a curve, look ahead gives better results.
            angle = geometry.angle(pt.x, pt.y, p[i+1].x, p[i+1].y)
        elif i == 0 and isinstance(points, BezierPath):
            # For the first point in a BezierPath, we can calculate a next point very close by.
            pt1 = points.point(0.001)
            angle = geometry.angle(pt.x, pt.y, pt1.x, pt1.y)
        elif i == n-1 and isinstance(points, BezierPath):
            # For the last point in a BezierPath, we can calculate a previous point very close by.
            pt0 = points.point(0.999)
            angle = geometry.angle(pt0.x, pt0.y, pt.x, pt.y)
        elif i == n-1 and isinstance(pt, bezier.DynamicPathElement) and pt.ctrl1.x != pt.x or pt.ctrl1.y != pt.y:
            # For the last point in BezierPath.points(), use incoming handle (ctrl1) for curves.
            angle = geometry.angle(pt.ctrl1.x, pt.ctrl1.y, pt.x, pt.y)
        elif 0 &lt; i:
            # For any point, look back gives a good result, if enough points are given.
            angle = geometry.angle(p[i-1].x, p[i-1].y, pt.x, pt.y)
        elif i &lt; n-1:
            # For the first point, the best (only) guess is the location of the next point.
            angle = geometry.angle(pt.x, pt.y, p[i+1].x, p[i+1].y)
        else:
            angle = 0
        yield angle, pt

</t>
<t tx="karstenw.20240123172917.151">class ClippingMask:
    @others
</t>
<t tx="karstenw.20240123172917.152">def draw(self, fill=(0,0,0,1), stroke=None):
    pass

</t>
<t tx="karstenw.20240123172917.153">def beginclip(path):
    """ Enables the given BezierPath (or ClippingMask) as a clipping mask.
        Drawing commands between beginclip() and endclip() are constrained to the shape of the path.
    """
    # Enable the stencil buffer to limit the area of rendering (stenciling).
    glClear(GL_STENCIL_BUFFER_BIT)
    glEnable(GL_STENCIL_TEST)
    glStencilFunc(GL_NOTEQUAL, 0, 0)
    glStencilOp(GL_INCR, GL_INCR, GL_INCR)
    # Shouldn't depth testing be disabled when stencilling?
    # In any case, if it is, transparency doesn't work.
    #glDisable(GL_DEPTH_TEST)
    path.draw(fill=(0,0,0,1), stroke=None) # Disregard color settings; always use a black mask.
    #glEnable(GL_DEPTH_TEST)
    glStencilFunc(GL_EQUAL, 1, 1)
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP)

</t>
<t tx="karstenw.20240123172917.154">def endclip():
    glDisable(GL_STENCIL_TEST)

</t>
<t tx="karstenw.20240123172917.155">def supershape(x, y, width, height, m, n1, n2, n3, points=100, percentage=1.0, range=2*pi, **kwargs):
    """ Returns a BezierPath constructed using the superformula,
        which can be used to describe many complex shapes and curves that are found in nature.
    """
    path = BezierPath()
    first = True
    for i in range(points):
        if i &lt;= points * percentage: 
            dx, dy = geometry.superformula(m, n1, n2, n3, i*range/points)
            dx, dy = dx*width/2 + x, dy*height/2 + y
            if first is True:
                path.moveto(dx, dy); first=False
            else:
                path.lineto(dx, dy)
    path.closepath()
    if kwargs.get("draw", True):
        path.draw(**kwargs)
    return path

</t>
<t tx="karstenw.20240123172917.156">def ceil2(x):
    """ Returns the nearest power of 2 that is higher than x, e.g. 700 =&gt; 1024.
    """
    for y in pow2:
        if y &gt;= x:
            return y

</t>
<t tx="karstenw.20240123172917.157">class ImageError(Exception): 
    pass

_texture_cache  = {} # pyglet.Texture referenced by filename.
_texture_cached = {} # pyglet.Texture.id is in keys once the image has been cached.
</t>
<t tx="karstenw.20240123172917.158">def texture(img, data=None):
    """ Returns a (cached) texture from the given image filename or byte data.
        When a Image or Pixels object is given, returns the associated texture.
    """
    # Image texture stored in cache, referenced by file path (or a custom id defined with cache()).
    if isinstance(img, (basestring, int)) and img in _texture_cache:
        return _texture_cache[img]

    # Image file path, load it, cache it, return texture.
    if isinstance(img, basestring):
        try: 
            cache(img, pyglet.image.load(img).get_texture())
        except IOError:
            raise ImageError( "can't load image from %s" % (repr(img),) )
        return _texture_cache[img]

    # Image texture, return original.
    if isinstance(img, pyglet.image.Texture):
        return img

    # Image object, return image texture.
    # (if you use this to create a new image, the new image will do expensive caching as well).
    if isinstance(img, Image):
        return img.texture

    # Pixels object, return pixel texture.
    if isinstance(img, Pixels):
        return img.texture

    # Pyglet image data.
    if isinstance(img, pyglet.image.ImageData):
        return img.texture

    # Image data as byte string, load it, return texture.
    if isinstance(data, basestring):
        return pyglet.image.load("", file=StringIO(data)).get_texture()

    # Don't know how to handle this image.
    raise ImageError( "unknown image type: %s" % (repr(img.__class__),) )

</t>
<t tx="karstenw.20240123172917.159">def cache(id, texture):
    """ Store the given texture in cache, referenced by id (which can then be passed to image()).
        This is useful for procedurally rendered images (which are not stored in cache by default).
    """
    if isinstance(texture, (Image, Pixels)):
        texture = texture.texture
    if not isinstance(texture, pyglet.image.Texture):
        raise ValueError( "can only cache texture, not %s"
                        % (repr(texture.__class__.__name__),) )
    _texture_cache[id] = texture
    _texture_cached[_texture_cache[id].id] = id
    
</t>
<t tx="karstenw.20240123172917.16">def _set_a(self, v): self[3] = v

r = red   = property(_get_r, _set_r)
g = green = property(_get_g, _set_g)
b = blue  = property(_get_b, _set_b)
a = alpha = property(_get_a, _set_a)

</t>
<t tx="karstenw.20240123172917.160">def cached(texture):
    """ Returns the cache id if the texture has been cached (None otherwise).
    """
    if isinstance(texture, (Image, Pixels)):
        texture = texture.texture
    if isinstance(texture, pyglet.image.Texture):
        return _texture_cached.get(texture.texture.id)
    if isinstance(texture, (basestring, int)):
        return texture in _texture_cache and texture or None
    return None
    
</t>
<t tx="karstenw.20240123172917.161">def _render(texture, quad=(0,0,0,0,0,0,0,0)):
    """ Renders the texture on the canvas inside a quadtriliteral (i.e. rectangle).
        The quadriliteral can be distorted by giving corner offset coordinates.
    """
    t = texture.tex_coords # power-2 dimensions
    w = texture.width      # See Pyglet programming guide -&gt; OpenGL imaging.
    h = texture.height
    dx1, dy1, dx2, dy2, dx3, dy3, dx4, dy4 = quad or (0,0,0,0,0,0,0,0)
    glEnable(texture.target)
    glBindTexture(texture.target, texture.id)
    glBegin(GL_QUADS)
    glTexCoord3f(t[0], t[1],  t[2] ); glVertex3f(dx4,   dy4,   0)
    glTexCoord3f(t[3], t[4],  t[5] ); glVertex3f(dx3+w, dy3,   0)
    glTexCoord3f(t[6], t[7],  t[8] ); glVertex3f(dx2+w, dy2+h, 0)
    glTexCoord3f(t[9], t[10], t[11]); glVertex3f(dx1,   dy1+h, 0)
    glEnd()
    glDisable(texture.target)

</t>
<t tx="karstenw.20240123172917.162">class Quad(list):
    
    @others
</t>
<t tx="karstenw.20240123172917.163">def __init__(self, dx1=0, dy1=0, dx2=0, dy2=0, dx3=0, dy3=0, dx4=0, dy4=0):
    """ Describes the four-sided polygon on which an image texture is "mounted".
        This is a quadrilateral (four sides) of which the vertices do not necessarily
        have a straight angle (i.e. the corners can be distorted).
    """
    list.__init__(self, (dx1, dy1, dx2, dy2, dx3, dy3, dx4, dy4))
    self._dirty = True # Image objects poll Quad._dirty to check if the image cache is outdated.

</t>
<t tx="karstenw.20240123172917.164">def copy(self):
    return Quad(*self)

</t>
<t tx="karstenw.20240123172917.165">def reset(self):
    list.__init__(self, (0,0,0,0,0,0,0,0))
    self._dirty = True

</t>
<t tx="karstenw.20240123172917.166">def __setitem__(self, i, v):
    list.__setitem__(self, i, v)
    self._dirty = True

</t>
<t tx="karstenw.20240123172917.167">def _get_dx1(self): return self[0]
</t>
<t tx="karstenw.20240123172917.168">def _get_dy1(self): return self[1]
</t>
<t tx="karstenw.20240123172917.169">def _get_dx2(self): return self[2]
</t>
<t tx="karstenw.20240123172917.17">def _get_rgb(self):
    return self[0], self[1], self[2]
# (r,g,b)
</t>
<t tx="karstenw.20240123172917.170">def _get_dy2(self): return self[3]
</t>
<t tx="karstenw.20240123172917.171">def _get_dx3(self): return self[4]
</t>
<t tx="karstenw.20240123172917.172">def _get_dy3(self): return self[5]
</t>
<t tx="karstenw.20240123172917.173">def _get_dx4(self): return self[6]
</t>
<t tx="karstenw.20240123172917.174">def _get_dy4(self): return self[7]

</t>
<t tx="karstenw.20240123172917.175">def _set_dx1(self, v): self[0] = v
</t>
<t tx="karstenw.20240123172917.176">def _set_dy1(self, v): self[1] = v
</t>
<t tx="karstenw.20240123172917.177">def _set_dx2(self, v): self[2] = v
</t>
<t tx="karstenw.20240123172917.178">def _set_dy2(self, v): self[3] = v
</t>
<t tx="karstenw.20240123172917.179">def _set_dx3(self, v): self[4] = v
</t>
<t tx="karstenw.20240123172917.18">def _set_rgb(self, triplet):
    r,g,b = triplet
    self[0] = r
    self[1] = g
    self[2] = b
    
rgb = property(_get_rgb, _set_rgb)

</t>
<t tx="karstenw.20240123172917.180">def _set_dy3(self, v): self[5] = v
</t>
<t tx="karstenw.20240123172917.181">def _set_dx4(self, v): self[6] = v
</t>
<t tx="karstenw.20240123172917.182">def _set_dy4(self, v): self[7] = v

dx1 = property(_get_dx1, _set_dx1)
dy1 = property(_get_dy1, _set_dy1)
dx2 = property(_get_dx2, _set_dx2)
dy2 = property(_get_dy2, _set_dy2)
dx3 = property(_get_dx3, _set_dx3)
dy3 = property(_get_dy3, _set_dy3)
dx4 = property(_get_dx4, _set_dx4)
dy4 = property(_get_dy4, _set_dy4)

</t>
<t tx="karstenw.20240123172917.183">class Image(object):
    
    @others
_IMAGE_CACHE = 200
_image_cache = {} # Image object referenced by Image.texture.id.
_image_queue = [] # Most recent id's are at the front of the list.
</t>
<t tx="karstenw.20240123172917.184">def __init__(self, path, x=0, y=0, width=None, height=None, alpha=1.0, data=None):
    """ A texture that can be drawn at a given position.
        The quadrilateral in which the texture is drawn can be distorted (slow, image cache is flushed).
        The image can be resized, colorized and its opacity can be set.
    """
    self._src     = (path, data)
    self._texture = texture(path, data=data)
    self._cache   = None
    self.x        = x
    self.y        = y
    self.width    = width  or self._texture.width  # Scaled width, Image.texture.width yields original width.
    self.height   = height or self._texture.height # Scaled height, Image.texture.height yields original height.
    self.quad     = Quad()
    self.color    = Color(1.0, 1.0, 1.0, alpha)

</t>
<t tx="karstenw.20240123172917.185">def copy(self, texture=None, width=None, height=None):
    img = texture is None \
      and self.__class__(self._src[0], data=self._src[1]) \
       or self.__class__(texture)
    img.x      = self.x
    img.y      = self.y
    img.width  = self.width
    img.height = self.height
    img.quad   = self.quad.copy()
    img.color  = self.color.copy()
    if width is not None: 
        img.width = width
    if height is not None: 
        img.height = height
    return img

</t>
<t tx="karstenw.20240123172917.186">@property
def id(self):
    return self._texture.id

</t>
<t tx="karstenw.20240123172917.187">@property
def texture(self):
    return self._texture

</t>
<t tx="karstenw.20240123172917.188">def _get_xy(self):
    return (self.x, self.y)
# (x,y)
</t>
<t tx="karstenw.20240123172917.189">def _set_xy(self, doublet):
    x,y = doublet
    self.x = x
    self.y = y
    
xy = property(_get_xy, _set_xy)

</t>
<t tx="karstenw.20240123172917.19">def _get_rgba(self):
    return self[0], self[1], self[2], self[3]

# (r,g,b,a)
</t>
<t tx="karstenw.20240123172917.190">def _get_size(self):
    return (self.width, self.height)
# (w,h)
</t>
<t tx="karstenw.20240123172917.191">def _set_size(self, doublet):
    w,h = doublet
    self.width  = w
    self.height = h
    
size = property(_get_size, _set_size)

</t>
<t tx="karstenw.20240123172917.192">def _get_alpha(self):
    return self.color[3]
</t>
<t tx="karstenw.20240123172917.193">def _set_alpha(self, v):
    self.color[3] = v
    
alpha = property(_get_alpha, _set_alpha)

</t>
<t tx="karstenw.20240123172917.194">def distort(self, dx1=0, dy1=0, dx2=0, dy2=0, dx3=0, dy3=0, dx4=0, dy4=0):
    """ Adjusts the four-sided polygon on which an image texture is "mounted",
        by incrementing the corner coordinates with the given values.
    """
    for i, v in enumerate((dx1, dy1, dx2, dy2, dx3, dy3, dx4, dy4)):
        if v != 0: 
            self.quad[i] += v

</t>
<t tx="karstenw.20240123172917.195">def adjust(r=1.0, g=1.0, b=1.0, a=1.0):
    """ Adjusts the image color by multiplying R,G,B,A channels with the given values.
    """
    self.color[0] *= r
    self.color[1] *= g
    self.color[2] *= b
    self.color[3] *= a
    
</t>
<t tx="karstenw.20240123172917.196">def draw(self, x=None, y=None, width=None, height=None, alpha=None, color=None, filter=None):
    """ Draws the image.
        The given parameters (if any) override the image's attributes.
    """
    # Calculate and cache the quad vertices as a Display List.
    # If the quad has changed, update the cache.
    if self._cache is None or self.quad._dirty:
        flush(self._cache)
        self._cache = precompile(_render, self._texture, self.quad)
        self.quad._dirty = False
    # Given parameters override Image attributes.
    if x is None: 
        x = self.x
    if y is None: 
        y = self.y
    if width is None: 
        width = self.width 
    if height is None: 
        height = self.height
    if color and len(color) &lt; 4:
        color = color[0], color[1], color[2], 1.0
    if color is None: 
        color = self.color
    if alpha is not None:
        color = color[0], color[1], color[2], alpha
    if filter:
        filter.texture = self._texture # Register the current texture with the filter.
        filter.push()
    # Round position (x,y) to nearest integer to avoid sub-pixel rendering.
    # This ensures there are no visual artefacts on transparent borders (e.g. the "white halo").
    # Halo can also be avoided by overpainting in the source image, but this requires some work:
    # http://technology.blurst.com/remove-white-borders-in-transparent-textures/
    x = round(x)
    y = round(y)
    w = float(width) / self._texture.width
    h = float(height) / self._texture.height
    # Transform and draw the quads.
    glPushMatrix()
    glTranslatef(x, y, 0)
    glScalef(w, h, 0)
    glColor4f(color[0], color[1], color[2], color[3] * _alpha)
    glCallList(self._cache)
    glPopMatrix() 
    if filter:
        filter.pop()

</t>
<t tx="karstenw.20240123172917.197">def save(self, path):
    """ Exports the image as a PNG-file.
    """
    self._texture.save(path)

</t>
<t tx="karstenw.20240123172917.198">def __repr__(self):
    return "%s(x=%.1f, y=%.1f, width=%.1f, height=%.1f, alpha=%.2f)" % (
        self.__class__.__name__, self.x, self.y, self.width, self.height, self.alpha)

</t>
<t tx="karstenw.20240123172917.199">def __del__(self):
    try:
        if hasattr(self, "_cache") and self._cache is not None and flush:
            flush(self._cache)
    except:
        pass

</t>
<t tx="karstenw.20240123172917.2">def getscreenconf():
    display = pyglet.canvas.get_display()
    screen = display.get_default_screen()
    config = screen.get_best_config()
    return screen, config

#import bezier
# Do this at the end, when we have defined BezierPath, which is needed in the bezier module.

#import shader
# Do this when we have defined texture() and image(), which are needed in the shader module.

# OpenGL version, e.g. "2.0 NVIDIA-1.5.48".
OPENGL = pyglet.gl.gl_info.get_version()

</t>
<t tx="karstenw.20240123172917.20">def _set_rgba(self, quadruplet):
    r,g,b,a = quadruplet
    self[0] = r
    self[1] = g
    self[2] = b
    self[3] = a
    
rgba = property(_get_rgba, _set_rgba)

</t>
<t tx="karstenw.20240123172917.200">def image(img, x=None, y=None, width=None, height=None, 
          alpha=None, color=None, filter=None, data=None, draw=True):
    """ Draws the image at (x,y), scaling it to the given width and height.
        The image's transparency can be set with alpha (0.0-1.0).
        Applies the given color adjustment, quad distortion and filter (one filter can be specified).
        Note: with a filter enabled, alpha and color will not be applied.
        This is because the filter overrides the default drawing behavior with its own.
    """
    if not isinstance(img, Image):
        # If the given image is not an Image object, create one on the fly.
        # This object is cached for reuse.
        # The cache has a limited size (200), so the oldest Image objects are deleted.
        t = texture(img, data=data)
        if t.id in _image_cache: 
            img = _image_cache[t.id]
        else:
            img = Image(img, data=data)
            _image_cache[img.texture.id] = img
            _image_queue.insert(0, img.texture.id)
            for id in reversed(_image_queue[_IMAGE_CACHE:]): 
                del _image_cache[id]
                del _image_queue[-1]
    # Draw the image.
    if draw:
        img.draw(x, y, width, height, alpha, color, filter)
    return img

</t>
<t tx="karstenw.20240123172917.201">def imagesize(img):
    """ Returns a (width, height)-tuple with the image dimensions.
    """
    t = texture(img)
    return (t.width, t.height)

</t>
<t tx="karstenw.20240123172917.202">def crop(img, x=0, y=0, width=None, height=None):
    """ Returns the given (x, y, width, height)-region from the image.
        Use this to pass cropped image files to image().
    """
    t = texture(img)
    if width  is None: width  = t.width
    if height is None: height = t.height
    t = t.get_region(x, y, min(t.width-x, width), min(t.height-y, height))
    if isinstance(img, Image):
        img = img.copy(texture=t)
        return img.copy(texture=t, width=t.width, height=t.height)
    if isinstance(img, Pixels):
        return Pixels(t)
    if isinstance(img, pyglet.image.Texture):
        return t
    return Image(t)

</t>
<t tx="karstenw.20240123172917.203">class Pixels(list):
    
    @others
pixels = Pixels

#--- ANIMATION ---------------------------------------------------------------------------------------
# A sequence of images displayed in a loop.
# Useful for storing pre-rendered effect frames like explosions etc.

</t>
<t tx="karstenw.20240123172917.204">def __init__(self, img):
    """ A list of RGBA color values (0-255) for each pixel in the given image.
        The Pixels object can be passed to the image() command.
    """
    self._img  = texture(img).get_image_data()
    # A negative pitch means the pixels are stored top-to-bottom row.
    self._flipped = self._img.pitch &gt;= 0
    # Data yields a byte array if no conversion (e.g. BGRA =&gt; RGBA) was necessary,
    # or a byte string otherwise - which needs to be converted to a list of ints.
    data = self._img.get_data("RGBA", self._img.width*4 * (-1,1)[self._flipped])
    if isinstance(data, str):
        data = map(ord, list(data))
    # Some formats seem to store values from -1 to -256.
    data = [(256+v)%256 for v in data]
    self.array = data
    self._texture  = None

</t>
<t tx="karstenw.20240123172917.205">@property
def width(self):
    return self._img.width

</t>
<t tx="karstenw.20240123172917.206">@property
def height(self):
    return self._img.height

</t>
<t tx="karstenw.20240123172917.207">@property
def size(self):
    return (self.width, self.height)

</t>
<t tx="karstenw.20240123172917.208">def __len__(self):
    return len(self.array) / 4

</t>
<t tx="karstenw.20240123172917.209">def __iter__(self):
    for i in range(len(self)):
        yield self[i]

</t>
<t tx="karstenw.20240123172917.21">def copy(self):
    return Color(self)

</t>
<t tx="karstenw.20240123172917.210">def __getitem__(self, i):
    """ Returns a list of R,G,B,A channel values between 0-255 from pixel i.
        Users need to wrap the list in a Color themselves for performance.
        - r,g,b,a = Pixels[i]
        - clr = color(Pixels[i], base=255)
    """
    return self.array[i*4:i*4+4]

</t>
<t tx="karstenw.20240123172917.211">def __setitem__(self, i, v):
    """ Sets pixel i to the given R,G,B,A values.
        Users need to unpack a Color themselves for performance,
        and are resposible for keeping channes values between 0 and 255
        (otherwise an error will occur when Pixels.update() is called),
        - Pixels[i] = r,g,b,a
        - Pixels[i] = clr.map(base=255)
    """
    for j in range(4):
        self.array[i*4+j] = v[j]

</t>
<t tx="karstenw.20240123172917.212">def __getslice__(self, i, j):
    return [self[i+n] for n in range(j-i)]

</t>
<t tx="karstenw.20240123172917.213">def __setslice__(self, i, j, seq):
    for n in range(j-i):
        self[i+n] = seq[n]
        
</t>
<t tx="karstenw.20240123172917.214">def map(self, function):
    """ Applies a function to each pixel.
        Function takes a list of R,G,B,A channel values and must return a similar list.
    """
    for i in range(len(self)):
        self[i] = function(self[i])
        
</t>
<t tx="karstenw.20240123172917.215">def get(self, i, j):
    """ Returns the pixel at row i, column j as a Color object.
    """
    if 0 &lt;= i &lt; self.width and 0 &lt;= j &lt; self.height:
        return color(self[i+j*self.width], base=255)

</t>
<t tx="karstenw.20240123172917.216">def set(self, i, j, clr):
    """ Sets the pixel at row i, column j from a Color object.
    """
    if 0 &lt;= i &lt; self.width and 0 &lt;= j &lt; self.height:
        self[i+j*self.width] = clr.map(base=255)

</t>
<t tx="karstenw.20240123172917.217">def update(self):
    """ Pixels.update() must be called to refresh the image.
    """
    data = self.array
    data = "".join(map(chr, data))
    self._img.set_data("RGBA", self._img.width*4*(-1,1)[self._flipped], data)
    self._texture = self._img.get_texture()
    
</t>
<t tx="karstenw.20240123172917.218">@property
def texture(self):
    if self._texture is None:
        self.update()
    return self._texture
    
</t>
<t tx="karstenw.20240123172917.219">def copy(self):
    return Pixels(self.texture)
    
</t>
<t tx="karstenw.20240123172917.22">def _apply(self):
    glColor4f(self[0], self[1], self[2], self[3] * _alpha)

</t>
<t tx="karstenw.20240123172917.220">def __repr__(self):
    return "%s(width=%.1f, height=%.1f)" % (
        self.__class__.__name__, self.width, self.height)

</t>
<t tx="karstenw.20240123172917.221">class Animation(list):
    
    @others
animation = Animation

</t>
<t tx="karstenw.20240123172917.222">def __init__(self, images=[], duration=None, loop=False, **kwargs):
    """ Constructs an animation loop from the given image frames.
        The duration specifies the time for the entire animation to run.
        Animations are useful to cache effects like explosions,
        that have for example been prepared in an offscreen buffer.
    """
    list.__init__(self, list(images))
    self.duration = duration # Duration of the entire animation.
    self.loop     = loop     # Loop from last frame to first frame?
    self._i       = -1       # Frame counter.
    self._t = Transition(0, interpolation=kwargs.get("interpolation", LINEAR))

</t>
<t tx="karstenw.20240123172917.223">def copy(self, **kwargs):
    return Animation(self, 
          duration = kwargs.get("duration", self.duration), 
              loop = kwargs.get("loop", self.loop), 
     interpolation = self._t._interpolation)

</t>
<t tx="karstenw.20240123172917.224">def update(self):
    if self.duration is not None:
        # With a duration,
        # skip to a next frame so that the entire animation takes the given time.
        if self._i &lt; 0 or self.loop and self._i == len(self)-1:
            self._t.set(0, 0)
            self._t.update()
            self._t.set(len(self)-1, self.duration)
        self._t.update()
        self._i = int(self._t.current)
    else:
        # Without a duration,
        # Animation.update() simply moves to the next frame.
        if self._i &lt; 0 or self.loop and self._i == len(self)-1:
            self._i = -1
        self._i = min(self._i+1, len(self)-1)

</t>
<t tx="karstenw.20240123172917.225">@property
def frames(self):
    return self
    
</t>
<t tx="karstenw.20240123172917.226">@property
def frame(self):
    # Yields the current frame Image (or None).
    try: return self[self._i]
    except:
        return None
    
</t>
<t tx="karstenw.20240123172917.227">@property
def done(self):
    # Yields True when the animation has stopped (or hasn't started).
    return self.loop is False and self._i == len(self)-1

</t>
<t tx="karstenw.20240123172917.228">def draw(self, *args, **kwargs):
    if not self.done:
        image(self.frame, *args, **kwargs)
        
</t>
<t tx="karstenw.20240123172917.229">def __repr__(self):
    return "%s(frames=%i, duration=%s)" % (
        self.__class__.__name__, len(self), repr(self.duration))

</t>
<t tx="karstenw.20240123172917.23">def __repr__(self):
    return "Color(%.3f, %.3f, %.3f, %.3f)" % \
        (self[0], self[1], self[2], self[3])
        
</t>
<t tx="karstenw.20240123172917.230">def install_font(ttf):
    """ Loads the given TrueType font from file, and returns True on success.
    """
    try: 
        pyglet.font.add_file(ttf)
        return True
    except:
        # This might fail with Carbon on 64-bit Mac systems.
        # Fonts can be installed on the system manually if this is the case.
        return False

# Load the platform-independent fonts shipped with NodeBox.
# The default font is Droid (licensed under Apache 2.0).
try:
    for f in glob(path.join(path.dirname(__file__), "..", "font", "*")):
        install_font(f)
    DEFAULT_FONT = "Droid Sans"
except:
    DEFAULT_FONT = "Arial"

# Font weight
NORMAL = "normal"
BOLD   = "bold"
ITALIC = "italic"

# Text alignment
LEFT   = "left"
RIGHT  = "right"
CENTER = "center"

_fonts      = []             # Custom fonts loaded from file.
_fontname   = DEFAULT_FONT   # Current state font name.
_fontsize   = 12             # Current state font size.
_fontweight = [False, False] # Current state font weight (bold, italic).
_lineheight = 1.0            # Current state text lineheight.
_align      = LEFT           # Current state text alignment (LEFT/RIGHT/CENTER).

</t>
<t tx="karstenw.20240123172917.231">def font(fontname=None, fontsize=None, fontweight=None, file=None):
    """ Sets the current font and/or fontsize.
        If a filename is also given, loads the fontname from the given font file.
    """
    global _fontname, _fontsize
    if file is not None and file not in _fonts:
        _fonts.append(file); install_font(file)
    if fontname is not None:
        _fontname = fontname
    if fontsize is not None:
        _fontsize = fontsize
    if fontweight is not None:
        _fontweight_(fontweight) # _fontweight_() is just an alias for fontweight().
    return _fontname

</t>
<t tx="karstenw.20240123172917.232">def fontname(name=None):
    """ Sets the current font used when drawing text.
    """
    global _fontname
    if name is not None:
        _fontname = name
    return _fontname

</t>
<t tx="karstenw.20240123172917.233">def fontsize(size=None):
    """ Sets the current fontsize in points.
    """
    global _fontsize
    if size is not None:
        _fontsize = size
    return _fontsize
    
</t>
<t tx="karstenw.20240123172917.234">def fontweight(*args, **kwargs):
    """ Sets the current font weight.
        You can supply NORMAL, BOLD and/or ITALIC or set named parameters bold=True and/or italic=True.
    """
    global _fontweight
    if len(args) == 1 and isinstance(args, (list, tuple)):
        args = args[0]
    if NORMAL in args:
        _fontweight = [False, False]
    if BOLD in args or kwargs.get(BOLD):
        _fontweight[0] = True
    if ITALIC in args or kwargs.get(ITALIC):
        _fontweight[1] = True
    return _fontweight
    
_fontweight_ = fontweight

</t>
<t tx="karstenw.20240123172917.235">def lineheight(size=None):
    """ Sets the vertical spacing between lines of text.
        The given size is a relative value: lineheight 1.2 for fontsize 10 means 12.
    """
    global _lineheight
    if size is not None:
        _lineheight = size
    return _lineheight

</t>
<t tx="karstenw.20240123172917.236">def align(mode=None):
    """ Sets the alignment of text paragrapgs (LEFT, RIGHT or CENTER).
    """
    global _align
    if mode is not None:
        _align = mode
    return _align

</t>
<t tx="karstenw.20240123172917.237">def font_mixin(**kwargs):
    fontname   = kwargs.get("fontname", kwargs.get("font", _fontname))
    fontsize   = kwargs.get("fontsize", _fontsize)
    bold       = kwargs.get("bold", BOLD in kwargs.get("fontweight", "") or _fontweight[0])
    italic     = kwargs.get("italic", ITALIC in kwargs.get("fontweight", "") or _fontweight[1])
    lineheight = kwargs.get("lineheight", _lineheight)
    align      = kwargs.get("align", _align)
    return (fontname, fontsize, bold, italic, lineheight, align) 

</t>
<t tx="karstenw.20240123172917.238">def label(string="", width=None, height=None, **kwargs):
    """ Returns a drawable pyglet.text.Label object from the given string.
        Optional arguments include: font, fontsize, bold, italic, align, lineheight, fill.
        If these are omitted the current state is used.
    """
    fontname, fontsize, bold, italic, lineheight, align = font_mixin(**kwargs)
    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    fill = fill is None and (0,0,0,0) or fill
    # We use begin_update() so that the TextLayout doesn't refresh on each update.
    # FormattedDocument allows individual styling of characters - see Text.style().
    label = pyglet.text.Label(batch=_label_batch)
    label.begin_update()
    label.document = pyglet.text.document.FormattedDocument(string or " ")
    label.width     = width    
    label.height    = height
    label.font_name = fontname
    label.font_size = fontsize
    label.bold      = bold
    label.italic    = italic
    label.multiline = True
    label.anchor_y  = "bottom"
    label.set_style("align", align)
    label.set_style("line_spacing", lineheight * fontsize)
    label.color     = [int(ch*255) for ch in fill]
    if string == "":
        # Empty string "" does not set properties so we used " " first.
        label.text = string
    label.end_update()
    return label

</t>
<t tx="karstenw.20240123172917.239">class Text(object):
    
    @others
_TEXT_CACHE = 200
_text_cache = {}
_text_queue = []
</t>
<t tx="karstenw.20240123172917.24">def __eq__(self, clr):
    if not isinstance(clr, Color): return False
    return self[0] == clr[0] \
       and self[1] == clr[1] \
       and self[2] == clr[2] \
       and self[3] == clr[3]

</t>
<t tx="karstenw.20240123172917.240">def __init__(self, string, x=0, y=0, width=None, height=None, **kwargs):
    """ A formatted string of text that can be drawn at a given position.
        Text has the following properties: 
        text, x, y, width, height, font, fontsize, bold, italic, lineheight, align, fill.
        Individual character ranges can be styled with Text.style().
    """
    if width is None:
        # Supplying a string with "\n" characters will crash if no width is given.
        # On the outside it appears as None but inside we use a very large number.
        width = geometry.INFINITE
        a, kwargs["align"] = kwargs.get("align", _align), LEFT
    else:
        a = None
    self.__dict__["x"]      = x
    self.__dict__["y"]      = y
    self.__dict__["_label"] = label(string, width, height, **kwargs)
    self.__dict__["_dirty"] = False
    self.__dict__["_align"] = a
    self.__dict__["_fill"]  = None

</t>
<t tx="karstenw.20240123172917.241">def _get_xy(self):
    return (self.x, self.y)
</t>
<t tx="karstenw.20240123172917.242"># (x,y )
def _set_xy(self, doublet):
    x,y = doublet
    self.x = x
    self.y = y
    
xy = property(_get_xy, _set_xy)

</t>
<t tx="karstenw.20240123172917.243">def _get_size(self):
    return (self.width, self.height)
</t>
<t tx="karstenw.20240123172917.244"># ( w,h )
def _set_size(self, doublet):
    w,h = doublet
    self.width  = w
    self.height = h
    
size = property(_get_size, _set_size)

</t>
<t tx="karstenw.20240123172917.245">def __getattr__(self, k):
    if k in self.__dict__:
        return self.__dict__[k]
    elif k in ("text", "height", "bold", "italic"):
        return getattr(self._label, k)
    elif k == "string":
        return self._label.text
    elif k == "width":
        if self._label.width != geometry.INFINITE: return self._label.width
    elif k in ("font", "fontname"):
        return self._label.font_name
    elif k == "fontsize":
        return self._label.font_size
    elif k == "fontweight":
        return ((None, BOLD)[self._label.bold], (None, ITALIC)[self._label.italic])
    elif k == "lineheight":
        return self._label.get_style("line_spacing") / (self.fontsize or 1)
    elif k == "align":
        if not self._align: self._align = self._label.get_style(k)
        return self._align
    elif k == "fill":
        if not self._fill: self._fill = Color([ch/255.0 for ch in self._label.color])
        return self._fill
    else:
        raise AttributeError( "'Text' object has no attribute '%s'" % (k,) )
        
</t>
<t tx="karstenw.20240123172917.246">def __setattr__(self, k, v):
    if k in self.__dict__:
        self.__dict__[k] = v; return
    # Setting properties other than x and y requires the label's layout to be updated.
    self.__dict__["_dirty"] = True
    self._label.begin_update()
    if k in ("text", "height", "bold", "italic"):
        setattr(self._label, k, v)
    elif k == "string":
        self._label.text = v
    elif k == "width":
        self._label.width = v is None and geometry.INFINITE or v
    elif k in ("font", "fontname"):
        self._label.font_name = v
    elif k == "fontsize":
        self._label.font_size = v
    elif k == "fontweight":
        self._label.bold, self._label.italic = BOLD in v, ITALIC in v
    elif k == "lineheight":
        self._label.set_style("line_spacing", v * (self.fontsize or 1))
    elif k == "align":
        self._align = v
        self._label.set_style(k, self._label.width == geometry.INFINITE and LEFT or v)
    elif k == "fill":
        self._fill = v
        
        try:
            c = [int(255*ch) for ch in self._fill or (0,0,0,0)]
            n = len(c)
            self._label.color[:n] = c
        except Exception as err:
            pass
            # self._label.color = (0,0,0)
    else:
        raise AttributeError( "'Text' object has no attribute '%s'" % (k,) )

</t>
<t tx="karstenw.20240123172917.247">def _update(self):
    # Called from Text.draw(), Text.copy() and Text.metrics.
    # Ensures that all the color changes have been reflected in Text._label.
    # If necessary, recalculates the label's layout (happens in end_update()).
    if hasattr(self._fill, "_dirty") and self._fill._dirty:
        self.fill = self._fill
        self._fill._dirty = False
    if self._dirty:
        self._label.end_update()
        self._dirty = False

</t>
<t tx="karstenw.20240123172917.248">@property
def path(self):
    raise NotImplementedError()

</t>
<t tx="karstenw.20240123172917.249">@property
def metrics(self):
    """ Yields a (width, height)-tuple of the actual text content.
    """
    self._update()
    return self._label.content_width, self._label.content_height
    
</t>
<t tx="karstenw.20240123172917.25">def __ne__(self, clr):
    return not self.__eq__(clr)

</t>
<t tx="karstenw.20240123172917.250">def draw(self, x=None, y=None):
    """ Draws the text.
    """
    # Given parameters override Text attributes.
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    # Fontsize is rounded, and fontsize 0 will output a default font.
    # Therefore, we don't draw text with a fontsize smaller than 0.5.
    if self._label.font_size &gt;= 0.5:
        glPushMatrix()
        glTranslatef(x, y, 0)
        self._update()
        self._label.draw()
        glPopMatrix()

</t>
<t tx="karstenw.20240123172917.251">def copy(self):
    self._update()
    txt = Text(self.text, self.x, self.y, self.width, self.height, 
          fontname = self.fontname,
          fontsize = self.fontsize,
              bold = self.bold,
            italic = self.italic,
        lineheight = self.lineheight,
             align = self.align,
              fill = self.fill
    )
    # The individual character styling is retrieved from Label.document._style_runs.
    # Traverse it and set the styles in the new text.
    txt._label.begin_update()
    for k in self._label.document._style_runs:
        for i, j, v in self._label.document._style_runs[k]:
            txt.style(i,j, **{k:v})
    txt._label.end_update()
    return txt
    
</t>
<t tx="karstenw.20240123172917.252">def style(self, i, j, **kwargs):
    """ Defines the styling for a range of characters in the text.
        Valid arguments can include: font, fontsize, bold, italic, lineheight, align, fill.
        For example: text.style(0, 10, bold=True, fill=color(1,0,0))
    """
    attributes = {}
    for k,v in kwargs.items():
        if k in ("font", "fontname"):
            attributes["font_name"] = v
        elif k == "fontsize":
            attributes["font_size"] = v
        elif k in ("bold", "italic", "align"):
            attributes[k] = v
        elif k == "fontweight":
            attributes.setdefault("bold", BOLD in v)
            attributes.setdefault("italic", ITALIC in v)
        elif k == "lineheight":
            attributes["line_spacing"] = v * self._label.font_size
        elif k == "fill":
            attributes["color"] = [int(ch*255) for ch in v]
        else:
            attributes[k] = v
    self._dirty = True
    self._label.begin_update()
    self._label.document.set_style(i, j, attributes)

</t>
<t tx="karstenw.20240123172917.253">def __len__(self):
    return len(self.text)

</t>
<t tx="karstenw.20240123172917.254">def __del__(self):
    if hasattr(self, "_label") and self._label:
        self._label.delete()

</t>
<t tx="karstenw.20240123172917.255">def text(string, x=None, y=None, width=None, height=None, draw=True, **kwargs):
    """ Draws the string at the given position, with the current font().
        Lines of text will span the given width before breaking to the next line.
        The text will be displayed with the current state font(), fontsize(), fontweight(), etc.
        When the given text is a Text object, the state will not be applied.
    """
    if isinstance(string, Text) and width is None and height is None and len(kwargs) == 0:
        txt = string
    else:
        # If the given text is not a Text object, create one on the fly.
        # Dynamic Text objects are cached by (font, fontsize, bold, italic),
        # and those that are no longer referenced by the user are recycled.
        # Changing Text properties is still faster than creating a new Text.
        # The cache has a limited size (200), so the oldest Text objects are deleted.
        fontname, fontsize, bold, italic, lineheight, align = font_mixin(**kwargs)
        fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
        id = (fontname, int(fontsize), bold, italic)
        recycled = False
        if id in _text_cache:
            for txt in _text_cache[id]:
                # Reference count 3 =&gt; Python, _text_cache[id], txt.
                # No other variables are referencing the text, so we can recycle it.
                if getrefcount(txt) == 3:
                    txt.text = string
                    txt.x = x or 0
                    txt.y = y or 0
                    txt.width = width
                    txt.height = height
                    txt.lineheight = lineheight
                    txt.align = align
                    txt.fill = fill
                    recycled = True
                    break
        if not recycled:
            txt = Text(string, x or 0, y or 0, width, height, **kwargs)
            _text_cache.setdefault(id, [])
            _text_cache[id].append(txt)
            _text_queue.insert(0, id)
            for id in reversed(_text_queue[_TEXT_CACHE:]): 
                del _text_cache[id][0]
                del _text_queue[-1]
    if draw:
        txt.draw(x, y)
    return txt

</t>
<t tx="karstenw.20240123172917.256">def textwidth(txt, **kwargs):
    """ Returns the width of the given text.
    """
    if not isinstance(txt, Text) or len(kwargs) &gt; 0:
        kwargs["draw"] = False
        txt = text(txt, 0, 0, **kwargs)
    return txt.metrics[0]

</t>
<t tx="karstenw.20240123172917.257">def textheight(txt, width=None, **kwargs):
    """ Returns the height of the given text.
    """
    if not isinstance(txt, Text) or len(kwargs) &gt; 0 or width != txt.width:
        kwargs["draw"] = False
        txt = text(txt, 0, 0, width=width, **kwargs)
    return txt.metrics[1]

</t>
<t tx="karstenw.20240123172917.258">def textmetrics(txt, width=None, **kwargs):
    """ Returns a (width, height)-tuple for the given text.
    """
    if not isinstance(txt, Text) or len(kwargs) &gt; 0 or width != txt.width:
        kwargs["draw"] = False
        txt = text(txt, 0, 0, width=width, **kwargs)
    return txt.metrics

</t>
<t tx="karstenw.20240123172917.259">class GlyphPathError(Exception):
    pass


glyphs = {}
try:
    # Load cached font glyph path information from nodebox/font/glyph.p.
    # By default, it has glyph path info for Droid Sans, Droid Sans Mono, Droid Serif.
    glyphpath = path.join(path.dirname(__file__), "..", "font", "glyph.p")
    glyphs = pickle.load(open(glyphpath, 'rb'))
except Exception as err:
    print("ERROR loading glyphs pickle.")
    print( err )

</t>
<t tx="karstenw.20240123172917.26">def map(self, base=1.0, colorspace=RGB):
    """ Returns a list of R,G,B,A values mapped to the given base,
        e.g. from 0-255 instead of 0.0-1.0 which is useful for setting image pixels.
        Other values than RGBA can be obtained by setting the colorspace (RGB/HSB/XYZ/LAB).
    """
    r, g, b, a = self
    if colorspace != RGB:
        if colorspace == HSB: r, g, b = rgb_to_hsb(r, g, b)
        if colorspace == XYZ: r, g, b = rgb_to_xyz(r, g, b)
        if colorspace == LAB: r, g, b = rgb_to_lab(r, g, b)
    if base != 1:
        r, g, b, a = [ch*base for ch in (r, g, b, a)]
    if base != 1 and isinstance(base, int):
        r, g, b, a = [int(ch) for ch in (r, g, b, a)]
    return r, g, b, a

</t>
<t tx="karstenw.20240123172917.260">def textpath(string, x=0, y=0, **kwargs):
    """ Returns a BezierPath from the given text string.
        The fontname, fontsize and fontweight can be given as optional parameters,
        width, height, lineheight and align are ignored.
        Only works with ASCII characters in the default fonts (Droid Sans, Droid Sans Mono, Droid Serif, Arial).
        See nodebox/font/glyph.py on how to activate other fonts.
    """
    
    fontname, fontsize, bold, italic, lineheight, align = font_mixin(**kwargs)
    
    w = bold and italic and "bold italic" or bold and "bold" or italic and "italic" or "normal"
    p = BezierPath()
    f = fontsize / 1000.0
    for ch in string:
        try: glyph = glyphs[fontname][w][ch]
        except:
            raise GlyphPathError( "no glyph path information for %s %s '%s'" % (w, fontname, ch) )
        for pt in glyph:
            if pt[0] == MOVETO:
                p.moveto(x+pt[1]*f, y-pt[2]*f)
            elif pt[0] == LINETO:
                p.lineto(x+pt[1]*f, y-pt[2]*f)
            elif pt[0] == CURVETO:
                p.curveto(x+pt[3]*f, y-pt[4]*f, x+pt[5]*f, y-pt[6]*f, x+pt[1]*f, y-pt[2]*f)
            elif pt[0] == CLOSE:
                p.closepath()
        x += textwidth(ch, font=fontname, fontsize=fontsize, bold=bold, italic=italic)
    return p

</t>
<t tx="karstenw.20240123172917.261">def _rnd_exp(bias=0.5): 
    bias = max(0, min(bias, 1)) * 10
    i = int(floor(bias))             # bias*10 =&gt; index in the _map curve.
    n = _RANDOM_MAP[i]               # If bias is 0.3, rnd()**2.33 will average 0.3.
    if bias &lt; 10:
        n += (_RANDOM_MAP[i+1]-n) * (bias-i)
    return n

</t>
<t tx="karstenw.20240123172917.262">def random(v1=1.0, v2=None, bias=None):
    """ Returns a number between v1 and v2, including v1 but not v2.
        The bias (0.0-1.0) represents preference towards lower or higher numbers.
    """
    if v2 is None:
        v1, v2 = 0, v1
    if bias is None:
        r = rnd()
    else:
        r = rnd()**_rnd_exp(bias)
    x = r * (v2-v1) + v1
    if isinstance(v1, int) and isinstance(v2, int):
        x = int(x)
    return x

</t>
<t tx="karstenw.20240123172917.263">def grid(cols, rows, colwidth=1, rowheight=1, shuffled=False):
    """ Yields (x,y)-tuples for the given number of rows and columns.
        The space between each point is determined by colwidth and colheight.
    """
    rows = range(int(rows))
    cols = range(int(cols))
    if shuffled:
        shuffle(rows)
        shuffle(cols)
    for y in rows:
        for x in cols:
            yield (x*colwidth, y*rowheight)

</t>
<t tx="karstenw.20240123172917.264">def files(path="*"):
    """ Returns a list of files found at the given path.
    """
    return glob(path)

</t>
<t tx="karstenw.20240123172917.265">class Prototype(object):
    
    @others
#=====================================================================================================

#--- EVENT HANDLER ------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240123172917.266">def __init__(self):
    """ A base class that allows on-the-fly extension.
        This means that external functions can be bound to it as methods,
        and properties set at runtime are copied correctly.
        Prototype can handle: 
        - functions (these become class methods),
        - immutable types (str, unicode, int, long, float, bool),
        - lists, tuples and dictionaries of immutable types, 
        - objects with a copy() method.
    """
    self._dynamic = {}

</t>
<t tx="karstenw.20240123172917.267">def _deepcopy(self, value):
    if isinstance(value, FunctionType):
        return instancemethod(value, self)
    elif hasattr(value, "copy"):
        return value.copy()
    elif isinstance(value, (list, tuple)):
        return [self._deepcopy(x) for x in value]
    elif isinstance(value, dict):
        return dict([(k, self._deepcopy(v)) for k,v in value.items()])
    elif isinstance(value, (str, bytes, int, long, float, bool)):
        return value
    else:
        # Biggest problem here is how to find/relink circular references.
        raise TypeError( "Prototype can't bind %s." % (str(value.__class__),) )

</t>
<t tx="karstenw.20240123172917.268">def _bind(self, key, value):
    """ Adds a new method or property to the prototype.
        For methods, the given function is expected to take the object (i.e. self) as first parameter.
        For properties, values can be: list, tuple, dict, str, unicode, int, long, float, bool,
        or an object with a copy() method.
        For example, we can define a Layer's custom draw() method in two ways:
        - By subclassing:
            class MyLayer(Layer):
                def draw(layer):
                    pass
            layer = MyLayer()
            layer.draw()
        - By function binding:
            def my_draw(layer):
                pass
            layer = Layer()
            layer._bind("draw", my_draw)
            layer.draw()
    """
    self._dynamic[key] = value
    object.__setattr__(self, key, self._deepcopy(value))
    
</t>
<t tx="karstenw.20240123172917.269">def set_method(self, function, name=None):
    """ Creates a dynamic method (with the given name) from the given function.
    """
    if not name: 
        name = function.__name__
    self._bind(name, function)

</t>
<t tx="karstenw.20240123172917.27">def blend(self, clr, t=0.5, colorspace=RGB):
    """ Returns a new color between the two colors.
        Parameter t is the amount to interpolate between the two colors 
        (0.0 equals the first color, 0.5 is half-way in between, etc.)
        Blending in CIE-LAB colorspace avoids "muddy" colors in the middle of the blend.
    """
    ch = zip(self.map(1, colorspace)[:3], clr.map(1, colorspace)[:3])
    r, g, b = [geometry.lerp(a, b, t) for a, b in ch]
    a = geometry.lerp(self.a, len(clr)==4 and clr[3] or 1, t)
    return Color(r, g, b, a, colorspace=colorspace)
    
</t>
<t tx="karstenw.20240123172917.270">def set_property(self, key, value):
    """ Adds a property to the prototype.
        Using this method ensures that dynamic properties are copied correctly - see inherit().
    """
    self._bind(key, value)

</t>
<t tx="karstenw.20240123172917.271">def inherit(self, prototype):
    """ Inherit all the dynamic properties and methods of another prototype.
    """
    for k,v in prototype._dynamic.items():
        self._bind(k,v)

</t>
<t tx="karstenw.20240123172917.272">class EventHandler:
    
    @others
</t>
<t tx="karstenw.20240123172917.273">def __init__(self):
    # Use __dict__ directly so we can do multiple inheritance in combination with Prototype:
    self.__dict__["enabled"] = True  # Receive events from the canvas?
    self.__dict__["focus"]   = False # True when this object receives the focus.
    self.__dict__["pressed"] = False # True when the mouse is pressed on this object.
    self.__dict__["dragged"] = False # True when the mouse is dragged on this object.
    self.__dict__["_queue"]  = []
    
</t>
<t tx="karstenw.20240123172917.274">def on_mouse_enter(self, mouse):
    pass
</t>
<t tx="karstenw.20240123172917.275">def on_mouse_leave(self, mouse):
    pass
</t>
<t tx="karstenw.20240123172917.276">def on_mouse_motion(self, mouse):
    pass
</t>
<t tx="karstenw.20240123172917.277">def on_mouse_press(self, mouse):
    pass
</t>
<t tx="karstenw.20240123172917.278">def on_mouse_release(self, mouse):
    pass
</t>
<t tx="karstenw.20240123172917.279">def on_mouse_drag(self, mouse):
    pass
</t>
<t tx="karstenw.20240123172917.28">def rotate(self, angle):
    """ Returns a new color with it's hue rotated on the RYB color wheel.
    """
    h, s, b = rgb_to_hsb(*self[:3])
    h, s, b = rotate_ryb(h, s, b, angle)
    return Color(h, s, b, self.a, colorspace=HSB)

</t>
<t tx="karstenw.20240123172917.280">def on_mouse_scroll(self, mouse):
    pass

</t>
<t tx="karstenw.20240123172917.281">def on_key_press(self, keys):
    pass
</t>
<t tx="karstenw.20240123172917.282">def on_key_release(self, keys):
    pass

# Instead of calling an event directly it could be queued,
# e.g. layer.queue_event(layer.on_mouse_press, canvas.mouse).
# layer.process_events() can then be called whenever desired,
# e.g. after the canvas has been drawn so that events can contain drawing commands.
</t>
<t tx="karstenw.20240123172917.283">def queue_event(self, event, *args):
    self._queue.append((event, args))
</t>
<t tx="karstenw.20240123172917.284">def process_events(self):
    for event, args in self._queue:
        event(*args)
    self._queue = []

# Note: there is no event propagation.
# Event propagation means that, for example, if a layer is pressed
# all its child (or parent) layers receive an on_mouse_press() event as well.
# If this kind of behavior is desired, it is the responsibility of custom subclasses of Layer.

</t>
<t tx="karstenw.20240123172917.285">class Transition(object):

    @others
</t>
<t tx="karstenw.20240123172917.286">def __init__(self, value, interpolation=SMOOTH):
    self._v0 = value # Previous value =&gt; Transition.start.
    self._vi = value # Current value  =&gt; Transition.current.
    self._v1 = value # Desired value  =&gt; Transition.stop.
    self._t0 = TIME  # Start time.
    self._t1 = TIME  # End time.
    self._interpolation = interpolation

</t>
<t tx="karstenw.20240123172917.287">def copy(self):
    t = Transition(None)
    t._v0 = self._v0
    t._vi = self._vi
    t._v1 = self._v1
    t._t0 = self._t0
    t._t1 = self._t1
    t._interpolation = self._interpolation
    return t

</t>
<t tx="karstenw.20240123172917.288">def get(self):
    """ Returns the transition stop value.
    """
    return self._v1
    
</t>
<t tx="karstenw.20240123172917.289">def set(self, value, duration=1.0):
    """ Sets the transition stop value, which will be reached in the given duration (seconds).
        Calling Transition.update() moves the Transition.current value toward Transition.stop.
    """
    if duration == 0:
        # If no duration is given, Transition.start = Transition.current = Transition.stop.
        self._vi = value
    self._v1 = value
    self._v0 = self._vi
    self._t0 = TIME # Now.
    self._t1 = TIME + duration

</t>
<t tx="karstenw.20240123172917.29">def background(*args, **kwargs):
    """ Sets the current background color.
    """
    global _background
    if args:
        _background = Color(*args, **kwargs)
        xywh = (GLint*4)(); glGetIntegerv(GL_VIEWPORT, xywh); x,y,w,h = xywh
        rect(x, y, w, h, fill=_background, stroke=None)   
    return _background

</t>
<t tx="karstenw.20240123172917.290">@property
def start(self):
    return self._v0
</t>
<t tx="karstenw.20240123172917.291">@property
def stop(self):
    return self._v1
</t>
<t tx="karstenw.20240123172917.292">@property 
def current(self): 
    return self._vi

</t>
<t tx="karstenw.20240123172917.293">@property
def done(self):
    return TIME &gt;= self._t1

</t>
<t tx="karstenw.20240123172917.294">def update(self):
    """ Calculates the new current value. Returns True when done.
        The transition approaches the desired value according to the interpolation:
        - LINEAR: even transition over the given duration time,
        - SMOOTH: transition goes slower at the beginning and end.
    """
    if TIME &gt;= self._t1 or self._vi is None:
        self._vi = self._v1
        return True
    else:
        # Calculate t: the elapsed time as a number between 0.0 and 1.0.
        t = (TIME-self._t0) / (self._t1-self._t0)
        if self._interpolation == LINEAR:
            self._vi = self._v0 + (self._v1-self._v0) * t
        else:
            self._vi = self._v0 + (self._v1-self._v0) * geometry.smoothstep(0.0, 1.0, t)
        return False

</t>
<t tx="karstenw.20240123172917.295">def _uid():
    global _UID; _UID+=1; return _UID

RELATIVE = "relative" # Origin point is stored as float, e.g. (0.5, 0.5).
ABSOLUTE = "absolute" # Origin point is stored as int, e.g. (100, 100).

</t>
<t tx="karstenw.20240123172917.296">class LayerRenderError(Exception):
    pass

</t>
<t tx="karstenw.20240123172917.297"># When Layer.clipped=True, children are clipped to the bounds of the layer.
# The layer clipping masks lazily changes size with the layer.
class LayerClippingMask(ClippingMask):
    @others
</t>
<t tx="karstenw.20240123172917.298">def __init__(self, layer):
    self.layer = layer
</t>
<t tx="karstenw.20240123172917.299">def draw(self, fill=(0,0,0,1), stroke=None):
    w = not self.layer.width  and geometry.INFINITE or self.layer.width
    h = not self.layer.height and geometry.INFINITE or self.layer.height
    rect(0, 0, w, h, fill=fill, stroke=stroke)

</t>
<t tx="karstenw.20240123172917.3">def precompile(function, *args, **kwargs):
    """ Creates an OpenGL Display List from the OpenGL commands in the given function.
        A Display List will precompile the commands and (if possible) store them in graphics memory.
        Returns an id which can be used with precompiled() to execute the cached commands.
    """
    id = glGenLists(1)
    glNewList(id, GL_COMPILE)
    function(*args, **kwargs)
    glEndList()
    return id
        
</t>
<t tx="karstenw.20240123172917.30">def fill(*args, **kwargs):
    """ Sets the current fill color for drawing primitives and paths.
    """
    global _fill
    if args:
        _fill = Color(*args, **kwargs)
    return _fill

fill(0) # The default fill is black.

</t>
<t tx="karstenw.20240123172917.300">class Layer(list, Prototype, EventHandler):

    @others
layer = Layer

</t>
<t tx="karstenw.20240123172917.301">def __init__(self, x=0, y=0, width=None, height=None, origin=(0,0), 
             scale=1.0, rotation=0, opacity=1.0, duration=0.0, name=None, 
             parent=None, **kwargs):
    """ Creates a new drawing layer that can be appended to the canvas.
        The duration defines the time (seconds) it takes to animate transformations or opacity.
        When the animation has terminated, layer.done=True.
    """
    if origin == CENTER:
        origin = (0.5,0.5)
        origin_mode = RELATIVE
    elif isinstance(origin[0], float) \
     and isinstance(origin[1], float):
        origin_mode = RELATIVE
    else:
        origin_mode = ABSOLUTE
    Prototype.__init__(self) # Facilitates extension on the fly.
    EventHandler.__init__(self)
    self._id       = _uid()
    self.name      = name                  # Layer name. Layers are accessible as ParentLayer.[name]
    self.canvas    = None                  # The canvas this layer is drawn to.
    self.parent    = parent                # The layer this layer is a child of.
    self._x        = Transition(x)         # Layer horizontal position in pixels, from the left.
    self._y        = Transition(y)         # Layer vertical position in pixels, from the bottom.
    self._width    = Transition(width)     # Layer width in pixels.
    self._height   = Transition(height)    # Layer height in pixels.
    self._dx       = Transition(origin[0]) # Transformation origin point.
    self._dy       = Transition(origin[1]) # Transformation origin point.
    self._origin   = origin_mode           # Origin point as RELATIVE or ABSOLUTE coordinates?
    self._scale    = Transition(scale)     # Layer width and height scale.
    self._rotation = Transition(rotation)  # Layer rotation.
    self._opacity  = Transition(opacity)   # Layer opacity.
    self.duration  = duration              # The time it takes to animate transformations.
    self.top       = True                  # Draw on top of or beneath parent?
    self.flipped   = False                 # Flip the layer horizontally?
    self.clipped   = False                 # Clip child layers to bounds?
    self.hidden    = False                 # Hide the layer?
    self._transform_cache = None           # Cache of the local transformation matrix.
    self._transform_stack = None           # Cache of the cumulative transformation matrix.
    self._clipping_mask   = LayerClippingMask(self)

</t>
<t tx="karstenw.20240123172917.302">@classmethod
def from_image(self, img, *args, **kwargs):
    """ Returns a new layer that renders the given image, and with the same size as the image.
        The layer's draw() method and an additional image property are set.
    """
    if not isinstance(img, Image):
        img = Image(img, data=kwargs.get("data"))
    kwargs.setdefault("width", img.width)
    kwargs.setdefault("height", img.height)
    def draw(layer):
        image(layer.image)
    layer = self(*args, **kwargs)
    layer.set_method(draw)
    layer.set_property("image", img)
    return layer
    
</t>
<t tx="karstenw.20240123172917.303">@classmethod
def from_function(self, function, *args, **kwargs):
    """ Returns a new layer that renders the drawing commands in the given function.
        The layer's draw() method is set.
    """
    def draw(layer):
        function(layer)
    layer = self(*args, **kwargs)
    layer.set_method(draw)
    return layer
    
</t>
<t tx="karstenw.20240123172917.304">def copy(self, parent=None, canvas=None):
    """ Returns a copy of the layer.
        All Layer properties will be copied, except for the new parent and canvas,
        which you need to define as optional parameters.
        This means that copies are not automatically appended to the parent layer or canvas.
    """
    layer           = self.__class__() # Create instance of the derived class, not Layer.
    layer.duration  = 0                # Copy all transitions instantly.
    layer.canvas    = canvas
    layer.parent    = parent
    layer.name      = self.name
    layer._x        = self._x.copy()
    layer._y        = self._y.copy()
    layer._width    = self._width.copy()
    layer._height   = self._height.copy()
    layer._origin   = self._origin
    layer._dx       = self._dx.copy()
    layer._dy       = self._dy.copy()
    layer._scale    = self._scale.copy()
    layer._rotation = self._rotation.copy()
    layer._opacity  = self._opacity.copy()
    layer.duration  = self.duration
    layer.top       = self.top
    layer.flipped   = self.flipped
    layer.clipped   = self.clipped
    layer.hidden    = self.hidden
    layer.enabled   = self.enabled
    # Use base Layer.extend(), we don't care about what subclass.extend() does.
    Layer.extend(layer, [child.copy() for child in self])
    # Inherit all the dynamic properties and methods.
    Prototype.inherit(layer, self)
    return layer

</t>
<t tx="karstenw.20240123172917.305">def __getattr__(self, key):
    """ Returns the given property, or the layer with the given name.
    """
    if key in self.__dict__: 
        return self.__dict__[key]
    for layer in self:
        if layer.name == key: 
            return layer
    raise AttributeError( "%s instance has no attribute '%s'" % (self.__class__.__name__, key) )

</t>
<t tx="karstenw.20240123172917.306">def _set_container(self, key, value):
    # If Layer.canvas is set to None, the canvas should no longer contain the layer.
    # If Layer.canvas is set to Canvas, this canvas should contain the layer.
    # Remove the layer from the old canvas/parent.
    # Append the layer to the new container.
    if self in (self.__dict__.get(key) or ()):
        self.__dict__[key].remove(self)
    if isinstance(value, list) and self not in value:
        list.append(value, self)
    self.__dict__[key] = value
    
</t>
<t tx="karstenw.20240123172917.307">def _get_canvas(self):
    return self.__dict__.get("canvas")
</t>
<t tx="karstenw.20240123172917.308">def _get_parent(self):
    return self.__dict__.get("parent")

</t>
<t tx="karstenw.20240123172917.309">def _set_canvas(self, canvas):
    self._set_container("canvas", canvas)        
</t>
<t tx="karstenw.20240123172917.31">def stroke(*args, **kwargs):
    """ Sets the current stroke color.
    """
    global _stroke
    if args:
        _stroke = Color(*args, **kwargs)
    return _stroke

</t>
<t tx="karstenw.20240123172917.310">def _set_parent(self, layer):
    self._set_container("parent", layer)

canvas = property(_get_canvas, _set_canvas)    
parent = property(_get_parent, _set_parent)

</t>
<t tx="karstenw.20240123172917.311">@property
def root(self):
    return self.parent and self.parent.root or self

</t>
<t tx="karstenw.20240123172917.312">@property
def layers(self):
    return self

</t>
<t tx="karstenw.20240123172917.313">def insert(self, index, layer):
    list.insert(self, index, layer)
    layer.__dict__["parent"] = self
</t>
<t tx="karstenw.20240123172917.314">def append(self, layer):
    list.append(self, layer)
    layer.__dict__["parent"] = self
</t>
<t tx="karstenw.20240123172917.315">def extend(self, layers):
    for layer in layers:
        Layer.append(self, layer)
</t>
<t tx="karstenw.20240123172917.316">def remove(self, layer):
    list.remove(self, layer)
    layer.__dict__["parent"] = None
</t>
<t tx="karstenw.20240123172917.317">def pop(self, index):
    layer = list.pop(self, index)
    layer.__dict__["parent"] = None
    return layer
    
</t>
<t tx="karstenw.20240123172917.318">def _get_x(self):
    return self._x.get()
</t>
<t tx="karstenw.20240123172917.319">def _get_y(self):
    return self._y.get()
</t>
<t tx="karstenw.20240123172917.32">def nofill():
    """ No current fill color.
    """
    global _fill
    _fill = None

</t>
<t tx="karstenw.20240123172917.320">def _get_width(self):
    return self._width.get()
</t>
<t tx="karstenw.20240123172917.321">def _get_height(self):
    return self._height.get()
</t>
<t tx="karstenw.20240123172917.322">def _get_scale(self):
    return self._scale.get()
</t>
<t tx="karstenw.20240123172917.323">def _get_rotation(self):
    return self._rotation.get()
</t>
<t tx="karstenw.20240123172917.324">def _get_opacity(self):
    return self._opacity.get()

</t>
<t tx="karstenw.20240123172917.325">def _set_x(self, x):
    self._transform_cache = None
    self._x.set(x, self.duration)
</t>
<t tx="karstenw.20240123172917.326">def _set_y(self, y):
    self._transform_cache = None
    self._y.set(y, self.duration)
</t>
<t tx="karstenw.20240123172917.327">def _set_width(self, width):
    self._transform_cache = None
    self._width.set(width, self.duration)
</t>
<t tx="karstenw.20240123172917.328">def _set_height(self, height):
    self._transform_cache = None
    self._height.set(height, self.duration)
</t>
<t tx="karstenw.20240123172917.329">def _set_scale(self, scale):
    self._transform_cache = None
    self._scale.set(scale, self.duration)
</t>
<t tx="karstenw.20240123172917.33">def nostroke():
    """ No current stroke color.
    """
    global _stroke
    _stroke = None

</t>
<t tx="karstenw.20240123172917.330">def _set_rotation(self, rotation):
    self._transform_cache = None
    self._rotation.set(rotation, self.duration)
</t>
<t tx="karstenw.20240123172917.331">def _set_opacity(self, opacity):
    self._opacity.set(opacity, self.duration)

x        = property(_get_x, _set_x)
y        = property(_get_y, _set_y)
width    = property(_get_width, _set_width)
height   = property(_get_height, _set_height)
scaling  = property(_get_scale, _set_scale)
rotation = property(_get_rotation, _set_rotation)
opacity  = property(_get_opacity, _set_opacity)

</t>
<t tx="karstenw.20240123172917.332">def _get_xy(self):
    return (self.x, self.y)
# (x,y)
</t>
<t tx="karstenw.20240123172917.333">def _set_xy(self, doublet):
    x,y = doublet
    self.x = x
    self.y = y
    
xy = property(_get_xy, _set_xy)

</t>
<t tx="karstenw.20240123172917.334">def _get_origin(self, relative=False):
    """ Returns the point (x,y) from which all layer transformations originate.
        When relative=True, x and y are defined percentually (0.0-1.0) in terms of width and height.
        In some cases x=0 or y=0 is returned:
        - For an infinite layer (width=None or height=None), we can't deduct the absolute origin
          from coordinates stored relatively (e.g. what is infinity*0.5?).
        - Vice versa, for an infinite layer we can't deduct the relative origin from coordinates
          stored absolute (e.g. what is 200/infinity?).
    """
    dx = self._dx.current
    dy = self._dy.current
    w  = self._width.current
    h  = self._height.current
    # Origin is stored as absolute coordinates and we want it relative.
    if self._origin == ABSOLUTE and relative:
        if w is None: w = 0
        if h is None: h = 0
        dx = w!=0 and dx/w or 0
        dy = h!=0 and dy/h or 0
    # Origin is stored as relative coordinates and we want it absolute.
    elif self._origin == RELATIVE and not relative:
        dx = w is not None and dx*w or 0
        dy = h is not None and dy*h or 0
    return dx, dy

</t>
<t tx="karstenw.20240123172917.335">def _set_origin(self, x, y, relative=False):
    """ Sets the transformation origin point in either absolute or relative coordinates.
        For example, if a layer is 400x200 pixels, setting the origin point to (200,100)
        all transformations (translate, rotate, scale) originate from the center.
    """
    self._transform_cache = None
    self._dx.set(x, self.duration)
    self._dy.set(y, self.duration)
    self._origin = relative and RELATIVE or ABSOLUTE

</t>
<t tx="karstenw.20240123172917.336">def origin(self, x=None, y=None, relative=False):
    """ Sets or returns the point (x,y) from which all layer transformations originate.
    """
    if x is not None:
        if x == CENTER: 
            x, y, relative = 0.5, 0.5, True
        if y is not None: 
            self._set_origin(x, y, relative)
    return self._get_origin(relative)

</t>
<t tx="karstenw.20240123172917.337">def _get_relative_origin(self):
    return self.origin(relative=True)
</t>
<t tx="karstenw.20240123172917.338">def _set_relative_origin(self, xy):
    self._set_origin(xy[0], xy[1], relative=True)
    
relative_origin = property(_get_relative_origin, _set_relative_origin)

</t>
<t tx="karstenw.20240123172917.339">def _get_absolute_origin(self):
    return self.origin(relative=False)
</t>
<t tx="karstenw.20240123172917.34">def strokewidth(width=None):
    """ Sets the outline stroke width.
    """
    # Note: strokewidth is clamped to integers (e.g. 0.2 =&gt; 1), 
    # but finer lines can be achieved visually with a transparent stroke.
    # Thicker strokewidth results in ugly (i.e. no) line caps.
    global _strokewidth
    if width is not None:
        _strokewidth = width
        glLineWidth(width)
    return _strokewidth

SOLID  = "solid"
DOTTED = "dotted"
DASHED = "dashed"

</t>
<t tx="karstenw.20240123172917.340">def _set_absolute_origin(self, xy):
    self._set_origin(xy[0], xy[1], relative=False)
    
absolute_origin = property(_get_absolute_origin, _set_absolute_origin)

</t>
<t tx="karstenw.20240123172917.341">def _get_visible(self):
    return not self.hidden
</t>
<t tx="karstenw.20240123172917.342">def _set_visible(self, b):
    self.hidden = not b
    
visible = property(_get_visible, _set_visible)

</t>
<t tx="karstenw.20240123172917.343">def translate(self, x, y):
    self.x += x
    self.y += y
    
</t>
<t tx="karstenw.20240123172917.344">def rotate(self, angle):
    self.rotation += angle
    
</t>
<t tx="karstenw.20240123172917.345">def scale(self, f):
    self.scaling *= f
    
</t>
<t tx="karstenw.20240123172917.346">def flip(self):
    self.flipped = not self.flipped

</t>
<t tx="karstenw.20240123172917.347">def _update(self):
    """ Called each frame from canvas._update() to update the layer transitions.
    """
    done  = self._x.update()
    done &amp;= self._y.update()
    done &amp;= self._width.update()
    done &amp;= self._height.update()
    done &amp;= self._dx.update()
    done &amp;= self._dy.update()
    done &amp;= self._scale.update()
    done &amp;= self._rotation.update()
    if not done: # i.e. the layer is being transformed
        self._transform_cache = None
    self._opacity.update()
    self.update()
    for layer in self:
        layer._update()
        
</t>
<t tx="karstenw.20240123172917.348">def update(self):
    """Override this method to provide custom updating code.
    """
    pass

</t>
<t tx="karstenw.20240123172917.349">@property
def done(self):
    """ Returns True when all transitions have finished.
    """
    return self._x.done \
       and self._y.done \
       and self._width.done \
       and self._height.done \
       and self._dx.done \
       and self._dy.done \
       and self._scale.done \
       and self._rotation.done \
       and self._opacity.done

</t>
<t tx="karstenw.20240123172917.35">def strokestyle(style=None):
    """ Sets the outline stroke style (SOLID / DOTTED / DASHED).
    """
    global _strokestyle
    if style is not None and style != _strokestyle:
        _strokestyle = style
        glLineDash(style)
    return _strokestyle
    
</t>
<t tx="karstenw.20240123172917.350">def _draw(self):
    """ Draws the transformed layer and all of its children.
    """
    if self.hidden:
        return
    glPushMatrix()
    # Be careful that the transformations happen in the same order in Layer._transform().
    # translate =&gt; flip =&gt; rotate =&gt; scale =&gt; origin.
    # Center the contents around the origin point.
    dx, dy = self.origin(relative=False)
    glTranslatef(round(self._x.current), round(self._y.current), 0)
    if self.flipped:
        glScalef(-1, 1, 1)
    glRotatef(self._rotation.current, 0, 0, 1)
    glScalef(self._scale.current, self._scale.current, 1)
    # Enable clipping mask if Layer.clipped=True.
    if self.clipped:
        beginclip(self._clipping_mask)
    # Draw child layers below.
    for layer in self:
        if layer.top is False:
            layer._draw()
    # Draw layer.
    global _alpha
    _alpha = self._opacity.current # XXX should also affect child layers?
    glPushMatrix()
    glTranslatef(-round(dx), -round(dy), 0) # Layers are drawn relative from parent origin.
    self.draw()
    glPopMatrix()
    _alpha = 1
    # Draw child layers on top.
    for layer in self:
        if layer.top is True:
            layer._draw()
    if self.clipped:
        endclip()
    glPopMatrix()
    
</t>
<t tx="karstenw.20240123172917.351">def draw(self):
    """Override this method to provide custom drawing code for this layer.
        At this point, the layer is correctly transformed.
    """
    pass
    
</t>
<t tx="karstenw.20240123172917.352">def render(self):
    """ Returns the layer as a flattened image.
        The layer and all of its children need to have width and height set.
    """
    b = self.bounds
    if geometry.INFINITE in (b.x, b.y, b.width, b.height):
        raise LayerRenderError( "can't render layer of infinite size" )
    return render(lambda: (translate(-b.x,-b.y), self._draw()), b.width, b.height)
        
</t>
<t tx="karstenw.20240123172917.353">def layer_at(self, x, y, clipped=False, enabled=False, transformed=True, _covered=False):
    """ Returns the topmost layer containing the mouse position, None otherwise.
        With clipped=True, no parts of child layers outside the parent's bounds are checked.
        With enabled=True, only enabled layers are checked (useful for events).
    """
    if self.hidden:
        # Don't do costly operations on layers the user can't see.
        return None
    if enabled and not self.enabled:
        # Skip disabled layers during event propagation.
        return None
    if _covered:
        # An ancestor is blocking this layer, so we can't select it.
        return None
    hit = self.contains(x, y, transformed)
    if clipped:
        # If (x,y) is not inside the clipped bounds, return None.
        # If children protruding beyond the layer's bounds are clipped,
        # we only need to look at children on top of the layer.
        # Each child is drawn on top of the previous child,
        # so we hit test them in reverse order (highest-first).
        if not hit: 
            return None
        children = [layer for layer in reversed(self) if layer.top is True]
    else:
        # Otherwise, traverse all children in on-top-first order to avoid
        # selecting a child underneath the layer that is in reality
        # covered by a peer on top of the layer, further down the list.
        children = sorted(reversed(self), key=lambda layer: not layer.top)
    for child in children:
        # An ancestor (e.g. grandparent) may be covering the child.
        # This happens when it hit tested and is somewhere on top of the child.
        # We keep a recursive covered-state to verify visibility.
        # The covered-state starts as False, but stays True once it switches.
        _covered = _covered or (hit and not child.top)
        child = child.layer_at(x, y, clipped, enabled, transformed, _covered)
        if child is not None:
            # Note: "if child:" won't work because it can be an empty list (no children). 
            # Should be improved by not having Layer inherit from list.
            return child
    if hit:
        return self
    else:
        return None
    
</t>
<t tx="karstenw.20240123172917.354">def _transform(self, local=True):
    """ Returns the transformation matrix of the layer:
        a calculated state of its translation, rotation and scaling.
        If local=False, prepends all transformations of the parent layers,
        i.e. you get the absolute transformation state of a nested layer.
    """
    if self._transform_cache is None:
        # Calculate the local transformation matrix.
        # Be careful that the transformations happen in the same order in Layer._draw().
        # translate =&gt; flip =&gt; rotate =&gt; scale =&gt; origin.
        tf = Transform()
        dx, dy = self.origin(relative=False)
        tf.translate(round(self._x.current), round(self._y.current))
        if self.flipped:
            tf.scale(-1, 1)
        tf.rotate(self._rotation.current)
        tf.scale(self._scale.current, self._scale.current)
        tf.translate(-round(dx), -round(dy))
        self._transform_cache = tf
        # Flush the cumulative transformation cache of all children.
        def _flush(layer):
            layer._transform_stack = None
        self.traverse(_flush)
    if not local:
        # Return the cumulative transformation matrix.
        # All of the parent transformation states need to be up to date.
        # If not, we need to recalculate the whole chain.
        if self._transform_stack is None:
            if self.parent is None:
                self._transform_stack = self._transform_cache.copy()
            else:
                # Accumulate all the parent layer transformations.
                # In the process, we update the transformation state of any outdated parent.
                dx, dy = self.parent.origin(relative=False)
                # Layers are drawn relative from parent origin.
                tf = self.parent._transform(local=False).copy()
                tf.translate(round(dx), round(dy))
                self._transform_stack = self._transform_cache.copy()
                self._transform_stack.prepend(tf)          
        return self._transform_stack
    return self._transform_cache

</t>
<t tx="karstenw.20240123172917.355">@property
def transform(self):
    return self._transform(local=False)

</t>
<t tx="karstenw.20240123172917.356">def _bounds(self, local=True):
    """ Returns the rectangle that encompasses the transformed layer and its children.
        If one of the children has width=None or height=None, bounds will be infinite.
    """
    w = self._width.current; w = w is None and geometry.INFINITE or w
    h = self._height.current; h = h is None and geometry.INFINITE or h
    # Find the transformed bounds of the layer:
    p = self.transform.map([(0,0), (w,0), (w,h), (0,h)])
    x = min(p[0][0], p[1][0], p[2][0], p[3][0])
    y = min(p[0][1], p[1][1], p[2][1], p[3][1])
    w = max(p[0][0], p[1][0], p[2][0], p[3][0]) - x
    h = max(p[0][1], p[1][1], p[2][1], p[3][1]) - y
    b = geometry.Bounds(x, y, w, h)
    if not local:
        for child in self: 
            b = b.union(child.bounds)
    return b

</t>
<t tx="karstenw.20240123172917.357">@property
def bounds(self):
    return self._bounds(local=False)

</t>
<t tx="karstenw.20240123172917.358">def contains(self, x, y, transformed=True):
    """ Returns True if (x,y) falls within the layer's rectangular area.
        Useful for GUI elements: with transformed=False the calculations are much faster;
        and it will report correctly as long as the layer (or parent layer)
        is not rotated or scaled, and has its origin at (0,0).
    """
    w = self._width.current; w = w is None and geometry.INFINITE or w
    h = self._height.current; h = h is None and geometry.INFINITE or h
    if not transformed:
        x0, y0 = self.absolute_position()
        return x0 &lt;= x &lt;= x0+w \
           and y0 &lt;= y &lt;= y0+h
    # Find the transformed bounds of the layer:
    p = self.transform.map([(0,0), (w,0), (w,h), (0,h)])
    return geometry.point_in_polygon(p, x, y)
    
hit_test = contains

</t>
<t tx="karstenw.20240123172917.359">def absolute_position(self, root=None):
    """ Returns the absolute (x,y) position (i.e. cumulative with parent position).
    """
    x = 0
    y = 0
    layer = self
    while layer is not None and layer != root:
        x += layer.x
        y += layer.y
        layer = layer.parent
    return x, y

</t>
<t tx="karstenw.20240123172917.36">def glLineDash(style):
    if style == SOLID:
        glDisable(GL_LINE_STIPPLE)
    elif style == DOTTED:
        glEnable(GL_LINE_STIPPLE); glLineStipple(0, 0x0101)
    elif style == DASHED:
        glEnable(GL_LINE_STIPPLE); glLineStipple(1, 0x000F)

</t>
<t tx="karstenw.20240123172917.360">def traverse(self, visit=lambda layer: None):
    """ Recurses the layer structure and calls visit() on each child layer.
    """
    visit(self)
    [layer.traverse(visit) for layer in self]
    
</t>
<t tx="karstenw.20240123172917.361">def __repr__(self):
    return "Layer(%sx=%.2f, y=%.2f, scale=%.2f, rotation=%.2f, opacity=%.2f, duration=%.2f)" % (
        self.name is not None and "name='%s', " % self.name or "", 
        self.x, 
        self.y, 
        self.scaling, 
        self.rotation, 
        self.opacity, 
        self.duration
    )
    
</t>
<t tx="karstenw.20240123172917.362">def __eq__(self, other):
    return isinstance(other, Layer) and self._id == other._id
</t>
<t tx="karstenw.20240123172917.363">def __ne__(self, other):
    return not self.__eq__(other)

</t>
<t tx="karstenw.20240123172917.364">class Group(Layer):
    
    @others
group = Group

</t>
<t tx="karstenw.20240123172917.365">def __init__(self, *args, **kwargs):
    """ A layer that serves as a container for other layers.
        It has no width or height and doesn't draw anything.
    """
    Layer.__init__(self, *args, **kwargs)
    self._set_width(0)
    self._set_height(0)
    
</t>
<t tx="karstenw.20240123172917.366">@classmethod
def from_image(*args, **kwargs):
    raise NotImplementedError()

</t>
<t tx="karstenw.20240123172917.367">@classmethod
def from_function(*args, **kwargs):
    raise NotImplementedError()

</t>
<t tx="karstenw.20240123172917.368">@property
def width(self):
    return 0
</t>
<t tx="karstenw.20240123172917.369">@property
def height(self):
    return 0
    
</t>
<t tx="karstenw.20240123172917.37">def outputmode(mode=None):
    raise NotImplementedError()

</t>
<t tx="karstenw.20240123172917.370">def layer_at(self, x, y, clipped=False, enabled=False, transformed=True, _covered=False):
    # Ignores clipped=True for Group (since it has no width or height).
    for child in reversed(self):
        layer = child.layer_at(x, y, clipped, enabled, transformed, _covered)
        if layer:
            return layer

</t>
<t tx="karstenw.20240123172917.371">class Mouse(Point):
    
    @others
#--- KEYBOARD ----------------------------------------------------------------------------------------

# Key codes:
BACKSPACE = "backspace"
DELETE    = "delete"
TAB       = "tab"
ENTER     = "enter"
SPACE     = "space"
ESCAPE    = "escape"
UP        = "up"
DOWN      = "down"
LEFT      = "left"
RIGHT     = "right"

# Key modifiers:
OPTION  = \
ALT     = "option"
CTRL    = "ctrl"
SHIFT   = "shift"
COMMAND = "command"

MODIFIERS = (OPTION, CTRL, SHIFT, COMMAND)

</t>
<t tx="karstenw.20240123172917.372">def __init__(self, canvas, x=0, y=0):
    """ Keeps track of the mouse position on the canvas, buttons pressed and the cursor icon.
    """
    Point.__init__(self, x, y)
    self._canvas   = canvas
    self._cursor   = DEFAULT    # Mouse cursor: CROSS, HAND, HIDDEN, TEXT, WAIT.
    self._button   = None       # Mouse button pressed: LEFT, RIGHT, MIDDLE.
    self.modifiers = []         # Mouse button modifiers: CTRL, SHIFT, OPTION.
    self.pressed   = False      # True if the mouse button is pressed.
    self.dragged   = False      # True if the mouse is dragged.
    self.scroll    = Point(0,0) # Scroll offset.
    self.dx        = 0          # Relative offset from previous horizontal position.
    self.dy        = 0          # Relative offset from previous vertical position.

# Backwards compatibility due to an old typo:
</t>
<t tx="karstenw.20240123172917.373">@property
def vx(self):
    return self.dx
</t>
<t tx="karstenw.20240123172917.374">@property
def vy(self):
    return self.dy

</t>
<t tx="karstenw.20240123172917.375">@property
def relative_x(self):
    try: return float(self.x) / self._canvas.width
    except ZeroDivisionError:
        return 0
</t>
<t tx="karstenw.20240123172917.376">@property
def relative_y(self):
    try: return float(self.y) / self._canvas.height
    except ZeroDivisionError:
        return 0

</t>
<t tx="karstenw.20240123172917.377">def _get_cursor(self):
    return self._cursor
</t>
<t tx="karstenw.20240123172917.378">def _set_cursor(self, mode):
    self._cursor = mode != DEFAULT and mode or None
    if mode == HIDDEN:
        self._canvas._window.set_mouse_visible(False); return
    self._canvas._window.set_mouse_cursor(
        self._canvas._window.get_system_mouse_cursor(
            self._cursor))
    
cursor = property(_get_cursor, _set_cursor)

</t>
<t tx="karstenw.20240123172917.379">def _get_button(self):
    return self._button
</t>
<t tx="karstenw.20240123172917.38">def colormode(mode=None, range=1.0):
    raise NotImplementedError()

</t>
<t tx="karstenw.20240123172917.380">def _set_button(self, button):
    self._button = \
        button == pyglet.window.mouse.LEFT   and LEFT or \
        button == pyglet.window.mouse.RIGHT  and RIGHT or \
        button == pyglet.window.mouse.MIDDLE and MIDDLE or None
        
button = property(_get_button, _set_button)

</t>
<t tx="karstenw.20240123172917.381">def __repr__(self):
    return "Mouse(x=%.1f, y=%.1f, pressed=%s, dragged=%s)" % (
        self.x, self.y, repr(self.pressed), repr(self.dragged))

</t>
<t tx="karstenw.20240123172917.382">class Keys(list):
    
    @others
</t>
<t tx="karstenw.20240123172917.383">def __init__(self, canvas):
    """ Keeps track of the keys pressed and any modifiers (e.g. shift or control key).
    """
    self._canvas   = canvas
    self.code      = None   # Last key pressed
    self.char      = ""     # Last key character representation (i.e., SHIFT + "a" = "A").
    self.modifiers = []     # Modifier keys pressed (OPTION, CTRL, SHIFT, COMMAND).
    self.pressed   = False


</t>
<t tx="karstenw.20240123172917.384">def append(self, code):
    code = self._decode(code)
    if code in MODIFIERS:
        self.modifiers.append(code)
    list.append(self, code)
    self.code = self[-1]

</t>
<t tx="karstenw.20240123172917.385">def remove(self, code):
    code = self._decode(code)
    if code in MODIFIERS:
        self.modifiers.remove(code)

    if code in self:              # some window managers catch keys in weird manner
        list.remove(self, code)   # .. so we may be in situation where no key code exists in our list

    self.code = len(self) &gt; 0 and self[-1] or None

</t>
<t tx="karstenw.20240123172917.386">def _decode(self, code):
    if not isinstance(code, Number):
        s = code
    else:
        s = pyglet.window.key.symbol_string(code)         # 65288 =&gt; "BACKSPACE"
        s = s.lower()                                     # "BACKSPACE" =&gt; "backspace"
        s = s.lstrip("_")                                 # "_1" =&gt; "1"
        s = s.replace("return", ENTER)                    # "return" =&gt; "enter"
        s = s.replace("num_", "")                         # "num_space" =&gt; "space"
        s = s.endswith(MODIFIERS) and s.lstrip("lr") or s # "lshift" =&gt; "shift"
    return s
            
</t>
<t tx="karstenw.20240123172917.387">def __repr__(self):
    return "Keys(char=%s, code=%s, modifiers=%s, pressed=%s)" % (
        repr(self.char), repr(iter(self)), repr(self.modifiers), repr(self.pressed))

</t>
<t tx="karstenw.20240123172917.388">def _configure(settings):
    """ Returns a pyglet.gl.Config object from the given dictionary of settings.
        If the settings are not supported, returns the default settings.
    """
    # screen = pyglet.window.get_platform().get_default_display().get_default_screen()
    screen, conf = getscreenconf()

    c = pyglet.gl.Config(**settings)
    try:
        c = screen.get_best_config(c)
    except pyglet.window.NoSuchConfigException:
        # Probably the hardwarde doesn't support multisampling.
        # We can still do some anti-aliasing by turning on GL_LINE_SMOOTH.
        c = pyglet.gl.Config() 
        c = screen.get_best_config(c)
    return c

</t>
<t tx="karstenw.20240123172917.389">class Canvas(list, Prototype, EventHandler):

    @others
</t>
<t tx="karstenw.20240123172917.39">def rgb_to_hsb(r, g, b):
    """ Converts the given R,G,B values to H,S,B (between 0.0-1.0).
    """
    h, s, v = 0, 0, max(r, g, b)
    d = v - min(r, g, b)
    if v != 0:
        s = d / float(v)
    if s != 0:
        if   r == v: h = 0 + (g-b) / d
        elif g == v: h = 2 + (b-r) / d
        else       : h = 4 + (r-g) / d
    h = h / 6.0 % 1
    return h, s, v

</t>
<t tx="karstenw.20240123172917.390">def __init__(self, width=640, height=480, name="NodeBox for OpenGL", resizable=False, border=True, settings=OPTIMAL, vsync=True):
    """ The main application window containing the drawing canvas.
        It is opened when Canvas.run() is called.
        It is a collection of drawable Layer objects, and it has its own draw() method.
        This method must be overridden with your own drawing commands, which will be executed each frame.
        Event handlers for keyboard and mouse interaction can also be overriden.
        Events will be passed to layers that have been appended to the canvas.
    """
    window = dict(
          caption = name,
          visible = False,
            width = width,
           height = height,
        resizable = resizable,
            style = border is False and WINDOW_BORDERLESS or WINDOW_DEFAULT,
           config = _configure(settings),
            vsync = vsync
    )
    Prototype.__init__(self)
    EventHandler.__init__(self)
    self.profiler                 = Profiler(self)
    self._window                  = pyglet.window.Window(**window)
    self._fps                     = 60          # Frames per second.
    self._frame                   = 0           # The current frame.
    self._elapsed                 = 0           # dt = time elapsed since last frame.
    self._active                  = False       # Application is running?
    self.paused                   = False       # Pause animation?
    self._mouse                   = Mouse(self) # The mouse cursor location. 
    self._keys                    = Keys(self)  # The keys pressed on the keyboard.
    self._focus                   = None        # The layer being focused by the mouse.
    # Mouse and keyboard events:
    self._window.on_mouse_enter   = self._on_mouse_enter
    self._window.on_mouse_leave   = self._on_mouse_leave
    self._window.on_mouse_motion  = self._on_mouse_motion
    self._window.on_mouse_press   = self._on_mouse_press
    self._window.on_mouse_release = self._on_mouse_release
    self._window.on_mouse_drag    = self._on_mouse_drag
    self._window.on_mouse_scroll  = self._on_mouse_scroll
    self._window.on_key_pressed   = False
    self._window.on_key_press     = self._on_key_press
    self._window.on_key_release   = self._on_key_release
    self._window.on_text          = self._on_text
    self._window.on_text_motion   = self._on_text_motion
    self._window.on_move          = self._on_move
    self._window.on_resize        = self._on_resize
    self._window.on_close         = self.stop

</t>
<t tx="karstenw.20240123172917.391">def _get_name(self):
    return self._window.caption
</t>
<t tx="karstenw.20240123172917.392">def _set_name(self, string):
    self._window.set_caption(string)
    
name = property(_get_name, _set_name)

</t>
<t tx="karstenw.20240123172917.393">def _get_vsync(self):
    return self._window.vsync
</t>
<t tx="karstenw.20240123172917.394">def _set_vsync(self, bool):
    self._window.set_vsync(bool)
    
vsync = property(_get_vsync, _set_vsync)

</t>
<t tx="karstenw.20240123172917.395">@property
def layers(self):
    return self

</t>
<t tx="karstenw.20240123172917.396">def insert(self, index, layer):
    list.insert(self, index, layer)
    layer.__dict__["canvas"] = self
</t>
<t tx="karstenw.20240123172917.397">def append(self, layer):
    list.append(self, layer)
    layer.__dict__["canvas"] = self
</t>
<t tx="karstenw.20240123172917.398">def extend(self, layers):
    for layer in layers:
        self.append(layer)
</t>
<t tx="karstenw.20240123172917.399">def remove(self, layer):
    list.remove(self, layer)
    layer.__dict__["canvas"] = None
</t>
<t tx="karstenw.20240123172917.4">def precompiled(id):
    """ Executes the Display List program with the given id.
    """
    glCallList(id)
        
</t>
<t tx="karstenw.20240123172917.40">def hsb_to_rgb(h, s, v):
    """ Converts the given H,S,B color values to R,G,B (between 0.0-1.0).
    """
    if s == 0: 
        return v, v, v
    h = h % 1 * 6.0
    i = floor(h)
    f = h - i
    x = v * (1-s)
    y = v * (1-s * f)
    z = v * (1-s * (1-f))
    if i &gt; 4:
        return v, x, y
    return [(v,z,x), (y,v,x), (x,v,z), (x,y,v), (z,x,v)][int(i)]
    
</t>
<t tx="karstenw.20240123172917.400">def pop(self, index):
    layer = list.pop(index)
    layer.__dict__["canvas"] = None
    return layer
    
</t>
<t tx="karstenw.20240123172917.401">def _get_x(self):
    return self._window.get_location()[0]
</t>
<t tx="karstenw.20240123172917.402">def _set_x(self, v):
    self._window.set_location(v, self.y)
</t>
<t tx="karstenw.20240123172917.403">def _get_y(self):
    return self._window.get_location()[1]
</t>
<t tx="karstenw.20240123172917.404">def _set_y(self, v):
    self._window.set_location(self.x, v)
</t>
<t tx="karstenw.20240123172917.405">def _get_xy(self):
    return (self.x, self.y)
# (x,y)
</t>
<t tx="karstenw.20240123172917.406">def _set_xy(self, doublet):
    x,y = doublet
    self.x = x
    self.y = y
</t>
<t tx="karstenw.20240123172917.407">def _get_width(self):
    return self._window.width
</t>
<t tx="karstenw.20240123172917.408">def _get_height(self):
    return self._window.height
</t>
<t tx="karstenw.20240123172917.409">def _get_size(self):
    return (self.width, self.height)
</t>
<t tx="karstenw.20240123172917.41">def rgb_to_xyz(r, g, b):
    """ Converts the given R,G,B values to CIE X,Y,Z (between 0.0-1.0).
    """
    r, g, b = [ch &gt; 0.04045 and ((ch+0.055) / 1.055) ** 2.4 or ch / 12.92 for ch in (r, g, b)]
    r, g, b = [ch * 100.0 for ch in (r, g, b)]
    r, g, b = ( # Observer = 2, Illuminant = D65
        r * 0.4124 + g * 0.3576 + b * 0.1805,
        r * 0.2126 + g * 0.7152 + b * 0.0722,
        r * 0.0193 + g * 0.1192 + b * 0.9505)
    return r/95.047, g/100.0, b/108.883

</t>
<t tx="karstenw.20240123172917.410">def _set_width(self, v):
    self._window.width = v
</t>
<t tx="karstenw.20240123172917.411">def _set_height(self, v):
    self._window.height = v
# (w,h)
</t>
<t tx="karstenw.20240123172917.412">def _set_size(self, doublet):
    w,h = doublet
    self.width  = w
    self.height = h

x      = property(_get_x, _set_x)
y      = property(_get_y, _set_y)
xy     = property(_get_xy, _set_xy)
width  = property(_get_width, _set_width)
height = property(_get_height, _set_height)
size   = property(_get_size, _set_size)

</t>
<t tx="karstenw.20240123172917.413">def _get_fullscreen(self):
    return self._window.fullscreen
</t>
<t tx="karstenw.20240123172917.414">def _set_fullscreen(self, mode=True):
    self._window.set_fullscreen(mode)
    
fullscreen = property(_get_fullscreen, _set_fullscreen)

</t>
<t tx="karstenw.20240123172917.415">@property
def screen(self):
    #return pyglet.window.get_platform().get_default_display().get_default_screen()
    screen, _ = getscreenconf()
    return screen


</t>
<t tx="karstenw.20240123172917.416">@property
def frame(self):
    """ Yields the current frame number.
    """
    return self._frame

</t>
<t tx="karstenw.20240123172917.417">@property
def elapsed(self):
    """ Yields the elapsed time since last frame.
    """
    return self._elapsed
    
dt = elapsed

</t>
<t tx="karstenw.20240123172917.418">@property
def mouse(self):
    """ Yields a Point(x, y) with the mouse position on the canvas.
    """
    return self._mouse

</t>
<t tx="karstenw.20240123172917.419">@property
def keys(self):
    return self._keys
    
</t>
<t tx="karstenw.20240123172917.42">def xyz_to_rgb(x, y, z):
    """ Converts the given CIE X,Y,Z color values to R,G,B (between 0.0-1.0).
    """
    x, y, z = x*95.047, y*100.0, z*108.883
    x, y, z = [ch / 100.0 for ch in (x, y, z)]
    r = x *  3.2406 + y * -1.5372 + z * -0.4986
    g = x * -0.9689 + y *  1.8758 + z *  0.0415
    b = x * -0.0557 + y * -0.2040 + z *  1.0570
    r, g, b = [ch &gt; 0.0031308 and 1.055 * ch**(1/2.4) - 0.055 or ch * 12.92 for ch in (r, g, b)]
    return r, g, b

</t>
<t tx="karstenw.20240123172917.420">@property # Backwards compatibility.
def key(self):
    return self._keys
    
</t>
<t tx="karstenw.20240123172917.421">@property
def focus(self):
    return self._focus
    
#--- Event dispatchers ------------------------------
# First events are dispatched, then update() and draw() are called.

</t>
<t tx="karstenw.20240123172917.422">def layer_at(self, x, y, **kwargs):
    """ Find the topmost layer at the specified coordinates.
        This method returns None if no layer was found.
    """
    for layer in reversed(self):
        layer = layer.layer_at(x, y, **kwargs)
        if layer is not None:
            return layer
    return None

</t>
<t tx="karstenw.20240123172917.423">def _on_mouse_enter(self, x, y):
    self._mouse.x = x
    self._mouse.y = y
    self.on_mouse_enter(self._mouse)
    
</t>
<t tx="karstenw.20240123172917.424">def _on_mouse_leave(self, x, y):
    self._mouse.x = x
    self._mouse.y = y
    self.on_mouse_leave(self._mouse)
    # When the mouse leaves the canvas, no layer has the focus.
    if self._focus is not None:
        self._focus.on_mouse_leave(self._mouse)
        self._focus.focus   = False
        self._focus.pressed = False
        self._focus.dragged = False
        self._focus = None
    
</t>
<t tx="karstenw.20240123172917.425">def _on_mouse_motion(self, x, y, dx, dy):
    self._mouse.x  = x
    self._mouse.y  = y
    self._mouse.dx = int(dx)
    self._mouse.dy = int(dy)
    self.on_mouse_motion(self._mouse)
    # Get the topmost layer over which the mouse is hovering.
    layer = self.layer_at(x, y, enabled=True)
    # If the layer differs from the layer which currently has the focus,
    # or the mouse is not over any layer, remove the current focus.
    if self._focus is not None and (self._focus != layer or not self._focus.contains(x,y)):
        self._focus.on_mouse_leave(self._mouse)
        self._focus.focus = False
        self._focus = None
    # Set the focus.
    if self.focus != layer and layer is not None:
        self._focus = layer
        self._focus.focus = True
        self._focus.on_mouse_enter(self._mouse)
    # Propagate mouse motion to layer with the focus.
    if self._focus is not None:
        self._focus.on_mouse_motion(self._mouse)

</t>
<t tx="karstenw.20240123172917.426">def _on_mouse_press(self, x, y, button, modifiers):
    self._mouse.pressed   = True
    self._mouse.button    = button
    self._mouse.modifiers = [a for (a,b) in (
          (CTRL, pyglet.window.key.MOD_CTRL), 
         (SHIFT, pyglet.window.key.MOD_SHIFT), 
        (OPTION, pyglet.window.key.MOD_OPTION)) if modifiers &amp; b]
    self.on_mouse_press(self._mouse)
    # Propagate mouse clicking to the layer with the focus.
    if self._focus is not None:
        self._focus.pressed = True
        self._focus.on_mouse_press(self._mouse)
    
</t>
<t tx="karstenw.20240123172917.427">def _on_mouse_release(self, x, y, button, modifiers):
    if self._focus is not None:
        self._focus.on_mouse_release(self._mouse)
        self._focus.pressed = False
        self._focus.dragged = False
    self.on_mouse_release(self._mouse)
    self._mouse.button    = None
    self._mouse.modifiers = []
    self._mouse.pressed   = False
    self._mouse.dragged   = False
    if self._focus is not None:
        # Get the topmost layer over which the mouse is hovering.
        layer = self.layer_at(x, y, enabled=True)
        # If the mouse is no longer over the layer with the focus
        # (this can happen after dragging), remove the focus.
        if self._focus != layer or not self._focus.contains(x,y):
            self._focus.on_mouse_leave(self._mouse)
            self._focus.focus = False
            self._focus = None
        # Propagate mouse to the layer with the focus.
        if self._focus != layer and layer is not None:
            layer.focus = True
            layer.on_mouse_enter(self._mouse)
        self._focus = layer

</t>
<t tx="karstenw.20240123172917.428">def _on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):
    self._mouse.dragged   = True
    self._mouse.x         = x
    self._mouse.y         = y
    self._mouse.dx        = int(dx)
    self._mouse.dy        = int(dy)
    self._mouse.modifiers = [a for (a,b) in (
          (CTRL, pyglet.window.key.MOD_CTRL), 
         (SHIFT, pyglet.window.key.MOD_SHIFT), 
        (OPTION, pyglet.window.key.MOD_OPTION)) if modifiers &amp; b]
    # XXX also needs to log buttons.
    self.on_mouse_drag(self._mouse)
    # Propagate mouse dragging to the layer with the focus.
    if self._focus is not None:
        self._focus.dragged = True
        self._focus.on_mouse_drag(self._mouse)
        
</t>
<t tx="karstenw.20240123172917.429">def _on_mouse_scroll(self, x, y, scroll_x, scroll_y):
    self._mouse.scroll.x = scroll_x
    self._mouse.scroll.y = scroll_y
    self.on_mouse_scroll(self._mouse)
    # Propagate mouse scrolling to the layer with the focus.
    if self._focus is not None:
        self._focus.on_mouse_scroll(self._mouse)

</t>
<t tx="karstenw.20240123172917.43">def rgb_to_lab(r, g, b):
    """ Converts the given R,G,B values to CIE L,A,B (between 0.0-1.0).
    """
    x, y, z = rgb_to_xyz(r, g, b)
    x, y, z = [ch &gt; 0.008856 and ch**(1/3.0) or (ch*7.787) + (16/116.0) for ch in (x, y, z)]
    l, a, b = y*116-16, 500*(x-y), 200*(y-z)
    l, a, b = l/100.0, (a+86)/(86+98), (b+108)/(108+94)
    return l, a, b
    
</t>
<t tx="karstenw.20240123172917.430">def _on_key_press(self, keycode, modifiers):
    self._keys.pressed = True            
    self._keys.append(keycode)
    if self._keys.code == TAB:
        self._keys.char = "\t"
    # The event is delegated in _update():
    self._window.on_key_pressed = True

</t>
<t tx="karstenw.20240123172917.431">def _on_key_release(self, keycode, modifiers):
    for layer in self:
        layer.on_key_release(self.key)
    self.on_key_release(self.key)
    self._keys.char = ""
    try:
        self._keys.remove(keycode)
    except ValueError:
        pass
    self._keys.pressed = False

</t>
<t tx="karstenw.20240123172917.432">def _on_text(self, text):
    self._keys.char = text
    # The event is delegated in _update():
    self._window.on_key_pressed = True
        
</t>
<t tx="karstenw.20240123172917.433">def _on_text_motion(self, keycode):
    self._keys.char = ""
    # The event is delegated in _update():
    self._window.on_key_pressed = True
    
</t>
<t tx="karstenw.20240123172917.434">def _on_move(self, x, y):
    self.on_move()

</t>
<t tx="karstenw.20240123172917.435">def _on_resize(self, width, height):
    pyglet.window.Window.on_resize(self._window, width, height)
    self.on_resize()

# Event methods are meant to be overridden or patched with Prototype.set_method().
</t>
<t tx="karstenw.20240123172917.436">def on_key_press(self, keys):
    """ The default behavior of the canvas:
        - ESC exits the application,
        - CTRL-P pauses the animation,
        - CTRL-S saves a screenshot.
    """
    if keys.code == ESCAPE:
        self.stop()
    if keys.code == "p" and CTRL in keys.modifiers:
        self.paused = not self.paused
    if keys.code == "s" and CTRL in keys.modifiers:
        self.save("nodebox-%s.png" % str(datetime.now()).split(".")[0].replace(" ","-").replace(":","-"))

</t>
<t tx="karstenw.20240123172917.437">def on_move(self):
    pass

</t>
<t tx="karstenw.20240123172917.438">def on_resize(self):
    pass

#--- Main loop --------------------------------------
    
</t>
<t tx="karstenw.20240123172917.439">def setup(self):
    pass
    
</t>
<t tx="karstenw.20240123172917.44">def lab_to_rgb(l, a, b):
    """ Converts the given CIE L,A,B color values to R,G,B (between 0.0-1.0).
    """
    l, a, b = l*100, a*(86+98)-86, b*(108+94)-108
    y = (l+16)/116.0
    x = y + a/500.0
    z = y - b/200.0
    x, y, z = [ch**3 &gt; 0.008856 and ch**3 or (ch-16/116.0)/7.787 for ch in (x, y, z)]
    return xyz_to_rgb(x, y, z)

</t>
<t tx="karstenw.20240123172917.440">def update(self):
    pass
    
</t>
<t tx="karstenw.20240123172917.441">def draw(self):
    self.clear()
    
</t>
<t tx="karstenw.20240123172917.442">def draw_overlay(self):
    """ Override this method to draw once all the layers have been drawn.
    """
    pass
    
draw_over = draw_overlay

</t>
<t tx="karstenw.20240123172917.443">def _setup(self):
    """ Initializes the application window and resets the state.
        Clears the canvas and calls Canvas.setup().
    """
    # Start the application (if not already running).
    if not self._active:
        self._window.switch_to()
        # Set the window color, this will be transparent in saved images.
        glClearColor(VERY_LIGHT_GREY, VERY_LIGHT_GREY, VERY_LIGHT_GREY, 0)
        # Reset the transformation state.
        # Most of this is already taken care of in Pyglet.
        
        if 0:
            glMatrixMode( GL_PROJECTION )
            glLoadIdentity()
            
            glOrtho(0, self.width, 0, self.height, -1, 1)
            glMatrixMode(GL_MODELVIEW)
        else:
            glLoadIdentity()
            # pass
        
        # Enable line anti-aliasing.
        glEnable(GL_LINE_SMOOTH)
        
        # Enable alpha transparency.
        glEnable(GL_BLEND)
        glBlendFuncSeparate( GL_SRC_ALPHA,
                             GL_ONE_MINUS_SRC_ALPHA,
                             GL_ONE,
                             GL_ONE_MINUS_SRC_ALPHA)
        # glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
        self._window.dispatch_events()
        self._window.set_visible(True)
        self._active = True
    self.clear()
    self.setup()

</t>
<t tx="karstenw.20240123172917.444">def _draw(self, lapse=0):
    """ Draws the canvas and its layers.
        This method gives the same result each time it gets drawn; only _update() advances state.
    """
    if self.paused: 
        return
    self._window.switch_to()
    glPushMatrix()
    self.draw()
    glPopMatrix()
    glPushMatrix()
    for layer in self:
        layer._draw()
    glPopMatrix()
    glPushMatrix()
    self.draw_overlay()
    glPopMatrix()

</t>
<t tx="karstenw.20240123172917.445">def _update(self, lapse=0):
    """ Updates the canvas and its layers.
        This method does not actually draw anything, it only updates the state.
    """
    self._elapsed = lapse
    if not self.paused:
        # Advance the animation by updating all layers.
        # This is only done when the canvas is not paused.
        # Events will still be propagated during pause.
        global TIME; TIME = time()
        self._frame += 1
        self.update()
        for layer in self:
            layer._update()
    if self._window.on_key_pressed is True:
        # Fire on_key_press() event,
        # which combines _on_key_press(), _on_text() and _on_text_motion().
        self._window.on_key_pressed = False
        self.on_key_press(self._keys)
        for layer in self:
            layer.on_key_press(self._keys)
            
</t>
<t tx="karstenw.20240123172917.446">def stop(self):
    # If you override this method, don't forget to call Canvas.stop() to exit the app.
    # Any user-defined stop method, added with canvas.set_method() or canvas.run(stop=stop), 
    # is called first.
    try: self._user_defined_stop()
    except:
        pass
    for f in (self._update, self._draw):
        pyglet.clock.unschedule(f)
    self._window.close()
    self._active = False
    pyglet.app.exit()

</t>
<t tx="karstenw.20240123172917.447">def clear(self):
    """ Clears the previous frame from the canvas.
    """
    glClear(GL_COLOR_BUFFER_BIT)
    glClear(GL_DEPTH_BUFFER_BIT)
    glClear(GL_STENCIL_BUFFER_BIT)

</t>
<t tx="karstenw.20240123172917.448">def run(self, draw=None, setup=None, update=None, stop=None):
    """ Opens the application windows and starts drawing the canvas.
        Canvas.setup() will be called once during initialization.
        Canvas.draw() and Canvas.update() will be called each frame. 
        Canvas.clear() needs to be called explicitly to clear the previous frame drawing.
        Canvas.stop() closes the application window.
        If the given setup, draw or update parameter is a function,
        it overrides that canvas method.
    """

    if isinstance(setup, FunctionType):
        self.set_method(setup, name="setup")
    if isinstance(draw, FunctionType):
        self.set_method(draw, name="draw")
    if isinstance(update, FunctionType):
        self.set_method(update, name="update")
    if isinstance(stop, FunctionType):
        self.set_method(stop, name="stop")
    self._setup()
    self.fps = self._fps # Schedule the _update and _draw events.
    pyglet.app.run()

</t>
<t tx="karstenw.20240123172917.449">@property
def active(self):
    return self._active

</t>
<t tx="karstenw.20240123172917.45">def luminance(r, g, b):
    """ Returns an indication (0.0-1.0) of how bright the color appears.
    """
    return (r*0.2125 + g*0.7154 + b+0.0721) * 0.5

</t>
<t tx="karstenw.20240123172917.450">def _get_fps(self):
    return self._fps
</t>
<t tx="karstenw.20240123172917.451">def _set_fps(self, v):
    # Use pyglet.clock to schedule _update() and _draw() events.
    # The clock will then take care of calling them enough times.
    # Note: frames per second is related to vsync. 
    # If the vertical refresh rate is about 30Hz you'll get top speed of around 33fps.
    # It's probably a good idea to leave vsync=True if you don't want to fry the GPU.
    for f in (self._update, self._draw):
        pyglet.clock.unschedule(f)
        if v is None:
            pyglet.clock.schedule(f)
        if v &gt; 0:
            pyglet.clock.schedule_interval(f, 1.0/v)
    self._fps = v
    
fps = property(_get_fps, _set_fps)        

#--- Frame export -----------------------------------

</t>
<t tx="karstenw.20240123172917.452">def render(self):
    """ Returns a screenshot of the current frame as a texture.
        This texture can be passed to the image() command.
    """
    return pyglet.image.get_buffer_manager().get_color_buffer().get_texture()
    
buffer = screenshot = render

</t>
<t tx="karstenw.20240123172917.453">@property
def texture(self):
    return pyglet.image.get_buffer_manager().get_color_buffer().get_texture()

</t>
<t tx="karstenw.20240123172917.454">def save(self, path):
    """ Exports the current frame as a PNG-file.
    """
    pyglet.image.get_buffer_manager().get_color_buffer().save(path)

#--- Prototype --------------------------------------

</t>
<t tx="karstenw.20240123172917.455">def __setattr__(self, k, v):
    # Canvas is a Prototype, so Canvas.draw() can be overridden 
    # but it can also be patched with Canvas.set_method(draw).
    # Specific methods (setup, draw, mouse and keyboard events) can also be set directly
    # (e.g. canvas.on_mouse_press = my_mouse_handler).
    # This way we don't have to explain set_method() to beginning users..
    if isinstance(v, FunctionType) and (k in ("setup", "draw", "update", "stop") \
    or k.startswith("on_") and k in (
        "on_mouse_enter",
        "on_mouse_leave",
        "on_mouse_motion",
        "on_mouse_press",
        "on_mouse_release",
        "on_mouse_drag",
        "on_mouse_scroll",
        "on_key_press",
        "on_key_release",
        "on_move",
        "on_resize")):
        self.set_method(v, name=k)
    else:
        object.__setattr__(self, k, v)
        
</t>
<t tx="karstenw.20240123172917.456">def set_method(self, function, name=None):
    if name == "stop" \
    or name is None and function.__name__ == "stop":
        Prototype.set_method(self, function, name="_user_defined_stop") # Called from Canvas.stop().
    else:
        Prototype.set_method(self, function, name)
        
</t>
<t tx="karstenw.20240123172917.457">def __repr__(self):
    return "Canvas(name='%s', size='%s', layers=%s)" % (self.name, self.size, repr(list(self)))

</t>
<t tx="karstenw.20240123172917.458">def profile_run():
    for i in range(_profile_frames):
        _profile_canvas._update()
        _profile_canvas._draw()

</t>
<t tx="karstenw.20240123172917.459">class Profiler:
    
    @others
</t>
<t tx="karstenw.20240123172917.46">def darker(clr, step=0.2):
    """ Returns a copy of the color with a darker brightness.
    """
    h, s, b = rgb_to_hsb(clr.r, clr.g, clr.b)
    r, g, b = hsb_to_rgb(h, s, max(0, b-step))
    return Color(r, g, b, len(clr)==4 and clr[3] or 1)

</t>
<t tx="karstenw.20240123172917.460">def __init__(self, canvas):
    self.canvas  = canvas

</t>
<t tx="karstenw.20240123172917.461">@property
def framerate(self):
    return pyglet.clock.get_fps()

</t>
<t tx="karstenw.20240123172917.462">def run(self, draw=None, setup=None, update=None, frames=100, sort=CUMULATIVE, top=30):
    """ Runs cProfile on the canvas for the given number of frames.
        The performance statistics are returned as a string, sorted by SLOWEST or CUMULATIVE.
        For example, instead of doing canvas.run(draw):
        print canvas.profiler.run(draw, frames=100)
    """
    # Register the setup, draw, update functions with the canvas (if given).
    if isinstance(setup, FunctionType):
        self.canvas.set_method(setup, name="setup")
    if isinstance(draw, FunctionType):
        self.canvas.set_method(draw, name="draw")
    if isinstance(update, FunctionType):
        self.canvas.set_method(update, name="update")
    # If enabled, turn Psyco off.
    psyco_stopped = False
    try: 
        psyco.stop()
        psyco_stopped = True
    except:
        pass
    # Set the current canvas and the number of frames to profile.
    # The profiler will then repeatedly execute canvas._update() and canvas._draw().
    # Statistics are redirected from stdout to a temporary file.
    global _profile_canvas, _profile_frames
    _profile_canvas = self.canvas
    _profile_frames = frames
    import cProfile
    import pstats
    cProfile.run("profile_run()", "_profile")
    p = pstats.Stats("_profile")
    p.stream = open("_profile", "w")
    p.sort_stats(sort==SLOWEST and "time" or sort).print_stats(top)
    p.stream.close()
    s = open("_profile").read()
    remove("_profile")
    # Restart Psyco if we stopped it.
    if psyco_stopped:
        psyco.profile()
    return s

</t>
<t tx="karstenw.20240123172917.463">def ximport(library):
    from sys import modules
    library = __import__(library)
    library._ctx = modules[__name__]
    return library

from . import bezier

</t>
<t tx="karstenw.20240123172917.47">def lighter(clr, step=0.2):
    """ Returns a copy of the color with a lighter brightness.
    """
    h, s, b = rgb_to_hsb(clr.r, clr.g, clr.b)
    r, g, b = hsb_to_rgb(h, s, min(1, b+step))
    return Color(r, g, b, len(clr)==4 and clr[3] or 1)
    
darken, lighten = darker, lighter

</t>
<t tx="karstenw.20240123172917.48">def rotate_ryb(h, s, b, angle=180):
    """ Rotates the given H,S,B color (0.0-1.0) on the RYB color wheel.
        The RYB colorwheel is not mathematically precise,
        but focuses on aesthetically pleasing complementary colors.
    """
    h = h*360 % 360
    # Find the location (angle) of the hue on the RYB color wheel.
    for i in range(len(_colorwheel)-1):
        (x0, y0), (x1, y1) = _colorwheel[i], _colorwheel[i+1]
        if y0 &lt;= h &lt;= y1:
            a = geometry.lerp(x0, x1, t=(h-y0)/(y1-y0))
            break
    # Rotate the angle and retrieve the hue.
    a = (a+angle) % 360
    for i in range(len(_colorwheel)-1):
        (x0, y0), (x1, y1) = _colorwheel[i], _colorwheel[i+1]
        if x0 &lt;= a &lt;= x1:
            h = geometry.lerp(y0, y1, t=(a-x0)/(x1-x0))
            break
    return h/360.0, s, b
    
</t>
<t tx="karstenw.20240123172917.49">def complement(clr):
    """ Returns the color opposite on the color wheel.
        The complementary color contrasts with the given color.
    """
    if not isinstance(clr, Color):
        clr = Color(clr)
    return clr.rotate(180)

</t>
<t tx="karstenw.20240123172917.5">def flush(id):
    """ Removes the Display List program with the given id from memory.
    """
    if id is not None:
        glDeleteLists(id, 1)

</t>
<t tx="karstenw.20240123172917.50">def analog(clr, angle=20, d=0.1):
    """ Returns a random adjacent color on the color wheel.
        Analogous color schemes can often be found in nature.
    """
    h, s, b = rgb_to_hsb(*clr[:3])
    h, s, b = rotate_ryb(h, s, b, angle=random(-angle,angle))
    s *= 1 - random(-d,d)
    b *= 1 - random(-d,d)
    return Color(h, s, b, len(clr)==4 and clr[3] or 1, colorspace=HSB)

</t>
<t tx="karstenw.20240123172917.51">def color_mixin(**kwargs):
    fill        = kwargs.get("fill", _fill)
    stroke      = kwargs.get("stroke", _stroke)
    strokewidth = kwargs.get("strokewidth", _strokewidth)
    strokestyle = kwargs.get("strokestyle", _strokestyle)
    return (fill, stroke, strokewidth, strokestyle)

</t>
<t tx="karstenw.20240123172917.52">def colorplane(x, y, width, height, *a):
    """ Draws a rectangle that emits a different fill color from each corner.
        An optional number of colors can be given: 
        - four colors define top left, top right, bottom right and bottom left,
        - three colors define top left, top right and bottom,
        - two colors define top and bottom,
        - no colors assumes black top and white bottom gradient.
    """
    if len(a) == 2:
        # Top and bottom colors.
        clr1, clr2, clr3, clr4 = a[0], a[0], a[1], a[1]
    elif len(a) == 4:
        # Top left, top right, bottom right, bottom left.
        clr1, clr2, clr3, clr4 = a[0], a[1], a[2], a[3]
    elif len(a) == 3:
        # Top left, top right, bottom.
        clr1, clr2, clr3, clr4 = a[0], a[1], a[2], a[2]
    elif len(a) == 0:
        # Black top, white bottom.
        clr1 = clr2 = (0,0,0,1)
        clr3 = clr4 = (1,1,1,1)
    glPushMatrix()
    glTranslatef(x, y, 0)
    glScalef(width, height, 1)
    glBegin(GL_QUADS)
    glColor4f(clr1[0], clr1[1], clr1[2], clr1[3] * _alpha); glVertex2f(-0.0,  1.0)
    glColor4f(clr2[0], clr2[1], clr2[2], clr2[3] * _alpha); glVertex2f( 1.0,  1.0)
    glColor4f(clr3[0], clr3[1], clr3[2], clr3[3] * _alpha); glVertex2f( 1.0, -0.0)
    glColor4f(clr4[0], clr4[1], clr4[2], clr4[3] * _alpha); glVertex2f(-0.0, -0.0)
    glEnd()
    glPopMatrix()

</t>
<t tx="karstenw.20240123172917.53">def push():
    """ Pushes the transformation state.
        Subsequent transformations (translate, rotate, scale) remain in effect until pop() is called.
    """
    glPushMatrix()

</t>
<t tx="karstenw.20240123172917.54">def pop():
    """ Pops the transformation state.
        This reverts the transformation to before the last push().
    """
    glPopMatrix()

</t>
<t tx="karstenw.20240123172917.55">def translate(x, y, z=0):
    """ By default, the origin of the layer or canvas is at the bottom left.
        This origin point will be moved by (x,y) pixels.
    """
    glTranslatef(round(x), round(y), round(z))

</t>
<t tx="karstenw.20240123172917.56">def rotate(degrees, axis=(0,0,1)):
    """ Rotates the transformation state, i.e. all subsequent drawing primitives are rotated.
        Rotations work incrementally:
        calling rotate(60) and rotate(30) sets the current rotation to 90.
    """
    glRotatef(degrees, *axis)

</t>
<t tx="karstenw.20240123172917.57">def scale(x, y=None, z=None):
    """ Scales the transformation state.
    """
    if y is None: 
        y = x
    if z is None: 
        z = 1
    glScalef(x, y, z)

</t>
<t tx="karstenw.20240123172917.58">def reset():
    """ Resets the transform state of the layer or canvas.
    """
    glLoadIdentity()

CORNER = "corner"
CENTER = "center"
</t>
<t tx="karstenw.20240123172917.59">def transform(mode=None):
    if mode == CENTER:
        raise NotImplementedError( "no center-mode transform" )
    return CORNER
    
</t>
<t tx="karstenw.20240123172917.6">class Color(list):

    @others
color = Color

</t>
<t tx="karstenw.20240123172917.60">def skew(x, y):
    raise NotImplementedError()

</t>
<t tx="karstenw.20240123172917.61">def line(x0, y0, x1, y1, **kwargs):
    """ Draws a straight line from x0, y0 to x1, y1 with the current stroke color and strokewidth.
    """
    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    if stroke is not None and strokewidth &gt; 0:
        glColor4f(stroke[0], stroke[1], stroke[2], stroke[3] * _alpha)
        glLineWidth(strokewidth)
        if strokestyle != _strokestyle:
            glLineDash(strokestyle)
        glBegin(GL_LINES)
        glVertex2f(x0, y0)
        glVertex2f(x1, y1)
        glEnd()

</t>
<t tx="karstenw.20240123172917.62">def rect(x, y, width, height, **kwargs):
    """ Draws a rectangle with the bottom left corner at x, y.
        The current stroke, strokewidth and fill color are applied.
    """
    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    if fill is not None:
        glColor4f(fill[0], fill[1], fill[2], fill[3] * _alpha)
        glRectf(x, y, x+width, y+height)

    if stroke is not None and strokewidth &gt; 0:
        glLineWidth(strokewidth)
        glLineDash(strokestyle)
        glColor4f(stroke[0], stroke[1], stroke[2], stroke[3] * _alpha)
        # Note: this performs equally well as when using precompile().
        glBegin(GL_LINE_LOOP)
        glVertex2f(x, y)
        glVertex2f(x+width, y)
        glVertex2f(x+width, y+height)
        glVertex2f(x, y+height)
        glEnd()

</t>
<t tx="karstenw.20240123172917.63">def triangle(x1, y1, x2, y2, x3, y3, **kwargs):
    """ Draws the triangle created by connecting the three given points.
        The current stroke, strokewidth and fill color are applied.
    """
    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    for i, clr in enumerate((fill, stroke)):
        if clr is not None and (i==0 or strokewidth &gt; 0):
            if i == 1: 
                glLineWidth(strokewidth)
                if strokestyle != _strokestyle:
                    glLineDash(strokestyle)
            glColor4f(clr[0], clr[1], clr[2], clr[3] * _alpha)
            # Note: this performs equally well as when using precompile().
            glBegin((GL_TRIANGLES, GL_LINE_LOOP)[i])
            glVertex2f(x1, y1)
            glVertex2f(x2, y2)
            glVertex2f(x3, y3)
            glEnd()

_ellipses = {}
ELLIPSE_SEGMENTS = 50
</t>
<t tx="karstenw.20240123172917.64">def ellipse(x, y, width, height, segments=ELLIPSE_SEGMENTS, **kwargs):
    """ Draws an ellipse with the center located at x, y.
        The current stroke, strokewidth and fill color are applied.
    """
    if not segments in _ellipses:
        # For the given amount of line segments, calculate the ellipse once.
        # Then reuse the cached ellipse by scaling it to the desired size.
        commands = []
        f = 2 * pi / segments
        v = [(cos(t)/2, sin(t)/2) for t in [i*f for i in list(range(segments))+[0]]]
        for mode in (GL_TRIANGLE_FAN, GL_LINE_LOOP):
            commands.append(precompile(lambda:(
               glBegin(mode),
               [glVertex2f(x, y) for (x, y) in v],
               glEnd()
               )))
        
        _ellipses[segments] = commands

    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    for i, clr in enumerate((fill, stroke)):
        if clr is not None and (i==0 or strokewidth &gt; 0):
            if i == 1: 
                glLineWidth(strokewidth)
                if strokestyle != _strokestyle:
                    glLineDash(strokestyle)
            glColor4f(clr[0], clr[1], clr[2], clr[3] * _alpha)
            glPushMatrix()
            glTranslatef(x, y, 0)
            glScalef(width, height, 1)
            glCallList(_ellipses[segments][i])
            glPopMatrix()

oval = ellipse # Backwards compatibility.

</t>
<t tx="karstenw.20240123172917.65">def arrow(x, y, width, **kwargs):
    """ Draws an arrow with its tip located at x, y.
        The current stroke, strokewidth and fill color are applied.
    """
    head = width * 0.4
    tail = width * 0.2
    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    for i, clr in enumerate((fill, stroke)):
        if clr is not None and (i==0 or strokewidth &gt; 0):
            if i == 1: 
                glLineWidth(strokewidth)
                glLineDash(strokestyle)
            glColor4f(clr[0], clr[1], clr[2], clr[3] * _alpha)
            # Note: this performs equally well as when using precompile().
            glBegin((GL_POLYGON, GL_LINE_LOOP)[i])
            glVertex2f(x, y)
            glVertex2f(x-head, y+head)
            glVertex2f(x-head, y+tail)
            glVertex2f(x-width, y+tail)
            glVertex2f(x-width, y-tail)
            glVertex2f(x-head, y-tail)
            glVertex2f(x-head, y-head)
            glVertex2f(x, y)
            glEnd()

</t>
<t tx="karstenw.20240123172917.66">def gcd(a, b):
    return gcd(b, a % b) if b else a

_stars = {} #TODO: LRU?
</t>
<t tx="karstenw.20240123172917.67">def fast_star(x, y, points=20, outer=100, inner=50, **kwargs):
    """ Draws a star with the given points, outer radius and inner radius.
        The current stroke, strokewidth and fill color are applied.
    """
    scale = gcd(inner, outer)
    iscale = inner / scale
    oscale = outer / scale
    cached = _stars.get((points, iscale, oscale), [])
    if not cached:
        radii = [oscale, iscale] * int(points+1); radii.pop() # which radius?
        f = pi / points
        v = [(r*sin(i*f), r*cos(i*f)) for i, r in enumerate(radii)]
        cached.append(precompile(lambda:(
            glBegin(GL_TRIANGLE_FAN),
            glVertex2f(0, 0),
            [glVertex2f(vx, vy) for (vx, vy) in v],
            glEnd()
        )))
        cached.append(precompile(lambda:(
            glBegin(GL_LINE_LOOP),
            [glVertex2f(vx, vy) for (vx, vy) in v],
            glEnd()
        )))
        _stars[(points, iscale, oscale)] = cached

    fill, stroke, strokewidth, strokestyle = color_mixin(**kwargs)
    for i, clr in enumerate((fill, stroke)):
        if clr is not None and (i == 0 or strokewidth &gt; 0):
            if i == 1: 
                glLineWidth(strokewidth)
                if strokestyle != _strokestyle:
                    glLineDash(strokestyle)
            glColor4f(clr[0], clr[1], clr[2], clr[3] * _alpha)
            glPushMatrix()
            glTranslatef(x, y, 0)
            glScalef(scale, scale, 1)
            glCallList(cached[i])
            glPopMatrix()

</t>
<t tx="karstenw.20240123172917.68">def star(x, y, points=20, outer=100, inner=50, **kwargs):
    """ Draws a star with the given points, outer radius and inner radius.
        The current stroke, strokewidth and fill color are applied.
        This is about 20x slower than fast_star; use it only if you need the path returned.
    """
    p = BezierPath(**kwargs)
    p.moveto(x, y+outer)
    for i in range(0, int(2*points)+1):
        r = (outer, inner)[i%2]
        a = pi*i/points
        p.lineto(x+r*sin(a), y+r*cos(a))
    p.closepath()

    if kwargs.get("draw", True):
        p.draw(**kwargs)
    return p

</t>
<t tx="karstenw.20240123172917.69">class PathError(Exception): 
    pass
</t>
<t tx="karstenw.20240123172917.7">def __init__(self, *args, **kwargs):
    """ A color with R,G,B,A channels, with channel values ranging between 0.0-1.0.
        Either takes four parameters (R,G,B,A), three parameters (R,G,B),
        two parameters (grayscale and alpha) or one parameter (grayscale or Color object).
        An optional base=1.0 parameter defines the range of the given parameters.
        An optional colorspace=RGB defines the color space of the given parameters.
    """
    # Values are supplied as a tuple.
    if len(args) == 1 and isinstance(args[0], (list, tuple)):
        args = args[0]
    # R, G, B and A.
    if len(args) == 4:
        r, g, b, a = args[0], args[1], args[2], args[3]
    # R, G and B.
    elif len(args) == 3:
        r, g, b, a = args[0], args[1], args[2], 1
    # Two values, grayscale and alpha.
    elif len(args) == 2:
        r, g, b, a = args[0], args[0], args[0], args[1]
    # One value, another color object.
    elif len(args) == 1 and isinstance(args[0], Color):
        r, g, b, a = args[0].r, args[0].g, args[0].b, args[0].a
    # One value, None.
    elif len(args) == 1 and args[0] is None:
        r, g, b, a = 0, 0, 0, 0
    # One value, grayscale.
    elif len(args) == 1:
        r, g, b, a = args[0], args[0], args[0], 1
    # No value, transparent black.
    elif len(args):
        r, g, b, a = 0, 0, 0, 0
    # Transform to base 1:
    base = float(kwargs.get("base", 1.0))
    if base != 1:
        r, g, b, a = [ch/base for ch in (r, g, b, a)]
    # Transform to color space RGB:
    colorspace = kwargs.get("colorspace")
    if colorspace and colorspace != RGB:
        if colorspace == HSB: r, g, b = hsb_to_rgb(r, g, b)
        if colorspace == XYZ: r, g, b = xyz_to_rgb(r, g, b)
        if colorspace == LAB: r, g, b = lab_to_rgb(r, g, b)
    list.__init__(self, [r, g, b, a])
    self._dirty = False

</t>
<t tx="karstenw.20240123172917.70">class NoCurrentPointForPath(Exception): 
    pass
</t>
<t tx="karstenw.20240123172917.71">class NoCurrentPath(Exception): 
    pass

</t>
<t tx="karstenw.20240123172917.72">class PathPoint(Point):
    
    @others
</t>
<t tx="karstenw.20240123172917.73">def __init__(self, x=0, y=0):
    """ A control handle for PathElement.
    """
    self._x = x
    self._y = y
    self._dirty = False

</t>
<t tx="karstenw.20240123172917.74">def _get_x(self): return self._x
</t>
<t tx="karstenw.20240123172917.75">def _set_x(self, v): 
    self._x = v
    self._dirty = True

</t>
<t tx="karstenw.20240123172917.76">def _get_y(self): return self._y
</t>
<t tx="karstenw.20240123172917.77">def _set_y(self, v):
    self._y = v
    self._dirty = True
    
x = property(_get_x, _set_x)
y = property(_get_y, _set_y)

</t>
<t tx="karstenw.20240123172917.78">def copy(self, parent=None):
    return PathPoint(self._x, self._y)

</t>
<t tx="karstenw.20240123172917.79">class PathElement(object):
    
    @others
</t>
<t tx="karstenw.20240123172917.8">def __setitem__(self, i, v):
    list.__setitem__(self, i, v)
    self._dirty = True

</t>
<t tx="karstenw.20240123172917.80">def __init__(self, cmd=None, pts=None):
    """ A point in the path, optionally with control handles:
        - MOVETO  : the list of points contains a single (x,y)-tuple.
        - LINETO  : the list of points contains a single (x,y)-tuple.
        - CURVETO : the list of points contains (vx1,vy1), (vx2,vy2), (x,y) tuples.
        - CLOSETO : no points.
    """
    if cmd == MOVETO \
    or cmd == LINETO:
        pt, h1, h2 = pts[0], pts[0], pts[0]
    elif cmd == CURVETO:
        pt, h1, h2 = pts[2], pts[0], pts[1]
    else:
        pt, h1, h2 = (0,0), (0,0), (0,0)
    self._cmd    = cmd
    self._x      = pt[0]
    self._y      = pt[1]
    self._ctrl1  = PathPoint(h1[0], h1[1])
    self._ctrl2  = PathPoint(h2[0], h2[1])
    self.__dirty = False

</t>
<t tx="karstenw.20240123172917.81">def _get_dirty(self):
    return self.__dirty \
        or self.ctrl1._dirty \
        or self.ctrl2._dirty
        
</t>
<t tx="karstenw.20240123172917.82">def _set_dirty(self, b):
    self.__dirty = b
    self.ctrl1._dirty = b
    self.ctrl2._dirty = b
    
_dirty = property(_get_dirty, _set_dirty)

</t>
<t tx="karstenw.20240123172917.83">@property
def cmd(self):
    return self._cmd

</t>
<t tx="karstenw.20240123172917.84">def _get_x(self): return self._x
</t>
<t tx="karstenw.20240123172917.85">def _set_x(self, v): 
    self._x = v
    self.__dirty = True
    
</t>
<t tx="karstenw.20240123172917.86">def _get_y(self): return self._y
</t>
<t tx="karstenw.20240123172917.87">def _set_y(self, v): 
    self._y = v
    self.__dirty = True
    
x = property(_get_x, _set_x)
y = property(_get_y, _set_y)

</t>
<t tx="karstenw.20240123172917.88">def _get_xy(self):
    return (self.x, self.y)
# (x,y)
</t>
<t tx="karstenw.20240123172917.89">def _set_xy(self, doublet):
    x,y = doublet
    self.x = x
    self.y = y
    
xy = property(_get_xy, _set_xy)

# Handle 1 describes now the curve from the previous point started.
</t>
<t tx="karstenw.20240123172917.9">def _get_r(self): return self[0]
</t>
<t tx="karstenw.20240123172917.90">def _get_ctrl1(self): return self._ctrl1
</t>
<t tx="karstenw.20240123172917.91">def _set_ctrl1(self, v):
    self._ctrl1 = PathPoint(v.x, v.y)
    self.__dirty = True

# Handle 2 describes how the curve from the previous point arrives in this point.
</t>
<t tx="karstenw.20240123172917.92">def _get_ctrl2(self): return self._ctrl2
</t>
<t tx="karstenw.20240123172917.93">def _set_ctrl2(self, v):
    self._ctrl2 = PathPoint(v.x, v.y)
    self.__dirty = True

ctrl1 = property(_get_ctrl1, _set_ctrl1)
ctrl2 = property(_get_ctrl2, _set_ctrl2)

</t>
<t tx="karstenw.20240123172917.94">def __eq__(self, pt):
    if not isinstance(pt, PathElement): return False
    return self.cmd == pt.cmd \
       and self.x == pt.x \
       and self.y == pt.y \
       and self.ctrl1 == pt.ctrl1 \
       and self.ctrl2 == pt.ctrl2
    
</t>
<t tx="karstenw.20240123172917.95">def __ne__(self, pt):
    return not self.__eq__(pt)
    
</t>
<t tx="karstenw.20240123172917.96">def __repr__(self):
    return "%s(cmd='%s', x=%.1f, y=%.1f, ctrl1=(%.1f, %.1f), ctrl2=(%.1f, %.1f))" % (
        self.__class__.__name__, self.cmd, self.x, self.y, 
        self.ctrl1.x, self.ctrl1.y, 
        self.ctrl2.x, self.ctrl2.y)

</t>
<t tx="karstenw.20240123172917.97">def copy(self):
    if self.cmd == MOVETO \
    or self.cmd == LINETO:
        pts = ((self.x, self.y),)
    elif self.cmd == CURVETO:
        pts = ((self.ctrl1.x, self.ctrl1.y), (self.ctrl2.x, self.ctrl2.y), (self.x, self.y))
    else:
        pts = None
    return PathElement(self.cmd, pts)

</t>
<t tx="karstenw.20240123172917.98">class BezierPath(list):
    
    @others
</t>
<t tx="karstenw.20240123172917.99">def __init__(self, path=None, **kwargs):
    """ A list of PathElements describing the curves and lines that make up the path.
    """
    if isinstance(path, (BezierPath, list, tuple)):
        self.extend([pt.copy() for pt in path])
    self._kwargs   = kwargs
    self._cache    = None # Cached vertices for drawing.
    self._segments = None # Cached segment lengths.
    self._bounds   = None # Cached bounding rectangle.
    self._polygon  = None # Cached polygon hit test area.
    self._dirty    = False
    self._index    = {}

</t>
<t tx="karstenw.20240123172920.1">#=== BEZIER ==========================================================================================
# Bezier mathematics.
# Authors: Tom De Smedt
# License: BSD (see LICENSE.txt for details).
# Copyright (c) 2008-2012 City In A Bottle (cityinabottle.org)
# http://cityinabottle.org/nodebox

# Thanks to Prof. F. De Smedt at the Vrije Universiteit Brussel.

from .context import BezierPath, PathElement, PathError, Point, MOVETO, LINETO, CURVETO, CLOSE
from math import sqrt, pow, acos, sin, cos, hypot, ceil, radians, degrees


</t>
<t tx="karstenw.20240123172920.10">def point(path, t, segments=None):
    """ Returns coordinates for point at t on the path.
        Gets the length of the path, based on the length of each curve and line in the path.
        Determines in what segment t falls. Gets the point on that segment.
        When you supply the list of segment lengths yourself, as returned from length(path, segmented=True), 
        point() works about thirty times faster in a for-loop since it doesn't need to recalculate 
        the length during each iteration.
    """
    if len(path) == 0:
        raise PathError( "The given path is empty" )
    i, t, closeto = _locate(path, t, segments=segments)
    x0, y0 = path[i].x, path[i].y
    p1 = path[i+1]

    if p1.cmd == CLOSE:
        x, y = linepoint(t, x0, y0, closeto.x, closeto.y)
        return DynamicPathElement(LINETO, ((x, y),))
    elif p1.cmd == LINETO:
        x1, y1 = p1.x, p1.y
        x, y = linepoint(t, x0, y0, x1, y1)
        return DynamicPathElement(LINETO, ((x, y),))
    elif p1.cmd == CURVETO:
        # Note: the handles need to be interpreted differenty than in a BezierPath.
        # In a BezierPath, ctrl1 is how the curve started, and ctrl2 how it arrives in this point.
        # Here, ctrl1 is how the curve arrives, and ctrl2 how it continues to the next point.
        x3, y3, x1, y1, x2, y2 = p1.x, p1.y, p1.ctrl1.x, p1.ctrl1.y, p1.ctrl2.x, p1.ctrl2.y
        x, y, c1x, c1y, c2x, c2y = curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3)
        return DynamicPathElement(CURVETO, ((c1x, c1y), (c2x, c2y), (x, y)))
    else:
        raise PathError( "Unknown cmd '%s' for p1 %s" % (p1.cmd, p1) )
        
</t>
<t tx="karstenw.20240123172920.11">def points(path, amount=100, start=0.0, end=1.0, segments=None):
    """ Returns an iterator with a list of calculated points for the path.
        To omit the last point on closed paths: end=1-1.0/amount
    """
    if len(path) == 0:
        raise PathError( "The given path is empty" )
    n = end - start
    d = n
    if amount &gt; 1:
        # The delta value is divided by amount-1, because we also want the last point (t=1.0)
        # If we don't use amount-1, we fall one point short of the end.
        # If amount=4, we want the point at t 0.0, 0.33, 0.66 and 1.0.
        # If amount=2, we want the point at t 0.0 and 1.0.
        d = float(n) / (amount-1)
    for i in range(amount):
        yield point(path, start+d*i, segments)

</t>
<t tx="karstenw.20240123172920.12">def contours(path):
    """ Returns a list of contours in the path, as BezierPath objects.
        A contour is a sequence of lines and curves separated from the next contour by a MOVETO.
        For example, the glyph "o" has two contours: the inner circle and the outer circle.
    """
    contours = []
    current_contour = None
    empty = True
    for i, el in enumerate(path):
        if el.cmd == MOVETO:
            if not empty:
                contours.append(current_contour)
            current_contour = BezierPath()
            current_contour.moveto(el.x, el.y)
            empty = True
        elif el.cmd == LINETO:
            empty = False
            current_contour.lineto(el.x, el.y)
        elif el.cmd == CURVETO:
            empty = False
            current_contour.curveto(el.ctrl1.x, el.ctrl1.y, el.ctrl2.x, el.ctrl2.y, el.x, el.y)
        elif el.cmd == CLOSE:
            current_contour.closepath()
    if not empty:
        contours.append(current_contour)
    return contours

</t>
<t tx="karstenw.20240123172920.13">def findpath(points, curvature=1.0):
    """ Constructs a smooth BezierPath from the given list of points.
        The curvature parameter offers some control on how separate segments are stitched together:
        from straight angles to smooth curves.
        Curvature is only useful if the path has more than three points.
    """
    
    # The list of points consists of Point objects,
    # but it shouldn't crash on something straightforward
    # as someone supplying a list of (x,y)-tuples.
    from types import TupleType
    for i, pt in enumerate(points):
        if type(pt) == TupleType:
            points[i] = Point(pt[0], pt[1])
    
    # No points: return nothing.
    if len(points) == 0: return None
    # One point: return a path with a single MOVETO-point.
    if len(points) == 1:
        path = BezierPath(None)
        path.moveto(points[0].x, points[0].y)
        return path
    # Two points: path with a single straight line.
    if len(points) == 2:
        path = BezierPath(None)
        path.moveto(points[0].x, points[0].y)
        path.lineto(points[1].x, points[1].y)
        return path
    # Zero curvature means path with straight lines.
    curvature = max(0, min(1, curvature))
    if curvature == 0:
        path = BezierPath(None)
        path.moveto(points[0].x, points[0].y)
        for i in range(len(points)): 
            path.lineto(points[i].x, points[i].y)
        return path
    
    # Construct the path with curves.
    curvature = 4 + (1.0-curvature)*40
    
    # The first point's ctrl1 and ctrl2 and last point's ctrl2
    # will be the same as that point's location;
    # we cannot infer how the path curvature started or will continue.
    dx = {0: 0, len(points)-1: 0}
    dy = {0: 0, len(points)-1: 0}
    bi = {1: -0.25}
    ax = {1: (points[2].x-points[0].x-dx[0]) / 4}
    ay = {1: (points[2].y-points[0].y-dy[0]) / 4}
    for i in range(2, len(points)-1):
        bi[i] = -1 / (curvature + bi[i-1])
        ax[i] = -(points[i+1].x-points[i-1].x-ax[i-1]) * bi[i]
        ay[i] = -(points[i+1].y-points[i-1].y-ay[i-1]) * bi[i]
        
    r = range(1, len(points)-1)
    r.reverse()
    for i in r:
        dx[i] = ax[i] + dx[i+1] * bi[i]
        dy[i] = ay[i] + dy[i+1] * bi[i]

    path = BezierPath(None)
    path.moveto(points[0].x, points[0].y)
    for i in range(len(points)-1):
        path.curveto(points[i].x + dx[i], 
                     points[i].y + dy[i],
                     points[i+1].x - dx[i+1], 
                     points[i+1].y - dy[i+1],
                     points[i+1].x,
                     points[i+1].y)
    
    return path

</t>
<t tx="karstenw.20240123172920.14">def insert_point(path, t):
    """ Inserts an extra point at t.
    """
    
    # Find the points before and after t on the path.
    i, t, closeto = _locate(path, t)
    x0 = path[i].x
    y0 = path[i].y
    p1 = path[i+1]
    p1cmd, x3, y3, x1, y1, x2, y2 = p1.cmd, p1.x, p1.y, p1.ctrl1.x, p1.ctrl1.y, p1.ctrl2.x, p1.ctrl2.y
    
    # Construct the new point at t.
    if p1cmd == CLOSE:
        pt_cmd = LINETO
        pt_x, pt_y = linepoint(t, x0, y0, closeto.x, closeto.y)
    elif p1cmd == LINETO:
        pt_cmd = LINETO
        pt_x, pt_y = linepoint(t, x0, y0, x3, y3)
    elif p1cmd == CURVETO:
        pt_cmd = CURVETO
        pt_x, pt_y, pt_c1x, pt_c1y, pt_c2x, pt_c2y, pt_h1x, pt_h1y, pt_h2x, pt_h2y = \
            curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3, True)
    else:
        raise PathError( "Locate should not return a MOVETO" )

    # NodeBox for OpenGL modifies the path in place,
    # NodeBox for Mac OS X returned a path copy (see inactive code below).
    if pt_cmd == CURVETO:
        path[i+1].ctrl1.x = pt_c2x
        path[i+1].ctrl1.y = pt_c2y
        path[i+1].ctrl2.x = pt_h2x
        path[i+1].ctrl2.y = pt_h2y
        path.insert(i+1, PathElement(cmd=CURVETO, pts=[(pt_h1x, pt_h1y), (pt_c1x, pt_c1y), (pt_x, pt_y)]))
    elif pt_cmd == LINETO:
        path.insert(i+1, PathElement(cmd=LINETO, pts=[(pt_x, pt_y)]))
    else:
        raise PathError( "Didn't expect pt_cmd %s here" % (pt_cmd,) )
    return path[i+1]
    
    #new_path = BezierPath(None)
    #new_path.moveto(path[0].x, path[0].y)
    #for j in range(1, len(path)):
    #    if j == i+1:
    #        if pt_cmd == CURVETO:
    #            new_path.curveto(pt_h1x, pt_h1y, pt_c1x, pt_c1y, pt_x, pt_y)
    #            new_path.curveto(pt_c2x, pt_c2y, pt_h2x, pt_h2y, path[j].x, path[j].y)
    #        elif pt_cmd == LINETO:
    #            new_path.lineto(pt_x, pt_y)
    #            if path[j].cmd != CLOSE:
    #                new_path.lineto(path[j].x, path[j].y)
    #            else:
    #                new_path.closepath()
    #        else:
    #            raise PathError, "Didn't expect pt_cmd %s here" % pt_cmd
    #    else:
    #        if path[j].cmd == MOVETO:
    #            new_path.moveto(path[j].x, path[j].y)
    #        if path[j].cmd == LINETO:
    #            new_path.lineto(path[j].x, path[j].y)
    #        if path[j].cmd == CURVETO:
    #            new_path.curveto(path[j].ctrl1.x, path[j].ctrl1.y,
    #                         path[j].ctrl2.x, path[j].ctrl2.y,
    #                         path[j].x, path[j].y)
    #        if path[j].cmd == CLOSE:
    #            new_path.closepath()
                
    return new_path

</t>
<t tx="karstenw.20240123172920.15">def arc(x1, y1, x2, y2, angle=0, extent=90):
    """ Compute a cubic Bezier approximation of an elliptical arc.
        (x1, y1) and (x2, y2) are the corners of the enclosing rectangle.
        The coordinate system has coordinates that increase to the right and down.
        Angles, measured in degrees, start with 0 to the right (the positive X axis) 
        and increase counter-clockwise.
        The arc extends from angle to angle+extent.
        I.e. angle=0 and extent=180 yields an openside-down semi-circle.
        The resulting coordinates are of the form (x1,y1, x2,y2, x3,y3, x4,y4)
        such that the curve goes from (x1, y1) to (x4, y4) 
        with (x2, y2) and (x3, y3) as their respective Bezier control points.
    """
    x1, y1, x2, y2 = min(x1,x2), max(y1,y2), max(x1,x2), min(y1,y2)
    extent = min(max(extent, -360), 360)
    n = abs(extent) &lt;= 90 and 1 or int(ceil(abs(extent) / 90.0))
    a = float(extent) / n
    cx = float(x1 + x2) / 2
    cy = float(y1 + y2) / 2
    rx = float(x2 - x1) / 2
    ry = float(y2 - y1) / 2
    a2 = radians(a) / 2
    kappa = abs(4.0 / 3 * (1 - cos(a2)) / sin(a2))
    points = []
    for i in range(n):
        theta0 = radians(angle + (i+0) * a)
        theta1 = radians(angle + (i+1) * a)
        c0, c1 = cos(theta0), cos(theta1)
        s0, s1 = sin(theta0), sin(theta1)
        k = a &gt; 0 and -kappa or kappa
        points.append((
            cx + rx * c0,
            cy - ry * s0,
            cx + rx * (c0 + k * s0),
            cy - ry * (s0 - k * c0),
            cx + rx * (c1 - k * s1),
            cy - ry * (s1 + k * c1),
            cx + rx * c1,
            cy - ry * s1
        ))
    return points

</t>
<t tx="karstenw.20240123172920.16">def arcto(x1, y1, rx, ry, phi, large_arc, sweep, x2, y2):
    """ An elliptical arc approximated with Bezier curves or a line segment.
        Algorithm taken from the SVG 1.1 Implementation Notes:
        http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
    """
    
    def angle(x1, y1, x2, y2):
        a = degrees(acos(min(max((x1*x2 + y1*y2) / hypot(x1,y1) * hypot(x2,y2), -1), 1)))
        return x1*y2 &gt; y1*x2 and a or -a
        
    def abspt(x, y, cphi, sphi, mx, my):
        return (x * cp - y * sp + mx, 
                x * sp + y * cp + my)
    
    if x1 == x2 and y1 == y2:
        return []
    if rx == 0 or ry == 0: # Line segment.
        return [(x2,y2)]
    rx, ry, phi = abs(rx), abs(ry), phi % 360
    cp = cos(radians(phi))
    sp = sin(radians(phi))

    # Rotate to the local coordinates.
    dx = 0.5 * (x1 - x2)
    dy = 0.5 * (y1 - y2)
    x  =  cp * dx + sp * dy
    y  = -sp * dx + cp * dy
    
    # If rx, ry and phi are such that there is no solution 
    # (basically, the ellipse is not big enough to reach from (x1, y1) to (x2, y2)) 
    # then the ellipse is scaled up uniformly until there is exactly one solution 
    # (until the ellipse is just big enough).
    s = (x/rx)**2 + (y/ry)**2
    if s &gt; 1.0:
        s = sqrt(s); rx, ry = rx*s, ry*s

    # Solve for the center in the local coordinates.
    a = sqrt(max((rx*ry)**2 - (rx*y)**2 - (ry*x)**2, 0) / ((rx*y)**2 + (ry*x)**2))
    a = large_arc == sweep and -a or a 
    cx =  a * rx * y / ry
    cy = -a * ry * x / rx

    # Transform back.
    mx = 0.5 * (x1 + x2)
    my = 0.5 * (y1 + y2)

    # Compute the start angle and the angular extent of the arc.
    # Note that theta is local to the phi-rotated coordinate space.
    dx1 = ( x - cx) / rx
    dy1 = ( y - cy) / ry
    dx2 = (-x - cx) / rx
    dy2 = (-y - cy) / ry
    theta = angle(1.0, 0.0, dx1, dy1)
    delta = angle(dx1, dy1, dx2, dy2)
    if not sweep and delta &gt; 0: delta -= 360
    if sweep and delta &lt; 0: delta += 360

    # Break it apart into Bezier curves.
    points  = []
    handles = arc(cx-rx, cy-ry, cx+rx, cy+ry, theta, delta)
    for x1, y1, x2, y2, x3, y3, x4, y4 in handles:
        points.append((
            abspt(x2, y2, cp, sp, mx, my) + \
            abspt(x3, y3, cp, sp, mx, my) + \
            abspt(x4, y4, cp, sp, mx, my)
        ))
    return points
</t>
<t tx="karstenw.20240123172920.2">class DynamicPathElement(PathElement):
    # Not a "fixed" point in the BezierPath, but calculated with BezierPath.point().
    pass

</t>
<t tx="karstenw.20240123172920.3">def linepoint(t, x0, y0, x1, y1):
    """ Returns coordinates for point at t on the line.
        Calculates the coordinates of x and y for a point at t on a straight line.
        The t parameter is a number between 0.0 and 1.0,
        x0 and y0 define the starting point of the line, 
        x1 and y1 the ending point of the line.
    """
    out_x = x0 + t * (x1-x0)
    out_y = y0 + t * (y1-y0)
    return (out_x, out_y)

</t>
<t tx="karstenw.20240123172920.4">def linelength(x0, y0, x1, y1):
    """ Returns the length of the line.
    """
    a = pow(abs(x0 - x1), 2)
    b = pow(abs(y0 - y1), 2)
    return sqrt(a+b)

</t>
<t tx="karstenw.20240123172920.5">def curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3, handles=False):
    """ Returns coordinates for point at t on the spline.
        Calculates the coordinates of x and y for a point at t on the cubic bezier spline, 
        and its control points, based on the de Casteljau interpolation algorithm.
        The t parameter is a number between 0.0 and 1.0,
        x0 and y0 define the starting point of the spline,
        x1 and y1 its control point,
        x3 and y3 the ending point of the spline,
        x2 and y2 its control point.
        If the handles parameter is set, returns not only the point at t,
        but the modified control points of p0 and p3 should this point split the path as well.
    """
    mint = 1 - t
    x01 = x0 * mint + x1 * t
    y01 = y0 * mint + y1 * t
    x12 = x1 * mint + x2 * t
    y12 = y1 * mint + y2 * t
    x23 = x2 * mint + x3 * t
    y23 = y2 * mint + y3 * t
    out_c1x = x01 * mint + x12 * t
    out_c1y = y01 * mint + y12 * t
    out_c2x = x12 * mint + x23 * t
    out_c2y = y12 * mint + y23 * t
    out_x = out_c1x * mint + out_c2x * t
    out_y = out_c1y * mint + out_c2y * t
    if not handles:
        return (out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y)
    else:
        return (out_x, out_y, out_c1x, out_c1y, out_c2x, out_c2y, x01, y01, x23, y23)

</t>
<t tx="karstenw.20240123172920.6">def curvelength(x0, y0, x1, y1, x2, y2, x3, y3, n=20):
    """ Returns the length of the spline.
        Integrates the estimated length of the cubic bezier spline defined by x0, y0, ... x3, y3, 
        by adding the lengths of linear lines between points at t.
        The number of points is defined by n 
        (n=10 would add the lengths of lines between 0.0 and 0.1, between 0.1 and 0.2, and so on).
        The default n=20 is fine for most cases, usually resulting in a deviation of less than 0.01.
    """
    length = 0
    xi = x0
    yi = y0
    for i in range(n):
        t = 1.0 * (i+1) / n
        pt_x, pt_y, pt_c1x, pt_c1y, pt_c2x, pt_c2y = \
            curvepoint(t, x0, y0, x1, y1, x2, y2, x3, y3)
        c = sqrt(pow(abs(xi-pt_x),2) + pow(abs(yi-pt_y),2))
        length += c
        xi = pt_x
        yi = pt_y
    return length

# Fast C implementations:
try:
    from nglbezier import linepoint, linelength, curvepoint, curvelength
    print( "FAST BEZIER" )
except Exception as err:
    print( err )
    print( "SLOW BEZIER" )
    pass

</t>
<t tx="karstenw.20240123172920.7">def segment_lengths(path, relative=False, n=20):
    """ Returns a list with the lengths of each segment in the path.
    """
    lengths = []
    first = True
    for el in path:
        if first == True:
            close_x, close_y = el.x, el.y
            first = False
        elif el.cmd == MOVETO:
            close_x, close_y = el.x, el.y
            lengths.append(0.0)
        elif el.cmd == CLOSE:
            lengths.append(linelength(x0, y0, close_x, close_y))
        elif el.cmd == LINETO:
            lengths.append(linelength(x0, y0, el.x, el.y))
        elif el.cmd == CURVETO:
            x3, y3, x1, y1, x2, y2 = el.x, el.y, el.ctrl1.x, el.ctrl1.y, el.ctrl2.x, el.ctrl2.y
            lengths.append(curvelength(x0, y0, x1, y1, x2, y2, x3, y3, n))
        if el.cmd != CLOSE:
            x0 = el.x
            y0 = el.y
    if relative:
        length = sum(lengths)
        try:
            # Relative segment lengths' sum is 1.0.
            return list(map(lambda l: l / length, lengths))
        except ZeroDivisionError:
            # If the length is zero, just return zero for all segments
            return [0.0] * len(lengths)
    else:
        return lengths

</t>
<t tx="karstenw.20240123172920.8">def length(path, segmented=False, n=20):
    """ Returns the length of the path.
        Calculates the length of each spline in the path, using n as a number of points to measure.
        When segmented is True, returns a list containing the individual length of each spline
        as values between 0.0 and 1.0, defining the relative length of each spline
        in relation to the total path length.
    """
    if not segmented:
        return sum(segment_lengths(path, n=n), 0.0)
    else:
        return segment_lengths(path, relative=True, n=n)

</t>
<t tx="karstenw.20240123172920.9">def _locate(path, t, segments=None):
    """ Locates t on a specific segment in the path.
        Returns (index, t, PathElement)
        A path is a combination of lines and curves (segments).
        The returned index indicates the start of the segment that contains point t.
        The returned t is the absolute time on that segment,
        in contrast to the relative t on the whole of the path.
        The returned point is the last MOVETO, any subsequent CLOSETO after i closes to that point.
        When you supply the list of segment lengths yourself, as returned from length(path, segmented=True), 
        point() works about thirty times faster in a for-loop since it doesn't need to recalculate 
        the length during each iteration. 
    """
    if segments == None:
        segments = segment_lengths(path, relative=True) 
    if len(segments) == 0:
        raise PathError( "The given path is empty" )
    for i, el in enumerate(path):
        if i == 0 or el.cmd == MOVETO:
            closeto = Point(el.x, el.y)
        if t &lt;= segments[i] or i == len(segments)-1: 
            break
        else: 
            t -= segments[i]
    try:
        t /= segments[i]
    except ZeroDivisionError: 
        pass
    if i == len(segments)-1 and segments[i] == 0: i -= 1
    return (i, t, closeto)

</t>
<t tx="karstenw.20240123172922.1">from . import context
from . import physics
from . import shader

import nglbezier
import nglgeometry

import nglnoise # import nglnoise as noise
# noise = nglnoise.noise
from . import noise


from .context import *

physics.line    = context.line
physics.ellipse = context.ellipse
physics.Text    = context.Text

#-----------------------------------------------------------------------------------------------------
# Expose the canvas and some common canvas properties on global level.
# Some magic constants from NodeBox are commands here:
# - WIDTH  =&gt; width()
# - HEIGHT =&gt; height()
# - FRAME  =&gt; frame()

canvas = Canvas()

</t>
<t tx="karstenw.20240123172922.2">def size(width=None, height=None):
    if width is not None:
        canvas.width = width
    if height is not None:
        canvas.height = height
    return canvas.size

</t>
<t tx="karstenw.20240123172922.3">def speed(fps=None):
    if fps is not None:
        canvas.fps = fps
    return canvas.fps

</t>
<t tx="karstenw.20240123172922.4">def frame():
    return canvas.frame
    
</t>
<t tx="karstenw.20240123172922.5">def clear():
    canvas.clear()
</t>
<t tx="karstenw.20240126154716.1">#=====================================================================================================

#--- BEZIER MATH ------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126154749.1">#--- BEZIER PATH LENGTH ------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126154832.1">#--- BEZIER PATH POINT -------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126154916.1">#--- BEZIER PATH CONTOURS ----------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126154940.1">#--- BEZIER PATH FROM POINTS -------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126155025.1">#--- BEZIER PATH INSERT POINT ------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126155058.1">#=====================================================================================================

#--- BEZIER ARC --------------------------------------------------------------------------------------

# Copyright (c) 2005-2008, Enthought, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification, 
# are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, 
# this list of conditions and the following disclaimer.
# Redistributions in binary form must reproduce the above copyright notice, 
# this list of conditions and the following disclaimer in the documentation 
# and/or other materials provided with the distribution.
# Neither the name of Enthought, Inc. nor the names of its contributors 
# may be used to endorse or promote products derived from this software 
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
# IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</t>
<t tx="karstenw.20240126155307.1">#=====================================================================================================

#--- CACHING -----------------------------------------------------------------------------------------
# OpenGL Display Lists offer a simple way to precompile batches of OpenGL commands.
# The drawback is that the commands, once compiled, can't be modified.

</t>
<t tx="karstenw.20240126155339.1">#=====================================================================================================

#--- COLOR -------------------------------------------------------------------------------------------

RGB = "RGB"
HSB = "HSB"
XYZ = "XYZ"
LAB = "LAB"

_background  = None    # Current state background color.
_fill        = None    # Current state fill color.
_stroke      = None    # Current state stroke color.
_strokewidth = 1       # Current state strokewidth.
_strokestyle = "solid" # Current state strokestyle.
_alpha       = 1       # Current state alpha transparency.

</t>
<t tx="karstenw.20240126155445.1">#--- COLOR SPACE -------------------------------------------------------------------------------------
# Transformations between RGB, HSB, CIE XYZ and CIE LAB color spaces.
# http://www.easyrgb.com/math.php

</t>
<t tx="karstenw.20240126155525.1">#--- COLOR ROTATION ----------------------------------------------------------------------------------

# Approximation of the RYB color wheel.
# In HSB, colors hues range from 0 to 360, 
# but on the color wheel these values are not evenly distributed. 
# The second tuple value contains the actual value on the wheel (angle).
_colorwheel = [
    (  0,   0), ( 15,   8), ( 30,  17), ( 45,  26),
    ( 60,  34), ( 75,  41), ( 90,  48), (105,  54),
    (120,  60), (135,  81), (150, 103), (165, 123),
    (180, 138), (195, 155), (210, 171), (225, 187),
    (240, 204), (255, 219), (270, 234), (285, 251),
    (300, 267), (315, 282), (330, 298), (345, 329), (360, 360)
]

</t>
<t tx="karstenw.20240126155550.1">#--- COLOR MIXIN -------------------------------------------------------------------------------------
# Drawing commands like rect() have optional parameters fill and stroke to set the color directly.

</t>
<t tx="karstenw.20240126155609.1">#--- COLOR PLANE -------------------------------------------------------------------------------------
# Not part of the standard API but too convenient to leave out.

</t>
<t tx="karstenw.20240126155632.1">#=====================================================================================================

#--- TRANSFORMATIONS ---------------------------------------------------------------------------------
# Unlike NodeBox, all transformations are CORNER-mode and originate from the bottom-left corner.

# Example: using Transform to get a transformed path.
# t = Transform()
# t.rotate(45)
# p = BezierPath()
# p.rect(10,10,100,70)
# p = t.transform_path(p)
# p.contains(x,y) # now we can check if the mouse is in the transformed shape.
Transform = geometry.AffineTransform

</t>
<t tx="karstenw.20240126155731.1">#=====================================================================================================

#--- DRAWING PRIMITIVES ------------------------------------------------------------------------------
# Drawing primitives: Point, line, rect, ellipse, arrow. star.
# The fill and stroke are two different shapes put on top of each other.

Point = geometry.Point

</t>
<t tx="karstenw.20240126155903.1">#=====================================================================================================

#--- BEZIER PATH -------------------------------------------------------------------------------------
# A BezierPath class with lineto(), curveto() and moveto() commands.
# It has all the path math functionality from NodeBox and a ray casting algorithm for contains().
# A number of caching mechanisms are used for performance:
# drawn vertices, segment lengths, path bounds, and a hit test area for BezierPath.contains().
# For optimal performance, the path should be created once (not every frame) and left unmodified.
# When points in the path are added, removed or modified, a _dirty flag is set.
# When dirty, the cache will be cleared and the new path recalculated.
# If the path is being drawn with a fill color, this means doing tessellation
# (i.e. additional math for finding out if parts overlap and punch a hole in the shape).

MOVETO  = "moveto"
LINETO  = "lineto"
CURVETO = "curveto"
CLOSE   = "close"

RELATIVE = "relative" # Number of straight lines to represent a curve = 20% of curve length.
RELATIVE_PRECISION = 0.2

</t>
<t tx="karstenw.20240126155952.1">#--- BEZIER EDITOR -----------------------------------------------------------------------------------

EQUIDISTANT = "equidistant"
IN, OUT, BOTH = "in", "out", "both" # Drag pt1.ctrl2, pt2.ctrl1 or both simultaneously?

</t>
<t tx="karstenw.20240126160010.1">#--- POINT ANGLES ------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160022.1">#--- CLIPPING PATH -----------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160104.1">#--- SUPERSHAPE --------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160123.1">#=====================================================================================================

#--- IMAGE -------------------------------------------------------------------------------------------
# Textures and quad vertices are cached for performance.
# Textures remain in cache for the duration of the program.
# Quad vertices are cached as Display Lists and destroyed when the Image object is deleted.
# For optimal performance, images should be created once (not every frame) and its quads left unmodified.
# Performance should be comparable to (moving) pyglet.Sprites drawn in a batch.

pow2 = [2**n for n in range(20)] # [1, 2, 4, 8, 16, 32, 64, ...]

</t>
<t tx="karstenw.20240126160327.1">#--- PIXELS ------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160358.1">#--- OFFSCREEN RENDERING -----------------------------------------------------------------------------
# Offscreen buffers can be used to render images from paths etc. 
# or to apply filters on images before drawing them to the screen.
# There are several ways to draw offscreen:
# - render(img, filter): applies the given filter to the image and returns it.
# - procedural(function, width, height): execute the drawing commands in function inside an image.
# - Create your own subclass of OffscreenBuffer with a draw() method:
#   class MyBuffer(OffscreenBuffer):
#       def draw(self): pass
# - Define drawing commands between OffscreenBuffer.push() and pop():
#   b = MyBuffer()
#   b.push()
#   # drawing commands
#   b.pop()
#   img = Image(b.render())
#
# The shader.py module already defines several filters that use an offscreen buffer, for example:
# blur(), adjust(), multiply(), twirl(), ...
#
# The less you change about an offscreen buffer, the faster it runs.
# This includes switching it on and off and changing its size.

from .shader import *

</t>
<t tx="karstenw.20240126160433.1">#=====================================================================================================

#--- FONT --------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160534.1">#--- FONT MIXIN --------------------------------------------------------------------------------------
# The text() command has optional parameters font, fontsize, fontweight, bold, italic, lineheight and align.

</t>
<t tx="karstenw.20240126160602.1">#--- TEXT --------------------------------------------------------------------------------------------
# Text is cached for performance.
# For optimal performance, texts should be created once (not every frame) and left unmodified.
# Dynamic texts use a cache of recycled Text objects.

# pyglet.text.Label leaks memory when deleted, because its old batch continues to reference
# loaded font/fontsize/bold/italic glyphs.
# Adding all labels to our own batch remedies this.
_label_batch = pyglet.graphics.Batch()

</t>
<t tx="karstenw.20240126160625.1">#--- TEXTPATH ----------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160653.1">#=====================================================================================================

#--- UTILITIES ---------------------------------------------------------------------------------------

_RANDOM_MAP = [90.0, 9.00, 4.00, 2.33, 1.50, 1.00, 0.66, 0.43, 0.25, 0.11, 0.01]
</t>
<t tx="karstenw.20240126160719.1">#=====================================================================================================

#--- PROTOTYPE ----------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160737.1">#=====================================================================================================

#--- TRANSITION --------------------------------------------------------------------------------------
# Transition.update() will tween from the last value to transition.set() new value in the given time.
# Transitions are used as attributes (e.g. position, rotation) for the Layer class.

TIME = 0 # the current time in this frame changes when the canvas is updated
    
LINEAR = "linear"
SMOOTH = "smooth"

</t>
<t tx="karstenw.20240126160803.1">#--- LAYER -------------------------------------------------------------------------------------------
# The Layer class is responsible for the following:
# - it has a draw() method to override; all sorts of NodeBox drawing commands can be put here,
# - it has a transformation origin point and rotates/scales its drawn items as a group,
# - it has child layers that transform relative to this layer,
# - when its attributes (position, scale, angle, ...) change, they will tween smoothly over time. 

_UID = 0
</t>
<t tx="karstenw.20240126160845.1">#--- GROUP -------------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240126160906.1">#=====================================================================================================

#--- MOUSE -------------------------------------------------------------------------------------------

# Mouse cursors:
DEFAULT = "default"
HIDDEN  = "hidden"
CROSS   = pyglet.window.Window.CURSOR_CROSSHAIR
HAND    = pyglet.window.Window.CURSOR_HAND
TEXT    = pyglet.window.Window.CURSOR_TEXT
WAIT    = pyglet.window.Window.CURSOR_WAIT

# Mouse buttons:
LEFT    = "left"
RIGHT   = "right"
MIDDLE  = "middle"

</t>
<t tx="karstenw.20240126160950.1">#=====================================================================================================

#--- CANVAS ------------------------------------------------------------------------------------------

VERY_LIGHT_GREY = 0.95

FRAME = 0

# Window styles.
WINDOW_DEFAULT    = pyglet.window.Window.WINDOW_STYLE_DEFAULT
WINDOW_BORDERLESS = pyglet.window.Window.WINDOW_STYLE_BORDERLESS

# Configuration settings for the canvas.
# http://www.pyglet.org/doc/programming_guide/opengl_configuration_options.html
# The stencil buffer is enabled (we need it to do clipping masks).
# Multisampling will be enabled (if possible) to do anti-aliasing.
settings = OPTIMAL = dict(
#      buffer_size = 32, # Let Pyglet decide automatically.
#         red_size = 8,
#       green_size = 8,
#        blue_size = 8,
        depth_size = 24,
      stencil_size = 1,
        alpha_size = 8, 
     double_buffer = 1,
    sample_buffers = 1, 
           samples = 4
)

</t>
<t tx="karstenw.20240126161010.1">#--- PROFILER ----------------------------------------------------------------------------------------

CUMULATIVE = "cumulative"
SLOWEST    = "slowest"

_profile_canvas = None
_profile_frames = 100
</t>
<t tx="karstenw.20240126161026.1">#--- LIBRARIES ---------------------------------------------------------------------------------------
# Import the library and assign it a _ctx variable containing the current context.
# This mimics the behavior in NodeBox for Mac OS X.

</t>
<t tx="karstenw.20240126161053.1"></t>
<t tx="karstenw.20240317203023.1">#--- GRAPH -------------------------------------------------------------------------------------------

# Return value of Graph.shortest_paths().
# Dictionary values can be accessed by Node as well as by node id.
</t>
<t tx="karstenw.20240317203143.1">#--- GRAPH TRAVERSAL ---------------------------------------------------------------------------------
</t>
<t tx="karstenw.20240317203210.1">#--- GRAPH THEORY ------------------------------------------------------------------------------------

</t>
<t tx="karstenw.20240317203259.1">#--- GRAPH THEORY | CLIQUE ---------------------------------------------------------------------------

</t>
<t tx="karstenw.20240317203331.1">#--- GRAPH MAINTENANCE -------------------------------------------------------------------------------
# Utility commands for safe linking and unlinking of nodes,
# with respect for the surrounding nodes.

</t>
<t tx="karstenw.20240317204938.1">def __hash__(self):
    # print(hash(repr(self)))
    return hash(repr(self))
</t>
</tnodes>
</leo_file>
